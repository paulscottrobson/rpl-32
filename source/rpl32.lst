
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -D debug=2 -q -c -o rpl32.prg -L rpl32.lst main.asm
; Thu Oct 10 15:29:00 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					debug=2

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; build the interpreter here
=$0c00					StackAddress = $0C00 						; 1k of stack space (256 x 32 bits)
=$1000					MemoryStart = $1000 						; system memory starts here
=$9f00					MemoryEnd = $9F00 							; and ends here.
=$0bff					StructureStack = $0BFF 						; structure stack (works down to $xx00)
=$0800					ExtDataArea = $0800 						; space where non zp data goes
=$0900					InputBuffer = $0900 						; Input Buffer
=$0a00					TokeniseBuffer = $0A00						; Tokenising buffer
=16					HashTableSize = 16 							; hash tables to search.
>0010					CodePtr: 		.word ? 					; code pointer
>0012					StructSP: 		.word ?						; structure stack pointer
>0014					zTemp0:			.word ?						; temporary words
>0016					zTemp1: 		.word ?
>0018					zTemp2: 		.word ?
>001a					zTemp3: 		.word ?
>001c					zTemp4:			.word ?
>001e					zLTemp1:		.dword ?					; temporary longs
>0022					idDataAddr:		.word ? 					; data address.
>0800					SBuffer:		.fill 32 					; string buffer
>0820					SBPosition:		.byte ? 					; position in String Buffer
>0821					NumConvCount:	.byte ? 					; used in int to string
>0822					breakCount:		.byte ? 					; used to stop break firing every execution.
>0823					SignCount:		.byte ?						; sign count for divide
>0824					NumSuppress:	.byte ? 					; zero suppression flag
>0825					IFSHexFlag:		.byte ? 					; $FF if hex, $00 if dec
>1000					AZVariables:	.fill	26*4 				; 26 x 4 byte variables, which are A-Z
>1068					HashTable: 		.fill 	HashTableSize * 2 	; n x 2 links for the hash tables.
>1088	00 00				VarMemory:		.word 	0 					; next free byte available for VARIABLES (going up)
>108a	00 00				AllocMemory: 	.word 	0 					; last free byte availabel for ALLOC (going down)
=4352					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0c00					stack0 = StackAddress
=3328					stack1 = StackAddress+256
=3584					stack2 = StackAddress+512
=3840					stack3 = StackAddress+768
="V"					IDT_VARIABLE = 'V'							; type markers for the information store.
="P"					IDT_PROCEDURE = 'P'							; standard procedure (e.g. in code)
="C"					IDT_CODEPROC = 'C'							; machine language procedure.
="F"					STM_FOR = 'F'								; structure markers (for/next)
="C"					STM_CALL = 'C'								; call & return  (& ;)
="R"					STM_REPEAT = 'R'							; repeat & until
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=5					CTH_ERROR = COL_MAGENTA
=7					CTH_TOKEN = COL_WHITE
=3					CTH_IDENT = COL_YELLOW
=10					CTH_COMMENT = COL_GREEN|COL_RVS
=9					CTH_LCOMMENT = COL_RED|COL_RVS
=5					CTH_STRING = COL_MAGENTA
=6					CTH_NUMBER = COL_CYAN
=5					CTH_LINENO = COL_MAGENTA
=147					SCM_CLS = 147 								; clear screen

;******  Return to file: main.asm


;******  Processing file: macro.asm


;******  Return to file: main.asm

.0f00	4c 00 a0	jmp $a000			jmp 	Start
.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 7e a2	jsr $a27e			jsr 	ExternInitialise 			; interface setup
.a006	a2 00		ldx #$00			ldx 	#0 							; display boot message
.a008					_Display:
.a008	bd a1 a0	lda $a0a1,x			lda 	BootMessage,x
.a00b	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a00e	e8		inx				inx
.a00f	bd a1 a0	lda $a0a1,x			lda 	BootMessage,x
.a012	d0 f4		bne $a008			bne 	_Display
.a014	a9 00		lda #$00			lda 	#(MemoryEnd-ProgramStart) & $FF
.a016	a0 8e		ldy #$8e			ldy 	#(MemoryEnd-ProgramStart) >>8
.a018	a2 00		ldx #$00			ldx 	#0
.a01a	20 3c a6	jsr $a63c			jsr 	ErrorPrint16
.a01d	a2 00		ldx #$00			ldx 	#0 							; clear extended data area
.a01f	9e 00 08	stz $0800,x	_ClearX:stz 	ExtDataArea,x 				; this is so any library data
.a022	e8		inx				inx 								; is zeroed on start up.
.a023	d0 fa		bne $a01f			bne 	_ClearX
.a025	a9 0d		lda #$0d			lda 	#13
.a027	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a02a	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a02d	a9 9f		lda #$9f			lda 	#MemoryEnd >> 8 			; set top of memory address.
.a02f	8d 8b 10	sta $108b			sta 	AllocMemory+1
.a032	9c 8a 10	stz $108a			stz 	AllocMemory
.a035	20 49 a5	jsr $a549			jsr 	ResetForRun
.a038	20 3e a5	jsr $a53e			jsr 	ResetCodePointer
.a03b					WarmStart:
.a03b	a9 06		lda #$06			lda 	#COL_CYAN
.a03d	20 ab a2	jsr $a2ab			jsr 	ExternColour
.a040	a9 4f		lda #$4f			lda 	#"O"
.a042	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a045	a9 4b		lda #$4b			lda 	#"K"
.a047	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a04a	a9 0d		lda #$0d			lda 	#13
.a04c	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a04f					NewCommand:
.a04f	8a		txa				txa
.a050	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack colour
.a052	9a		txs				txs
.a053	aa		tax				tax
.a054	a9 07		lda #$07			lda 	#COL_WHITE
.a056	20 ab a2	jsr $a2ab			jsr 	ExternColour
.a059	20 d3 a2	jsr $a2d3			jsr 	ExternInput 				; input text
.a05c	a9 00		lda #$00			lda 	#InputBuffer & $FF 			; codePtr = input buffer
.a05e	85 10		sta $10				sta 	codePtr
.a060	a9 09		lda #$09			lda 	#InputBuffer >> 8
.a062	85 11		sta $11				sta 	codePtr+1
.a064	a9 03		lda #$03			lda 	#(TokeniseBuffer+3) & $FF 	; zTemp1 is set up as a fake line
.a066	85 16		sta $16				sta 	zTemp1 						; with line number 0 by being
.a068	a9 0a		lda #$0a			lda 	#(TokeniseBuffer+3) >> 8 	; prefixed with three zeros
.a06a	85 17		sta $17				sta 	zTemp1+1
.a06c	9c 00 0a	stz $0a00			stz 	TokeniseBuffer+0			; put in those three zeroes
.a06f	9c 01 0a	stz $0a01			stz		TokeniseBuffer+1
.a072	9c 02 0a	stz $0a02			stz 	TokeniseBuffer+2
.a075	20 ac a7	jsr $a7ac			jsr 	Tokenise
.a078	a0 00		ldy #$00			ldy 	#0 							; see what's at the start re numbers
.a07a					SkipSpaces:
.a07a	b9 00 09	lda $0900,y			lda 	InputBuffer,y
.a07d	c8		iny				iny
.a07e	c9 20		cmp #$20			cmp 	#' '
.a080	f0 f8		beq $a07a			beq 	SkipSpaces
.a082	c9 30		cmp #$30			cmp 	#'0'
.a084	90 0e		bcc $a094			bcc 	ExecuteCLI
.a086	c9 3a		cmp #$3a			cmp 	#'9'+1
.a088	b0 0a		bcs $a094			bcs 	ExecuteCLI
.a08a	ad 00 09	lda $0900			lda 	InputBuffer
.a08d	c9 20		cmp #$20			cmp 	#' '
.a08f	f0 03		beq $a094			beq 	ExecuteCLI
.a091	4c 1d a9	jmp $a91d			jmp		EditProgram
.a094					ExecuteCLI:
.a094	a9 00		lda #$00			lda 	#TokeniseBuffer & 255 		; set tokenise buffer as faux line
.a096	85 10		sta $10				sta 	codePtr
.a098	a9 0a		lda #$0a			lda 	#TokeniseBuffer >> 8
.a09a	85 11		sta $11				sta 	codePtr+1
.a09c	a0 03		ldy #$03			ldy 	#3
.a09e	4c 84 a3	jmp $a384			jmp 	Execute 					; and run it
.a0a1					BootMessage:

;******  Processing file: generated/bootmessage.inc

>a0a1	2a 2a 2a 2a 20 52 50 4c			.byte $2a,$2a,$2a,$2a,$20,$52,$50,$4c,$2f,$33,$32,$20,$49,$4e,$54,$45,$52,$50,$52,$45,$54,$45,$52,$20,$2a,$2a,$2a,$2a,$0d,$0d,$57,$52,$49,$54,$54,$45,$4e,$20,$42,$59,$20,$50,$41,$55,$4c,$20,$52,$4f,$42,$53,$4f,$4e,$20,$32,$30,$31,$39,$0d,$0d,$42,$55,$49,$4c,$44,$3a,$39,$20,$44,$41,$54,$45,$3a,$31,$30,$2d,$4f,$43,$54,$2d,$32,$30,$31,$39,$0d,$0d,$4d,$45,$4d,$4f,$52,$59,$20,$41,$56,$41,$49,$4c,$41,$42,$4c,$45,$20,$00
>a0a9	2f 33 32 20 49 4e 54 45 52 50 52 45 54 45 52 20
>a0b9	2a 2a 2a 2a 0d 0d 57 52 49 54 54 45 4e 20 42 59
>a0c9	20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32 30 31
>a0d9	39 0d 0d 42 55 49 4c 44 3a 39 20 44 41 54 45 3a
>a0e9	31 30 2d 4f 43 54 2d 32 30 31 39 0d 0d 4d 45 4d
>a0f9	4f 52 59 20 41 56 41 49 4c 41 42 4c 45 20 00

;******  Return to file: main.asm


;******  Processing file: generated/tables.inc

.a108					KeywordText:
>a108	01 21					.byte $01,$21                          ; $10 !
>a10a	01 2a					.byte $01,$2a                          ; $11 *
>a10c	01 2b					.byte $01,$2b                          ; $12 +
>a10e	02 2b 2b				.byte $02,$2b,$2b                      ; $13 ++
>a111	01 2d					.byte $01,$2d                          ; $14 -
>a113	02 2d 2d				.byte $02,$2d,$2d                      ; $15 --
>a116	01 2e					.byte $01,$2e                          ; $16 .
>a118	01 2f					.byte $01,$2f                          ; $17 /
>a11a	01 3b					.byte $01,$3b                          ; $18 ;
>a11c	01 3c					.byte $01,$3c                          ; $19 <
>a11e	02 3c 3c				.byte $02,$3c,$3c                      ; $1a <<
>a121	02 3c 3d				.byte $02,$3c,$3d                      ; $1b <=
>a124	02 3c 3e				.byte $02,$3c,$3e                      ; $1c <>
>a127	01 3d					.byte $01,$3d                          ; $1d =
>a129	01 3e					.byte $01,$3e                          ; $1e >
>a12b	02 3e 3d				.byte $02,$3e,$3d                      ; $1f >=
>a12e	02 3e 3e				.byte $02,$3e,$3e                      ; $20 >>
>a131	01 40					.byte $01,$40                          ; $21 @
>a133	03 41 42 53				.byte $03,$41,$42,$53                  ; $22 ABS
>a137	05 41 4c 4c 4f 43			.byte $05,$41,$4c,$4c,$4f,$43          ; $23 ALLOC
>a13d	03 41 4e 44				.byte $03,$41,$4e,$44                  ; $24 AND
>a141	06 41 53 53 45 52 54			.byte $06,$41,$53,$53,$45,$52,$54      ; $25 ASSERT
>a148	02 43 21				.byte $02,$43,$21                      ; $26 C!
>a14b	02 43 40				.byte $02,$43,$40                      ; $27 C@
>a14e	03 43 4c 52				.byte $03,$43,$4c,$52                  ; $28 CLR
>a152	03 44 45 46				.byte $03,$44,$45,$46                  ; $29 DEF
>a156	04 44 52 4f 50				.byte $04,$44,$52,$4f,$50              ; $2a DROP
>a15b	03 44 55 50				.byte $03,$44,$55,$50                  ; $2b DUP
>a15f	04 45 4c 53 45				.byte $04,$45,$4c,$53,$45              ; $2c ELSE
>a164	03 45 4e 44				.byte $03,$45,$4e,$44                  ; $2d END
>a168	05 45 4e 44 49 46			.byte $05,$45,$4e,$44,$49,$46          ; $2e ENDIF
>a16e	03 46 4f 52				.byte $03,$46,$4f,$52                  ; $2f FOR
>a172	02 49 46				.byte $02,$49,$46                      ; $30 IF
>a175	05 49 4e 44 45 58			.byte $05,$49,$4e,$44,$45,$58          ; $31 INDEX
>a17b	04 4c 49 53 54				.byte $04,$4c,$49,$53,$54              ; $32 LIST
>a180	04 4c 4f 41 44				.byte $04,$4c,$4f,$41,$44              ; $33 LOAD
>a185	03 4d 4f 44				.byte $03,$4d,$4f,$44                  ; $34 MOD
>a189	06 4e 45 47 41 54 45			.byte $06,$4e,$45,$47,$41,$54,$45      ; $35 NEGATE
>a190	03 4e 45 57				.byte $03,$4e,$45,$57                  ; $36 NEW
>a194	04 4e 45 58 54				.byte $04,$4e,$45,$58,$54              ; $37 NEXT
>a199	03 4e 49 50				.byte $03,$4e,$49,$50                  ; $38 NIP
>a19d	03 4e 4f 54				.byte $03,$4e,$4f,$54                  ; $39 NOT
>a1a1	03 4f 4c 44				.byte $03,$4f,$4c,$44                  ; $3a OLD
>a1a5	02 4f 52				.byte $02,$4f,$52                      ; $3b OR
>a1a8	04 4f 56 45 52				.byte $04,$4f,$56,$45,$52              ; $3c OVER
>a1ad	08 52 45 4e 55 4d 42 45			.byte $08,$52,$45,$4e,$55,$4d,$42,$45,$52 ; $3d RENUMBER
>a1b5	52
>a1b6	06 52 45 50 45 41 54			.byte $06,$52,$45,$50,$45,$41,$54      ; $3e REPEAT
>a1bd	06 52 45 54 55 52 4e			.byte $06,$52,$45,$54,$55,$52,$4e      ; $3f RETURN
>a1c4	03 52 55 4e				.byte $03,$52,$55,$4e                  ; $40 RUN
>a1c8	04 53 41 56 45				.byte $04,$53,$41,$56,$45              ; $41 SAVE
>a1cd	03 53 48 4c				.byte $03,$53,$48,$4c                  ; $42 SHL
>a1d1	03 53 48 52				.byte $03,$53,$48,$52                  ; $43 SHR
>a1d5	04 53 54 4f 50				.byte $04,$53,$54,$4f,$50              ; $44 STOP
>a1da	04 53 57 41 50				.byte $04,$53,$57,$41,$50              ; $45 SWAP
>a1df	03 53 59 53				.byte $03,$53,$59,$53                  ; $46 SYS
>a1e3	05 55 4e 54 49 4c			.byte $05,$55,$4e,$54,$49,$4c          ; $47 UNTIL
>a1e9	02 57 21				.byte $02,$57,$21                      ; $48 W!
>a1ec	02 57 40				.byte $02,$57,$40                      ; $49 W@
>a1ef	03 58 4f 52				.byte $03,$58,$4f,$52                  ; $4a XOR
>a1f3	01 5b					.byte $01,$5b                          ; $4b [
>a1f5	01 5d					.byte $01,$5d                          ; $4c ]
>a1f7	01 5e					.byte $01,$5e                          ; $4d ^
>a1f9	01 2b					.byte $01,$2b                          ; $4e {+}
>a1fb	01 2d					.byte $01,$2d                          ; $4f {-}
>a1fd	00					.byte $00
.a1fe					KeywordVectorTable:
>a1fe	d9 ab					.word Mem_DPoke                        ; $10 !
>a200	f7 ac					.word MulInteger32                     ; $11 *
>a202	00 ac					.word Stack_Add                        ; $12 +
>a204	00 ab					.word Unary_Increment                  ; $13 ++
>a206	27 ac					.word Stack_Sub                        ; $14 -
>a208	13 ab					.word Unary_Decrement                  ; $15 --
>a20a	b2 b0					.word System_ShowStack                 ; $16 .
>a20c	40 ad					.word DivInteger32                     ; $17 /
>a20e	f3 b1					.word ProcReturn                       ; $18 ;
>a210	27 ae					.word Comp_Less                        ; $19 <
>a212	35 ab					.word Unary_Shl                        ; $1a <<
>a214	52 ae					.word Comp_LessEqual                   ; $1b <=
>a216	f0 ad					.word Comp_NotEqual                    ; $1c <>
>a218	ed ad					.word Comp_Equal                       ; $1d =
>a21a	55 ae					.word Comp_Greater                     ; $1e >
>a21c	2a ae					.word Comp_GreaterEqual                ; $1f >=
>a21e	42 ab					.word Unary_Shr                        ; $20 >>
>a220	87 ab					.word Mem_DPeek                        ; $21 @
>a222	b7 aa					.word Unary_Absolute                   ; $22 ABS
>a224	7d ae					.word Allocate                         ; $23 ALLOC
>a226	4e ac					.word Stack_And                        ; $24 AND
>a228	43 b0					.word System_Assert                    ; $25 ASSERT
>a22a	ac ab					.word Mem_Poke                         ; $26 C!
>a22c	4f ab					.word Mem_Peek                         ; $27 C@
>a22e	29 aa					.word Stack_Empty                      ; $28 CLR
>a230	d7 a5					.word SyntaxError                      ; $29 DEF
>a232	2c aa					.word Stack_Drop                       ; $2a DROP
>a234	2e aa					.word Stack_Dup                        ; $2b DUP
>a236	09 b3					.word Struct_ELSE                      ; $2c ELSE
>a238	38 b0					.word System_END                       ; $2d END
>a23a	0e b3					.word Struct_ENDIF                     ; $2e ENDIF
>a23c	2a b3					.word Command_For                      ; $2f FOR
>a23e	f4 b2					.word Struct_IF                        ; $30 IF
>a240	b6 b3					.word Command_Index                    ; $31 INDEX
>a242	bd ae					.word Cmd_List                         ; $32 LIST
>a244	fe b0					.word System_Load                      ; $33 LOAD
>a246	d5 ad					.word ModInteger32                     ; $34 MOD
>a248	bd aa					.word Unary_Negate                     ; $35 NEGATE
>a24a	5d b0					.word System_New                       ; $36 NEW
>a24c	79 b3					.word Command_Next                     ; $37 NEXT
>a24e	48 aa					.word Stack_Nip                        ; $38 NIP
>a250	df aa					.word Unary_Not                        ; $39 NOT
>a252	66 b0					.word System_Old                       ; $3a OLD
>a254	9a ac					.word Stack_Or                         ; $3b OR
>a256	62 aa					.word Stack_Over                       ; $3c OVER
>a258	f7 af					.word Cmd_Renumber                     ; $3d RENUMBER
>a25a	e2 b3					.word Command_Repeat                   ; $3e REPEAT
>a25c	f3 b1					.word ProcReturn2                      ; $3f RETURN
>a25e	2f b0					.word System_RUN                       ; $40 RUN
>a260	e0 b0					.word System_Save                      ; $41 SAVE
>a262	c0 ac					.word Stack_Shl                        ; $42 SHL
>a264	c3 ac					.word Stack_Shr                        ; $43 SHR
>a266	3b b0					.word System_STOP                      ; $44 STOP
>a268	7c aa					.word Stack_Swap                       ; $45 SWAP
>a26a	8a b0					.word System_Sys                       ; $46 SYS
>a26c	ec b3					.word Command_Until                    ; $47 UNTIL
>a26e	be ab					.word Mem_WPoke                        ; $48 W!
>a270	68 ab					.word Mem_WPeek                        ; $49 W@
>a272	74 ac					.word Stack_Xor                        ; $4a XOR
>a274	d7 a5					.word SyntaxError                      ; $4b [
>a276	d7 a5					.word SyntaxError                      ; $4c ]
>a278	02 b2					.word WriteVariable                    ; $4d ^
>a27a	d7 a5					.word SyntaxError                      ; $4e {+}
>a27c	d7 a5					.word SyntaxError                      ; $4f {-}
=$10					KWD_PLING = $10                  ; $10 !
=$11					KWD_ASTERISK = $11               ; $11 *
=$12					KWD_PLUS = $12                   ; $12 +
=$13					KWD_PLUSPLUS = $13               ; $13 ++
=$14					KWD_MINUS = $14                  ; $14 -
=$15					KWD_MINUSMINUS = $15             ; $15 --
=$16					KWD_DOT = $16                    ; $16 .
=$17					KWD_SLASH = $17                  ; $17 /
=$18					KWD_SEMICOLON = $18              ; $18 ;
=$19					KWD_LESS = $19                   ; $19 <
=$1a					KWD_LESSLESS = $1a               ; $1a <<
=$1b					KWD_LESSEQUAL = $1b              ; $1b <=
=$1c					KWD_LESSGREATER = $1c            ; $1c <>
=$1d					KWD_EQUAL = $1d                  ; $1d =
=$1e					KWD_GREATER = $1e                ; $1e >
=$1f					KWD_GREATEREQUAL = $1f           ; $1f >=
=$20					KWD_GREATERGREATER = $20         ; $20 >>
=$21					KWD_AT = $21                     ; $21 @
=$22					KWD_ABS = $22                    ; $22 ABS
=$23					KWD_ALLOC = $23                  ; $23 ALLOC
=$24					KWD_AND = $24                    ; $24 AND
=$25					KWD_ASSERT = $25                 ; $25 ASSERT
=$26					KWD_CPLING = $26                 ; $26 C!
=$27					KWD_CAT = $27                    ; $27 C@
=$28					KWD_CLR = $28                    ; $28 CLR
=$29					KWD_DEF = $29                    ; $29 DEF
=$2a					KWD_DROP = $2a                   ; $2a DROP
=$2b					KWD_DUP = $2b                    ; $2b DUP
=$2c					KWD_ELSE = $2c                   ; $2c ELSE
=$2d					KWD_END = $2d                    ; $2d END
=$2e					KWD_ENDIF = $2e                  ; $2e ENDIF
=$2f					KWD_FOR = $2f                    ; $2f FOR
=$30					KWD_IF = $30                     ; $30 IF
=$31					KWD_INDEX = $31                  ; $31 INDEX
=$32					KWD_LIST = $32                   ; $32 LIST
=$33					KWD_LOAD = $33                   ; $33 LOAD
=$34					KWD_MOD = $34                    ; $34 MOD
=$35					KWD_NEGATE = $35                 ; $35 NEGATE
=$36					KWD_NEW = $36                    ; $36 NEW
=$37					KWD_NEXT = $37                   ; $37 NEXT
=$38					KWD_NIP = $38                    ; $38 NIP
=$39					KWD_NOT = $39                    ; $39 NOT
=$3a					KWD_OLD = $3a                    ; $3a OLD
=$3b					KWD_OR = $3b                     ; $3b OR
=$3c					KWD_OVER = $3c                   ; $3c OVER
=$3d					KWD_RENUMBER = $3d               ; $3d RENUMBER
=$3e					KWD_REPEAT = $3e                 ; $3e REPEAT
=$3f					KWD_RETURN = $3f                 ; $3f RETURN
=$40					KWD_RUN = $40                    ; $40 RUN
=$41					KWD_SAVE = $41                   ; $41 SAVE
=$42					KWD_SHL = $42                    ; $42 SHL
=$43					KWD_SHR = $43                    ; $43 SHR
=$44					KWD_STOP = $44                   ; $44 STOP
=$45					KWD_SWAP = $45                   ; $45 SWAP
=$46					KWD_SYS = $46                    ; $46 SYS
=$47					KWD_UNTIL = $47                  ; $47 UNTIL
=$48					KWD_WPLING = $48                 ; $48 W!
=$49					KWD_WAT = $49                    ; $49 W@
=$4a					KWD_XOR = $4a                    ; $4a XOR
=$4b					KWD_LSQPAREN = $4b               ; $4b [
=$4c					KWD_RSQPAREN = $4c               ; $4c ]
=$4d					KWD_HAT = $4d                    ; $4d ^
=$4e					KWD_CONSTANT_PLUS = $4e          ; $4e {+}
=$4f					KWD_CONSTANT_MINUS = $4f         ; $4f {-}

;******  Return to file: main.asm


;******  Processing file: system/extern.asm

.a27e					ExternInitialise:
.a27e	a9 07		lda #$07			lda 	#$07 						; set colour
.a280	8d 86 02	sta $0286			sta 	646
.a283	a9 93		lda #$93			lda 	#147 						; clear screen
.a285	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a288	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a28a	4c ab a2	jmp $a2ab			jmp 	ExternColour
.a28d					ExternCheckBreak:
.a28d	da		phx				phx 								; make sure we keep XY
.a28e	5a		phy				phy
.a28f	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a292	f0 03		beq $a297			beq		_ECBExit 					; stopped
.a294	7a		ply				ply 								; restore and exit.
.a295	fa		plx				plx
.a296	60		rts				rts
.a297					_ECBExit:
.a297	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>a29a	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.a2a1					ExternPrint:
.a2a1	48		pha				pha
.a2a2	da		phx				phx
.a2a3	5a		phy				phy
.a2a4	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a2a7	7a		ply				ply
.a2a8	fa		plx				plx
.a2a9	68		pla				pla
.a2aa	60		rts				rts
.a2ab					ExternColour:
.a2ab	48		pha				pha
.a2ac	da		phx				phx
.a2ad	48		pha				pha
.a2ae	29 08		and #$08			and 	#8
.a2b0	0a		asl a				asl 	a
.a2b1	0a		asl a				asl 	a
.a2b2	0a		asl a				asl 	a
.a2b3	0a		asl a				asl 	a
.a2b4	49 92		eor #$92			eor 	#$92
.a2b6	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a2b9	a9 0e		lda #$0e			lda 	#14							; lower case
.a2bb	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a2be	68		pla				pla
.a2bf	29 07		and #$07			and 	#7
.a2c1	aa		tax				tax
.a2c2	bd cb a2	lda $a2cb,x			lda 	_ECTable,x
.a2c5	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a2c8	fa		plx				plx
.a2c9	68		pla				pla
.a2ca	60		rts				rts
.a2cb					_ECTable:
>a2cb	90						.byte 	144
>a2cc	1c						.byte 	28
>a2cd	1e						.byte 	30
>a2ce	9e						.byte 	158
>a2cf	1f						.byte 	31
>a2d0	9c						.byte 	156
>a2d1	9f						.byte 	159
>a2d2	05						.byte 	5
.a2d3					ExternInput:
.a2d3	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a2d5	85 14		sta $14				sta 	zTemp0
.a2d7	a9 09		lda #$09			lda 	#(InputBuffer >> 8)
.a2d9	85 15		sta $15				sta 	zTemp0+1
.a2db	a9 07		lda #$07			lda 	#COL_WHITE
.a2dd	20 ab a2	jsr $a2ab			jsr 	ExternColour
.a2e0	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a2e3	29 7f		and #$7f			and 	#$7F
.a2e5	c9 0d		cmp #$0d			cmp 	#13
.a2e7	f0 0a		beq $a2f3			beq 	_EIExit
.a2e9	92 14		sta ($14)			sta 	(zTemp0)
.a2eb	e6 14		inc $14				inc 	zTemp0
.a2ed	d0 f1		bne $a2e0			bne 	_EIRead
.a2ef	e6 15		inc $15				inc 	zTemp0+1
.a2f1	80 ed		bra $a2e0			bra 	_EIRead
.a2f3	a9 00		lda #$00	_EIExit:lda 	#0
.a2f5	92 14		sta ($14)			sta 	(zTemp0)
.a2f7	a9 0d		lda #$0d			lda 	#13
.a2f9	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a2fc	60		rts				rts
.a2fd					ExternSave:
.a2fd	da		phx				phx
.a2fe	5a		phy				phy
.a2ff	85 18		sta $18				sta 	zTemp2 						; save start
.a301	84 19		sty $19				sty 	zTemp2+1
.a303	20 65 a3	jsr $a365			jsr 	EXGetLength 				; get length of file into A
.a306	a6 14		ldx $14				ldx 	zTemp0
.a308	a4 15		ldy $15				ldy 	zTemp0+1
.a30a	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a30d	a9 01		lda #$01			lda 	#1
.a30f	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a311	a0 00		ldy #$00			ldy 	#0
.a313	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a316	a6 16		ldx $16				ldx 	zTemp1 						; end address
.a318	a4 17		ldy $17				ldy 	zTemp1+1
.a31a	a9 18		lda #$18			lda 	#zTemp2
.a31c	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.a31f	b0 03		bcs $a324			bcs 	_ESSave
.a321	7a		ply				ply
.a322	fa		plx				plx
.a323	60		rts				rts
.a324					_ESSave:
.a324	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>a327	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>a32f	4c 45 44 00
.a333					ExternLoad:
.a333	da		phx				phx 								; save XY
.a334	5a		phy				phy
.a335	48		pha				pha 								; save target
.a336	5a		phy				phy
.a337	20 65 a3	jsr $a365			jsr 	EXGetLength 				; get length of file into A
.a33a	a6 14		ldx $14				ldx 	zTemp0
.a33c	a4 15		ldy $15				ldy 	zTemp0+1
.a33e	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a341	a9 01		lda #$01			lda 	#1
.a343	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a345	a0 00		ldy #$00			ldy 	#0
.a347	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a34a	7a		ply				ply 								; restore target to YX and call load
.a34b	fa		plx				plx
.a34c	a9 00		lda #$00			lda 	#0 							; load command
.a34e	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.a351	b0 03		bcs $a356			bcs 	_ESLoad
.a353	7a		ply				ply
.a354	fa		plx				plx
.a355	60		rts				rts
.a356					_ESLoad:
.a356	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>a359	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>a361	4c 45 44 00
.a365					EXGetLength:
.a365	a0 ff		ldy #$ff			ldy 	#255
.a367	c8		iny		_EXGL:	iny
.a368	b1 14		lda ($14),y			lda 	(zTemp0),y
.a36a	d0 fb		bne $a367			bne 	_EXGL
.a36c	98		tya				tya
.a36d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/execute.asm

.a36e					EXNextLine:
.a36e	b2 10		lda ($10)			lda 	(codePtr) 					; is it run from the buffer (offset 0)
.a370	f0 0f		beq $a381			beq 	_EXNLWarmStart
.a372	18		clc				clc 								; advance code pointer to next line
.a373	65 10		adc $10				adc 	codePtr
.a375	85 10		sta $10				sta 	codePtr
.a377	90 02		bcc $a37b			bcc 	_EXNLNoBump
.a379	e6 11		inc $11				inc 	codePtr+1
.a37b					_EXNLNoBump:
.a37b	a0 03		ldy #$03			ldy 	#3 							; position in that line
.a37d	b2 10		lda ($10)			lda 	(codePtr) 					; read offset
.a37f	d0 03		bne $a384			bne 	Execute 					; not end of program
.a381					_EXNLWarmStart:
.a381	4c 38 b0	jmp $b038			jmp 	System_END
.a384	e0 fc		cpx #$fc	Execute:cpx 	#$FC  						; stack overflow
.a386	b0 1c		bcs $a3a4			bcs 	EXStackOverflow
.a388	ee 22 08	inc $0822			inc 	BreakCount 					; break occasionally. too slow otherwise.
.a38b	d0 03		bne $a390			bne 	_EXNoBreak
.a38d	20 8d a2	jsr $a28d			jsr 	ExternCheckBreak
.a390					_EXNoBreak:
.a390	b1 10		lda ($10),y			lda 	(codePtr),y 				; load the character
.a392	f0 da		beq $a36e			beq 	EXNextLine 					; reached end of the line.
.a394	c8		iny				iny 								; advance pointer.
.a395	c9 10		cmp #$10			cmp 	#$10 						; is it 01-0F, which means a string/comment ?
.a397	90 3b		bcc $a3d4			bcc 	EXStringComment
.a399	c9 80		cmp #$80			cmp 	#$80 						; if it 10-7F, token
.a39b	90 21		bcc $a3be			bcc 	EXTokenExecute
.a39d	c9 c0		cmp #$c0			cmp 	#$C0 						; is it a numeric constant 80-BF
.a39f	90 17		bcc $a3b8			bcc 	EXPushConstant
.a3a1	4c 76 b1	jmp $b176			jmp 	Identifier 					; it's an identifier C0-FF
.a3a4					EXStackOverflow:
.a3a4	a2 00		ldx #$00			ldx 	#0 							; stack error clears stack otherwise doesn't work.
.a3a6	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>a3a9	53 54 41 43 4b 20 4f 56				.text 	"STACK OVERFLOW",0
>a3b1	45 52 46 4c 4f 57 00
.a3b8					EXPushConstant:
.a3b8	88		dey				dey
.a3b9	20 03 a4	jsr $a403			jsr 	ExtractIntegerToTOS 		; extract integer
.a3bc	80 c6		bra $a384			bra 	Execute
.a3be					EXTokenExecute:
.a3be	0a		asl a				asl 	a 							; double token, also clears carry
.a3bf	da		phx				phx 								; save X, put token x 2 in X
.a3c0	aa		tax				tax
.a3c1	bd de a1	lda $a1de,x			lda 	KeywordVectorTable-$20,x 	; copy vector. The -$20 is because the tokens
.a3c4	85 14		sta $14				sta 	zTemp0 						; start at $10.
.a3c6	bd df a1	lda $a1df,x			lda 	KeywordVectorTable-$20+1,x
.a3c9	85 15		sta $15				sta 	zTemp0+1
.a3cb	fa		plx				plx 								; restore X
.a3cc	20 d1 a3	jsr $a3d1			jsr 	_EXTCall 					; call the routine
.a3cf	80 b3		bra $a384			bra 	Execute
.a3d1					_EXTCall:
.a3d1	6c 14 00	jmp ($0014)			jmp 	(zTemp0)
.a3d4					EXStringComment:
.a3d4	c9 02		cmp #$02			cmp 	#$02 						; 02 is the token for single quoted string
.a3d6	f0 15		beq $a3ed			beq 	EXStringSkip 				; (comment), so just skip it.
.a3d8	e8		inx				inx 								; push Y + 1 + codePtr on the stack
.a3d9	98		tya				tya
.a3da	38		sec				sec
.a3db	65 10		adc $10				adc 	codePtr
.a3dd	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a3e0	a5 11		lda $11				lda 	codePtr+1
.a3e2	69 00		adc #$00			adc 	#0
.a3e4	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a3e7	9e 00 0e	stz $0e00,x			stz 	stack2,x 					; clear the upper 2 bytes.
.a3ea	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a3ed					EXStringSkip:
.a3ed	98		tya				tya 								; the current position in A
.a3ee	18		clc				clc
.a3ef	71 10		adc ($10),y			adc 	(codePtr),y					; add the total length
.a3f1	a8		tay				tay 			 					; and make that the current position.
.a3f2	88		dey				dey 								; back one because of the initial skip
.a3f3	80 8f		bra $a384			bra 	Execute
.a3f5					EXShiftTOSRight:
.a3f5	4a		lsr a				lsr 	a
.a3f6	7e 00 0f	ror $0f00,x			ror 	stack3,x
.a3f9	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a3fc	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a3ff	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a402	60		rts				rts
.a403					ExtractIntegerToTOS:
.a403	b1 10		lda ($10),y			lda 	(codePtr),y
.a405	c8		iny				iny
.a406	e8		inx				inx 								; make stack space
.a407	29 3f		and #$3f			and 	#$3F 						; to start with, it's just that value
.a409	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a40c	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a40f	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a412	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a415					_EXConstantLoop:
.a415	b1 10		lda ($10),y			lda 	(codePtr),y 				; look at next ?
.a417	29 c0		and #$c0			and 	#$C0 						; in range 80-FF e.g. 10xx xxxx
.a419	c9 80		cmp #$80			cmp 	#$80
.a41b	d0 2d		bne $a44a			bne		_EXDone 					; no then exit
.a41d	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; put the MSB in A
.a420	48		pha				pha
.a421	bd 00 0e	lda $0e00,x			lda 	stack2,x 					; shift every byte up one, e.g. x 256
.a424	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a427	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a42a	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a42d	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a430	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a433	9e 00 0c	stz $0c00,x			stz 	stack0,x
.a436	68		pla				pla
.a437	20 f5 a3	jsr $a3f5			jsr 	EXShiftTOSRight 				; shift the whole A:Top of Stack right twice
.a43a	20 f5 a3	jsr $a3f5			jsr 	EXShiftTOSRight				; which will be x64
.a43d	b1 10		lda ($10),y			lda 	(codePtr),y 				; get and skip constant shift
.a43f	c8		iny				iny
.a440	29 3f		and #$3f			and 	#$3F
.a442	1d 00 0c	ora $0c00,x			ora 	stack0,x 					; or into low byte
.a445	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a448	80 cb		bra $a415			bra 	_EXConstantLoop
.a44a	b1 10		lda ($10),y	_EXDone:lda 	(codePtr),y
.a44c	c8		iny				iny 								; skip over unary constant + -
.a44d	c9 4f		cmp #$4f			cmp 	#KWD_CONSTANT_MINUS
.a44f	d0 03		bne $a454			bne 	_EXPositive
.a451	4c bd aa	jmp $aabd			jmp 	Unary_Negate
.a454					_EXPositive:
.a454	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/identifier.asm

.a455					IdentifierSearch:
.a455	b1 10		lda ($10),y			lda 	(codePtr),y 				; get first character
.a457	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a fast var ?
.a459	90 12		bcc $a46d			bcc 	_ISSlow
.a45b	c9 fa		cmp #$fa			cmp 	#$F9+1
.a45d	b0 0e		bcs $a46d			bcs 	_ISSlow
.a45f	29 1f		and #$1f			and 	#$1F 						; index, then x 4
.a461	0a		asl a				asl 	a
.a462	0a		asl a				asl		a
.a463	85 22		sta $22				sta 	idDataAddr					; set up addres
.a465	a9 10		lda #$10			lda 	#AZVariables >> 8
.a467	85 23		sta $23				sta 	idDataAddr+1
.a469	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; type
.a46b	38		sec				sec 								; return with CS.
.a46c	60		rts				rts
.a46d					_ISSlow:
.a46d	20 29 a5	jsr $a529			jsr 	IdentifierSetupHashPtr 		; set up hash table.
.a470	98		tya				tya 								; set (zTemp1) to point to the
.a471	18		clc				clc 	 							; identifier to be searched.
.a472	65 10		adc $10				adc 	codePtr
.a474	85 16		sta $16				sta 	zTemp1
.a476	a5 11		lda $11				lda 	codePtr+1
.a478	69 00		adc #$00			adc 	#0
.a47a	85 17		sta $17				sta 	zTemp1+1
.a47c	5a		phy				phy 								; save Y
.a47d	b2 14		lda ($14)	_ISLoop:lda 	(zTemp0)					; follow link
.a47f	48		pha				pha
.a480	a0 01		ldy #$01			ldy 	#1
.a482	b1 14		lda ($14),y			lda 	(zTemp0),y
.a484	85 15		sta $15				sta 	zTemp0+1
.a486	68		pla				pla
.a487	85 14		sta $14				sta 	zTemp0
.a489	05 15		ora $15				ora 	zTemp0+1 					; if zero, then fail.
.a48b	f0 2c		beq $a4b9			beq 	_ISFail
.a48d	a0 06		ldy #$06			ldy 	#6 							; copy name into zTemp2
.a48f	b1 14		lda ($14),y			lda 	(zTemp0),y
.a491	85 18		sta $18				sta 	zTemp2
.a493	c8		iny				iny
.a494	b1 14		lda ($14),y			lda 	(zTemp0),y
.a496	85 19		sta $19				sta 	zTemp2+1
.a498	a0 00		ldy #$00			ldy 	#0 							; compare names at zTemp1/zTemp2
.a49a					_ISCompare:
.a49a	b1 16		lda ($16),y			lda 	(zTemp1),y
.a49c	d1 18		cmp ($18),y			cmp 	(zTemp2),y
.a49e	d0 dd		bne $a47d			bne		_ISLoop 					; different ?
.a4a0	c8		iny				iny
.a4a1	c9 e0		cmp #$e0			cmp 	#$E0 						; until end identifiers matched.
.a4a3	90 f5		bcc $a49a			bcc 	_ISCompare
.a4a5	18		clc				clc 								; set up the data pointer
.a4a6	a5 14		lda $14				lda 	zTemp0
.a4a8	69 02		adc #$02			adc 	#2
.a4aa	85 22		sta $22				sta 	idDataAddr
.a4ac	a5 15		lda $15				lda 	zTemp0+1
.a4ae	69 00		adc #$00			adc		#0
.a4b0	85 23		sta $23				sta 	idDataAddr+1
.a4b2	a0 09		ldy #$09			ldy 	#9 							; get the type
.a4b4	b1 14		lda ($14),y			lda 	(zTemp0),y
.a4b6	7a		ply				ply
.a4b7	38		sec				sec
.a4b8	60		rts				rts
.a4b9					_ISFail:
.a4b9	7a		ply				ply
.a4ba	18		clc				clc
.a4bb	60		rts				rts
.a4bc					IdentifierCreate:
.a4bc	5a		phy				phy 								; save Y
.a4bd	48		pha				pha 								; save type on stack
.a4be	20 29 a5	jsr $a529			jsr 	IdentifierSetUpHashPtr 		; zTemp0 = address of table.
.a4c1	ad 88 10	lda $1088			lda 	VarMemory 					; copy VarMemory to zTemp1
.a4c4	85 16		sta $16				sta 	zTemp1
.a4c6	ad 89 10	lda $1089			lda 	VarMemory+1
.a4c9	85 17		sta $17				sta 	zTemp1+1
.a4cb	5a		phy				phy 								; save Y (code offset)
.a4cc	a0 00		ldy #$00			ldy 	#0 							; copy next link in.
.a4ce	b1 14		lda ($14),y			lda 	(zTemp0),y 					; +0,+1 is the link.
.a4d0	91 16		sta ($16),y			sta 	(zTemp1),y
.a4d2	c8		iny				iny
.a4d3	b1 14		lda ($14),y			lda 	(zTemp0),y
.a4d5	91 16		sta ($16),y			sta 	(zTemp1),y
.a4d7	c8		iny				iny
.a4d8					_IDCErase:
.a4d8	a9 00		lda #$00			lda 	#0
.a4da	91 16		sta ($16),y			sta 	(zTemp1),y
.a4dc	c8		iny				iny
.a4dd	c0 06		cpy #$06			cpy 	#6
.a4df	d0 f7		bne $a4d8			bne 	_IDCErase
.a4e1	68		pla				pla 								; original Y
.a4e2	18		clc				clc
.a4e3	65 10		adc $10				adc		codePtr 					; address of identifier +6,+7
.a4e5	91 16		sta ($16),y			sta 	(zTemp1),y
.a4e7	c8		iny				iny
.a4e8	a5 11		lda $11				lda 	codePtr+1
.a4ea	69 00		adc #$00			adc 	#0
.a4ec	91 16		sta ($16),y			sta 	(zTemp1),y
.a4ee	c8		iny				iny
.a4ef	a9 00		lda #$00			lda 	#0 							; +8 bank (0)
.a4f1	91 16		sta ($16),y			sta 	(zTemp1),y
.a4f3	68		pla				pla 								; restore type
.a4f4	c8		iny				iny
.a4f5	91 16		sta ($16),y			sta 	(zTemp1),y 					; store at +9
.a4f7	c8		iny				iny
.a4f8	98		tya				tya									; add offset to VarMemory
.a4f9	18		clc				clc
.a4fa	6d 88 10	adc $1088			adc 	VarMemory
.a4fd	8d 88 10	sta $1088			sta 	VarMemory
.a500	ad 89 10	lda $1089			lda 	VarMemory+1
.a503	69 00		adc #$00			adc 	#0
.a505	8d 89 10	sta $1089			sta 	VarMemory+1
.a508	cd 8b 10	cmp $108b			cmp 	AllocMemory+1 				; in the same page as allocated ?
.a50b	f0 19		beq $a526			beq 	_IDCMemory
.a50d	a5 16		lda $16				lda 	zTemp1 						; overwrite hash table entry
.a50f	92 14		sta ($14)			sta 	(zTemp0)
.a511	a0 01		ldy #$01			ldy 	#1
.a513	a5 17		lda $17				lda 	zTemp1+1
.a515	91 14		sta ($14),y			sta 	(zTemp0),y
.a517	a5 16		lda $16				lda 	zTemp1 						; set up idDataAddr
.a519	18		clc				clc
.a51a	69 02		adc #$02			adc 	#2
.a51c	85 22		sta $22				sta 	idDataAddr
.a51e	a5 17		lda $17				lda 	zTemp1+1
.a520	69 00		adc #$00			adc 	#0
.a522	85 23		sta $23				sta 	idDataAddr+1
.a524	7a		ply				ply 								; restore Y and exit
.a525	60		rts				rts
.a526					_IDCMemory:
.a526	4c e7 a5	jmp $a5e7			jmp 	OutOfMemoryError
.a529					IdentifierSetUpHashPtr:
.a529	5a		phy				phy
.a52a					_ISPLoop:
.a52a	b1 10		lda ($10),y			lda 	(codePtr),y 				; get the last identifier character
.a52c	c8		iny				iny
.a52d	c9 e0		cmp #$e0			cmp 	#$E0
.a52f	90 f9		bcc $a52a			bcc 	_ISPLoop
.a531	29 0f		and #$0f			and 	#(HashTableSize-1)			; convert to a hash index
.a533	0a		asl a				asl 	a 							; convert to an offset, clc
.a534	69 68		adc #$68			adc 	#(HashTable & $FF)			; set zTemp0 to point to hashTable entry
.a536	85 14		sta $14				sta 	zTemp0
.a538	a9 10		lda #$10			lda 	#(HashTable >> 8) 			; assumes table in one page
.a53a	85 15		sta $15				sta 	zTemp0+1
.a53c	7a		ply				ply
.a53d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/reset.asm

.a53e					ResetCodePointer:
.a53e	48		pha				pha
.a53f	a9 11		lda #$11			lda 	#ProgramStart >> 8 			; set up line pointer
.a541	85 11		sta $11				sta 	codePtr+1
.a543	64 10		stz $10				stz 	codePtr
.a545	a0 03		ldy #$03			ldy 	#3 							; point to first piece of code
.a547	68		pla				pla
.a548	60		rts				rts
.a549					ResetForRun:
.a549	48		pha				pha
.a54a	5a		phy				phy
.a54b	a2 00		ldx #$00			ldx 	#0 							; erase the hash table
.a54d					_RRErase:
.a54d	bd 72 b5	lda $b572,x			lda 	DefaultHashTable,x
.a550	9d 68 10	sta $1068,x			sta		HashTable,x
.a553	e8		inx				inx
.a554	e0 20		cpx #$20			cpx 	#HashTableSize * 2
.a556	d0 f5		bne $a54d			bne 	_RRErase
.a558	20 6f a5	jsr $a56f			jsr 	ResetVarMemory
.a55b	a9 ff		lda #$ff			lda 	#StructureStack & $FF
.a55d	85 12		sta $12				sta 	StructSP
.a55f	a9 0b		lda #$0b			lda 	#StructureStack >> 8
.a561	85 13		sta $13				sta 	StructSP+1
.a563	a9 ff		lda #$ff			lda 	#$FF 						; put a value that will fail structure tests
.a565	92 12		sta ($12)			sta 	(StructSP)
.a567	20 96 a5	jsr $a596			jsr 	ProcedureScan
.a56a	a2 00		ldx #$00			ldx 	#0 							; empty the stack
.a56c	7a		ply				ply
.a56d	68		pla				pla
.a56e	60		rts				rts
.a56f					ResetVarMemory:
.a56f	a9 00		lda #$00			lda 	#ProgramStart & $FF
.a571	85 14		sta $14				sta 	zTemp0
.a573	a9 11		lda #$11			lda 	#ProgramStart >> 8
.a575	85 15		sta $15				sta 	zTemp0+1
.a577					_RRFindEnd:
.a577	b2 14		lda ($14)			lda 	(zTemp0)					; at end ?
.a579	f0 0b		beq $a586			beq 	_RRFoundEnd
.a57b	18		clc				clc 								; no, add offset to pointer.
.a57c	65 14		adc $14				adc 	zTemp0
.a57e	85 14		sta $14				sta 	zTemp0
.a580	90 f5		bcc $a577			bcc 	_RRFindEnd
.a582	e6 15		inc $15				inc 	zTemp0+1
.a584	80 f1		bra $a577			bra 	_RRFindEnd
.a586					_RRFoundEnd:
.a586	18		clc				clc 								; add 1 to this, as it points to the last
.a587	a5 14		lda $14				lda 	zTemp0 					; offset, and store in Variable Memory pointer
.a589	69 01		adc #$01			adc 	#1
.a58b	8d 88 10	sta $1088			sta 	VarMemory
.a58e	a5 15		lda $15				lda 	zTemp0+1
.a590	69 00		adc #$00			adc 	#0
.a592	8d 89 10	sta $1089			sta 	VarMemory+1
.a595	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/scan.asm

.a596					ProcedureScan:
.a596	20 3e a5	jsr $a53e			jsr 	ResetCodePointer 			; reset the code pointer.
.a599	b2 10		lda ($10)	_PSMain:lda 	(codePtr)					; check if end
.a59b	f0 39		beq $a5d6			beq 	_PSExit
.a59d	a0 03		ldy #$03			ldy 	#3 							; start of line
.a59f	b1 10		lda ($10),y			lda 	(codePtr),y 				; skip over spaces
.a5a1	c9 29		cmp #$29			cmp 	#KWD_DEF 					; first thing is DEF ?
.a5a3	d0 24		bne $a5c9			bne 	_PSNext
.a5a5	c8		iny				iny 								; skip over def first
.a5a6	b1 10		lda ($10),y			lda 	(codePtr),y 				; next, must be C0-DF - a multi char ID
.a5a8	29 e0		and #$e0			and 	#$E0
.a5aa	c9 c0		cmp #$c0			cmp 	#$C0
.a5ac	d0 1b		bne $a5c9			bne 	_PSNext 					; otherwise ignore it.
.a5ae	a9 50		lda #$50			lda 	#IDT_PROCEDURE 				; create a procedure
.a5b0	20 bc a4	jsr $a4bc			jsr 	IdentifierCreate
.a5b3					_PSSkipIdentifier:
.a5b3	b1 10		lda ($10),y			lda 	(codePtr),y
.a5b5	c9 e0		cmp #$e0			cmp 	#$E0
.a5b7	c8		iny				iny
.a5b8	90 f9		bcc $a5b3			bcc 	_PSSkipIdentifier
.a5ba	98		tya				tya  								; save the address in the data slot.
.a5bb	a0 03		ldy #$03			ldy 	#3
.a5bd	91 22		sta ($22),y			sta 	(idDataAddr),y 				; offset
.a5bf	a5 10		lda $10				lda 	codePtr
.a5c1	92 22		sta ($22)			sta 	(idDataAddr) 				; position.low
.a5c3	a5 11		lda $11				lda 	codePtr+1
.a5c5	a0 01		ldy #$01			ldy 	#1
.a5c7	91 22		sta ($22),y			sta 	(idDataAddr),y 				; position.high
.a5c9					_PSNext:
.a5c9	18		clc				clc 								; go to next
.a5ca	b2 10		lda ($10)			lda 	(codePtr)
.a5cc	65 10		adc $10				adc 	codePtr
.a5ce	85 10		sta $10				sta 	codeptr
.a5d0	90 c7		bcc $a599			bcc 	_PSMain
.a5d2	e6 11		inc $11				inc 	codePtr+1
.a5d4	80 c3		bra $a599			bra 	_PSMain
.a5d6					_PSExit:
.a5d6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/error.asm

.a5d7					SyntaxError:
.a5d7	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>a5da	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>a5e2	52 52 4f 52 00
.a5e7					OutOfMemoryError:
.a5e7	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>a5ea	4f 55 54 20 4f 46 20 4d				.text 	"OUT OF MEMORY",0
>a5f2	45 4d 4f 52 59 00
.a5f8					ErrorHandler:
.a5f8	68		pla				pla 								; pop message address
.a5f9	85 14		sta $14				sta 	zTemp0
.a5fb	68		pla				pla
.a5fc	85 15		sta $15				sta 	zTemp0+1
.a5fe	a9 05		lda #$05			lda 	#CTH_ERROR
.a600	20 ab a2	jsr $a2ab			jsr 	ExternColour
.a603	a0 01		ldy #$01			ldy 	#1 							; print it
.a605					_ErrorPrint:
.a605	b1 14		lda ($14),y			lda 	(zTemp0),y
.a607	20 a1 a2	jsr $a2a1			jsr		ExternPrint
.a60a	c8		iny				iny
.a60b	b1 14		lda ($14),y			lda 	(zTemp0),y
.a60d	d0 f6		bne $a605			bne 	_ErrorPrint
.a60f	a0 01		ldy #$01			ldy 	#1 							; check if line# 0
.a611	b1 10		lda ($10),y			lda		(codePtr),y
.a613	c8		iny				iny
.a614	12 10		ora ($10)			ora 	(codePtr)
.a616	f0 1c		beq $a634			beq 	_ErrorNoLine 				; if so, skip
.a618	a9 20		lda #$20			lda 	#32
.a61a	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a61d	a9 40		lda #$40			lda 	#'@'
.a61f	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a622	a9 20		lda #$20			lda 	#32
.a624	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a627	a0 01		ldy #$01			ldy 	#1 							; load current line into YA
.a629	b1 10		lda ($10),y			lda 	(codePtr),y
.a62b	48		pha				pha
.a62c	c8		iny				iny
.a62d	b1 10		lda ($10),y			lda 	(codePtr),y
.a62f	a8		tay				tay
.a630	68		pla				pla
.a631	20 3c a6	jsr $a63c			jsr 	ErrorPrint16 				; print YA as unsigned 16 bit integer.
.a634					_ErrorNoLine:
.a634	a9 0d		lda #$0d			lda 	#13							; new line
.a636	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a639	4c 3b a0	jmp $a03b			jmp 	WarmStart
.a63c					ErrorPrint16:
.a63c	da		phx				phx
.a63d	e8		inx				inx 								; space on stack
.a63e	9d 00 0c	sta $0c00,x			sta 	stack0,x					; save on TOS
.a641	98		tya				tya
.a642	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a645	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a648	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a64b	20 61 a6	jsr $a661			jsr 	IntegerToString 			; convert to string.
.a64e	fa		plx				plx
.a64f					ErrorPrintIntegerBuffer:
.a64f	da		phx				phx
.a650	a2 00		ldx #$00			ldx 	#0
.a652					_EP16Loop:
.a652	bd 00 08	lda $0800,x			lda 	SBuffer,x
.a655	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.a658	e8		inx				inx
.a659	bd 00 08	lda $0800,x			lda 	SBuffer,x
.a65c	d0 f4		bne $a652			bne 	_EP16Loop
.a65e	8a		txa				txa
.a65f	fa		plx				plx
.a660	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/inttostr.asm

.a661					IntegerToString:
.a661	48		pha				pha
.a662	5a		phy				phy
.a663	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a666	48		pha				pha
.a667	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a66a	48		pha				pha
.a66b	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a66e	48		pha				pha
.a66f	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a672	48		pha				pha
.a673	bd 00 0f	lda $0f00,x			lda 		stack3,x 				; check -ve
.a676	10 08		bpl $a680			bpl 		_ITSNotMinus
.a678	a9 2d		lda #$2d			lda 		#"-"
.a67a	20 22 a7	jsr $a722			jsr 		ITSOutputCharacter
.a67d	20 bd aa	jsr $aabd			jsr 		Unary_Negate
.a680					_ITSNotMinus:
.a680	9c 20 08	stz $0820			stz 		SBPosition 				; reset string buffer position
.a683	9c 24 08	stz $0824			stz 		NumSuppress 			; clear zero suppression flag
.a686	8a		txa				txa 								; use Y for the integer index.
.a687	a8		tay				tay
.a688	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.a68a					_ITSNextSubtractor:
.a68a	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.a68c	8d 21 08	sta $0821			sta 		NumConvCount
.a68f					_ITSSubtract:
.a68f	38		sec				sec
.a690	b9 00 0c	lda $0c00,y			lda 		stack0,y 			; subtract number and push on stack
.a693	fd fe a6	sbc $a6fe,x			sbc 		_ITSSubtractors+0,x 	; only update if actually can subtract it.
.a696	48		pha				pha
.a697	b9 00 0d	lda $0d00,y			lda 		stack1,y
.a69a	fd ff a6	sbc $a6ff,x			sbc 		_ITSSubtractors+1,x
.a69d	48		pha				pha
.a69e	b9 00 0e	lda $0e00,y			lda 		stack2,y
.a6a1	fd 00 a7	sbc $a700,x			sbc 		_ITSSubtractors+2,x
.a6a4	48		pha				pha
.a6a5	b9 00 0f	lda $0f00,y			lda 		stack3,y
.a6a8	fd 01 a7	sbc $a701,x			sbc 		_ITSSubtractors+3,x
.a6ab	90 14		bcc $a6c1			bcc 		_ITSCantSubtract 		; if CC, then gone too far, can't subtract
.a6ad	99 00 0f	sta $0f00,y			sta 		stack3,y 		; save subtract off stack as it's okay
.a6b0	68		pla				pla
.a6b1	99 00 0e	sta $0e00,y			sta 		stack2,y
.a6b4	68		pla				pla
.a6b5	99 00 0d	sta $0d00,y			sta 		stack1,y
.a6b8	68		pla				pla
.a6b9	99 00 0c	sta $0c00,y			sta 		stack0,y
.a6bc	ee 21 08	inc $0821			inc 		NumConvCount 			; bump count.
.a6bf	80 ce		bra $a68f			bra 		_ITSSubtract 			; go round again.
.a6c1					_ITSCantSubtract:
.a6c1	68		pla				pla 								; throw away interim answers
.a6c2	68		pla				pla 								; (the subtraction that failed)
.a6c3	68		pla				pla
.a6c4	ad 21 08	lda $0821			lda 		NumConvCount 			; if not zero then no suppression check
.a6c7	c9 30		cmp #$30			cmp 		#"0"
.a6c9	d0 05		bne $a6d0			bne 		_ITSOutputDigit
.a6cb	ad 24 08	lda $0824			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.a6ce	f0 09		beq $a6d9			beq	 		_ITSGoNextSubtractor
.a6d0					_ITSOutputDigit:
.a6d0	ce 24 08	dec $0824			dec 		NumSuppress 			; suppression check will be non-zero from now on.
.a6d3	ad 21 08	lda $0821			lda 		NumConvCount 			; count of subtractions
.a6d6	20 22 a7	jsr $a722			jsr 		ITSOutputCharacter 		; output it.
.a6d9					_ITSGoNextSubtractor:
.a6d9	e8		inx				inx 								; next dword in subtractor table.
.a6da	e8		inx				inx
.a6db	e8		inx				inx
.a6dc	e8		inx				inx
.a6dd	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.a6df	d0 a9		bne $a68a			bne 		_ITSNextSubtractor 		; do all the subtractors.
.a6e1	98		tya				tya 								; X is back as the mantissa index
.a6e2	aa		tax				tax
.a6e3	bd 00 0c	lda $0c00,x			lda 		stack0,x 		; and the last digit is left.
.a6e6	09 30		ora #$30			ora 		#"0"
.a6e8	20 22 a7	jsr $a722			jsr 		ITSOutputCharacter
.a6eb	68		pla				pla
.a6ec	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a6ef	68		pla				pla
.a6f0	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a6f3	68		pla				pla
.a6f4	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a6f7	68		pla				pla
.a6f8	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a6fb	7a		ply				ply 								; and exit
.a6fc	68		pla				pla
.a6fd	60		rts				rts
.a6fe					_ITSSubtractors:
>a6fe	00 ca 9a 3b					.dword 		1000000000
>a702	00 e1 f5 05					.dword 		100000000
>a706	80 96 98 00					.dword 		10000000
>a70a	40 42 0f 00					.dword 		1000000
>a70e	a0 86 01 00					.dword 		100000
>a712	10 27 00 00					.dword 		10000
>a716	e8 03 00 00					.dword 		1000
>a71a	64 00 00 00					.dword 		100
>a71e	0a 00 00 00					.dword 		10
.a722					_ITSSubtractorsEnd:
.a722					ITSOutputCharacter:
.a722	48		pha				pha
.a723	da		phx				phx
.a724	ae 20 08	ldx $0820			ldx 	SBPosition 					; save digit
.a727	9d 00 08	sta $0800,x			sta 	SBuffer,x
.a72a	9e 01 08	stz $0801,x			stz 	SBuffer+1,x
.a72d	ee 20 08	inc $0820			inc 	SBPosition					; bump pointer.
.a730	fa		plx				plx
.a731	68		pla				pla
.a732	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/intfromstr.asm

.a733					IntFromString:
.a733	a0 00		ldy #$00			ldy 	#0 							; from (zTemp0)
.a735	8c 25 08	sty $0825			sty 	IFSHexFlag
.a738	b2 14		lda ($14)			lda 	(zTemp0)					; check &
.a73a	c9 26		cmp #$26			cmp 	#"&"
.a73c	d0 04		bne $a742			bne 	_IFSNotHex
.a73e	ce 25 08	dec $0825			dec 	IFSHexFlag 					; hex flag = $FF
.a741	c8		iny				iny 								; skip
.a742					_IFSNotHex:
.a742	e8		inx				inx 								; space on stack
.a743	20 9f a7	jsr $a79f			jsr 	IFSClearTOS
.a746					_IFSLoop:
.a746	ad 25 08	lda $0825			lda 	IFSHexFlag 					; check in hex mode ?
.a749	f0 0a		beq $a755			beq 	_IFSDecOnly
.a74b	b1 14		lda ($14),y			lda 	(zTemp0),y 					; get next
.a74d	c9 41		cmp #$41			cmp 	#"A"
.a74f	90 04		bcc $a755			bcc 	_IFSDecOnly
.a751	c9 47		cmp #$47			cmp 	#"F"+1
.a753	90 0a		bcc $a75f			bcc 	_IFSOkDigit
.a755					_IFSDecOnly:
.a755	b1 14		lda ($14),y			lda 	(zTemp0),y 					; get next
.a757	c9 30		cmp #$30			cmp 	#"0"						; validate it as range 0-9
.a759	90 3e		bcc $a799			bcc 	_IFSExit
.a75b	c9 3a		cmp #$3a			cmp 	#"9"+1
.a75d	b0 3a		bcs $a799			bcs 	_IFSExit
.a75f					_IFSOkDigit:
.a75f	ad 25 08	lda $0825			lda 	IFSHexFlag
.a762	d0 11		bne $a775			bne 	_IFSHexShift
.a764	20 2e aa	jsr $aa2e			jsr 	Stack_Dup 					; duplicate tos
.a767	20 35 ab	jsr $ab35			jsr 	Unary_Shl	 				; x 2
.a76a	20 35 ab	jsr $ab35			jsr 	Unary_Shl 					; x 4
.a76d	20 00 ac	jsr $ac00			jsr 	Stack_Add 					; x 5
.a770	20 35 ab	jsr $ab35			jsr 	Unary_Shl 					; x 10
.a773	80 0c		bra $a781			bra 	_IFSAddIn
.a775					_IFSHexShift:
.a775	20 35 ab	jsr $ab35			jsr 	Unary_Shl	 				; x 2
.a778	20 35 ab	jsr $ab35			jsr 	Unary_Shl	 				; x 4
.a77b	20 35 ab	jsr $ab35			jsr 	Unary_Shl	 				; x 8
.a77e	20 35 ab	jsr $ab35			jsr 	Unary_Shl	 				; x 16
.a781					_IFSAddIn:
.a781	e8		inx				inx  								; create space next up
.a782	20 9f a7	jsr $a79f			jsr 	IFSClearTOS
.a785	b1 14		lda ($14),y			lda 	(zTemp0),y 					; add digit
.a787	c9 41		cmp #$41			cmp 	#"A"
.a789	90 03		bcc $a78e			bcc 	_IFSDec
.a78b	38		sec				sec 								; hex fixup.
.a78c	e9 07		sbc #$07			sbc 	#7
.a78e					_IFSDec:
.a78e	29 0f		and #$0f			and 	#15
.a790	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; tos is new add
.a793	20 00 ac	jsr $ac00			jsr 	Stack_Add 					; add to tos
.a796	c8		iny				iny
.a797	80 ad		bra $a746			bra 	_IFSLoop
.a799					_IFSExit:
.a799	98		tya				tya
.a79a	38		sec				sec
.a79b	f0 01		beq $a79e			beq 	_IFSSkipFail
.a79d	18		clc				clc
.a79e					_IFSSkipFail:
.a79e	60		rts				rts
.a79f					IFSClearTOS:
.a79f	9e 00 0c	stz $0c00,x			stz		stack0,x
.a7a2	9e 00 0d	stz $0d00,x			stz		stack1,x
.a7a5	9e 00 0e	stz $0e00,x			stz		stack2,x
.a7a8	9e 00 0f	stz $0f00,x			stz		stack3,x
.a7ab	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/tokeniser.asm

.a7ac					Tokenise:
.a7ac	da		phx				phx
.a7ad	a0 ff		ldy #$ff			ldy 	#255 						; predecrement
.a7af					_TKSkip:
.a7af	c8		iny				iny
.a7b0					_TKMainLoop:
.a7b0	b1 10		lda ($10),y			lda 	(codePtr),y 				; get and check end.
.a7b2	f0 06		beq $a7ba			beq 	_TKExit
.a7b4	c9 20		cmp #$20			cmp 	#" "
.a7b6	f0 f7		beq $a7af			beq 	_TKSkip
.a7b8	80 04		bra $a7be			bra 	_TKNotEnd
.a7ba	92 16		sta ($16)	_TKExit:sta 	(zTemp1) 					; and ending $00
.a7bc	fa		plx				plx
.a7bd	60		rts				rts
.a7be					_TKNotEnd:
.a7be	c9 22		cmp #$22			cmp 	#'"'
.a7c0	f0 04		beq $a7c6			beq 	_TKIsQuote
.a7c2	c9 27		cmp #$27			cmp 	#"'"
.a7c4	d0 05		bne $a7cb			bne 	_TKNotQuote
.a7c6					_TKIsQuote:
.a7c6	20 ea a8	jsr $a8ea			jsr		TOKQuotedString
.a7c9	80 e5		bra $a7b0			bra 	_TKMainLoop
.a7cb					_TKNotQuote:
.a7cb	98		tya				tya 								; current pos -> zTemp0
.a7cc	18		clc				clc
.a7cd	65 10		adc $10				adc 	codePtr
.a7cf	85 14		sta $14				sta 	zTemp0
.a7d1	85 10		sta $10				sta 	codePtr
.a7d3	a5 11		lda $11				lda 	codePtr+1
.a7d5	69 00		adc #$00			adc 	#0
.a7d7	85 15		sta $15				sta 	zTemp0+1
.a7d9	85 11		sta $11				sta 	codePtr+1
.a7db	a0 00		ldy #$00			ldy 	#0 							; reset and get character
.a7dd	b1 10		lda ($10),y			lda 	(codePtr),y
.a7df	c9 26		cmp #$26			cmp 	#"&"						; hex marker
.a7e1	f0 08		beq $a7eb			beq 	_TKIsNumber
.a7e3	c9 30		cmp #$30			cmp 	#"0"						; check for decimal.
.a7e5	90 23		bcc $a80a			bcc 	_TKNotNumber
.a7e7	c9 3a		cmp #$3a			cmp 	#"9"+1
.a7e9	b0 1f		bcs $a80a			bcs 	_TKNotNumber
.a7eb					_TKIsNumber:
.a7eb	e8		inx				inx
.a7ec	20 33 a7	jsr $a733			jsr 	IntFromString 				; convert to integer
.a7ef	48		pha				pha
.a7f0	20 c2 a8	jsr $a8c2			jsr 	TokWriteConstant 			; do constant recursively.
.a7f3	7a		ply				ply
.a7f4	ca		dex				dex
.a7f5	b1 10		lda ($10),y			lda 	(codePtr),y
.a7f7	c9 2d		cmp #$2d			cmp 	#"-"						; followed by minus
.a7f9	d0 08		bne $a803			bne 	_TKIsPositive
.a7fb	c8		iny				iny									; skip it
.a7fc	a9 4f		lda #$4f			lda 	#KWD_CONSTANT_MINUS
.a7fe	20 b9 a8	jsr $a8b9			jsr 	TokWriteToken 				; write token out
.a801	80 ad		bra $a7b0			bra 	_TKMainLoop 				; loop back.
.a803					_TKIsPositive:
.a803	a9 4e		lda #$4e			lda 	#KWD_CONSTANT_PLUS
.a805	20 b9 a8	jsr $a8b9			jsr 	TokWriteToken 				; write token out
.a808	80 a6		bra $a7b0			bra 	_TKMainLoop 				; loop back.
.a80a					_TKNotNumber:
.a80a	a9 08		lda #$08			lda 	#KeywordText & $FF 			; zTemp2 -> token table
.a80c	85 18		sta $18				sta 	zTemp2
.a80e	a9 a1		lda #$a1			lda 	#KeywordText >> 8
.a810	85 19		sta $19				sta 	zTemp2+1
.a812	64 1a		stz $1a				stz 	zTemp3 						; clear 'best'
.a814	a9 10		lda #$10			lda 	#$10
.a816	85 1b		sta $1b				sta 	zTemp3+1 					; set current token
.a818					_TKSearch:
.a818	a0 00		ldy #$00			ldy 	#0
.a81a					_TKCompare:
.a81a	b1 10		lda ($10),y			lda 	(codePtr),y 	 			; get char from buffer
.a81c	c8		iny				iny
.a81d	d1 18		cmp ($18),y			cmp 	(zTemp2),y 					; does it match.
.a81f	d0 07		bne $a828			bne 	_TKNext
.a821	98		tya				tya
.a822	d2 18		cmp ($18)			cmp 	(zTemp2) 					; Y = length
.a824	d0 f4		bne $a81a			bne 	_TKCompare 					; found a match.
.a826	80 13		bra $a83b			bra 	_TKFound
.a828	b2 18		lda ($18)	_TKNext:lda 	(zTemp2)					; get length
.a82a	38		sec				sec 								; add length+1 to current
.a82b	65 18		adc $18				adc 	zTemp2
.a82d	85 18		sta $18				sta 	zTemp2
.a82f	90 02		bcc $a833			bcc 	_TKNNC
.a831	e6 19		inc $19				inc 	zTemp2+1
.a833	e6 1b		inc $1b		_TKNNC:	inc 	zTemp3+1 					; increment current token
.a835	b2 18		lda ($18)			lda 	(zTemp2) 					; reached then end
.a837	d0 df		bne $a818			bne 	_TKSearch 					; go try again.
.a839	80 0f		bra $a84a			bra 	_TKComplete
.a83b					_TKFound:
.a83b	98		tya				tya
.a83c	c5 1a		cmp $1a				cmp 	zTemp3 						; check best
.a83e	90 e8		bcc $a828			bcc 	_TKNext 					; if < best try next
.a840	f0 e6		beq $a828			beq 	_TKNext 					; if equal this is one of the special +- tokens
.a842	85 1a		sta $1a				sta 	zTemp3 						; update best
.a844	a5 1b		lda $1b				lda 	zTemp3+1 					; save current token.
.a846	85 1c		sta $1c				sta 	zTemp4
.a848	80 de		bra $a828			bra 	_TKNext
.a84a					_TKComplete:
.a84a	a5 1a		lda $1a				lda 	zTemp3 						; get "best score"
.a84c	f0 1a		beq $a868			beq		_TKTokenFail 				; if zero no match occurred
.a84e	a4 1a		ldy $1a				ldy 	zTemp3 						; length in Y
.a850	88		dey				dey
.a851	b1 10		lda ($10),y			lda 	(codePtr),y 				; look at last character
.a853	c8		iny				iny
.a854	20 a9 a8	jsr $a8a9			jsr 	TOKIsIdentifier 			; identifier character
.a857	90 07		bcc $a860			bcc 	_TKOutput 					; if not, then token is okay
.a859	b1 10		lda ($10),y			lda 	(codePtr),y 				; look at character after
.a85b	20 a9 a8	jsr $a8a9			jsr 	TOKIsIdentifier 			; is that an identifier
.a85e	b0 08		bcs $a868			bcs 	_TKTokenFail 				; if so it must be something like DEFAULT (DEF-AULT)
.a860					_TKOutput:
.a860	a5 1c		lda $1c				lda 	zTemp4 						; output actual token
.a862	20 b9 a8	jsr $a8b9			jsr 	TOKWriteToken
.a865	4c b0 a7	jmp $a7b0			jmp 	_TKMainLoop					; go round again
.a868					_TKTokenFail:
.a868	a0 00		ldy #$00			ldy 	#0
.a86a	b2 10		lda ($10)			lda 	(codePtr) 					; is the first an identifier ?
.a86c	20 a9 a8	jsr $a8a9			jsr 	TOKIsIdentifier
.a86f	b0 13		bcs $a884			bcs 	_TKCopyIdent 				; if yes copy it
.a871	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>a874	43 41 4e 4e 4f 54 20 54				.text 	"CANNOT TOKENISE",0
>a87c	4f 4b 45 4e 49 53 45 00
.a884					_TKCopyIdent:
.a884	c8		iny				iny 								; get next
.a885	b1 10		lda ($10),y			lda 	(codePtr),y
.a887	20 a9 a8	jsr $a8a9			jsr 	TOKIsIdentifier 			; if identifier
.a88a	08		php				php 								; save CS on stack
.a88b	88		dey				dey 								; back to character
.a88c	b1 10		lda ($10),y			lda 	(codePtr),y 				; get it
.a88e	c8		iny				iny
.a88f	c9 2e		cmp #$2e			cmp 	#"."
.a891	d0 02		bne $a895			bne 	_TKNotDot
.a893	a9 60		lda #$60			lda 	#'A'+31 					; to map . to 31
.a895					_TKNotDot:
.a895	38		sec				sec
.a896	e9 41		sbc #$41			sbc		#'A'
.a898	09 c0		ora #$c0			ora 	#$C0 						; in right range
.a89a	28		plp				plp 								; CS if next is identifier
.a89b	08		php				php
.a89c	b0 02		bcs $a8a0			bcs 	_TKNotLast					; CC if next is not identifier
.a89e	09 e0		ora #$e0			ora 	#$E0 						; range E0-FF
.a8a0					_TKNotLast:
.a8a0	20 b9 a8	jsr $a8b9			jsr 	TOKWriteToken 				; write out
.a8a3	28		plp				plp 								; get test result
.a8a4	b0 de		bcs $a884			bcs 	_TKCopyIdent 				; get the next identifier.
.a8a6	4c b0 a7	jmp $a7b0			jmp 	_TKMainLoop
.a8a9					TOKIsIdentifier:
.a8a9	c9 2e		cmp #$2e			cmp 	#"."
.a8ab	f0 08		beq $a8b5			beq 	_TIIYes
.a8ad	c9 41		cmp #$41			cmp 	#"A"
.a8af	90 06		bcc $a8b7			bcc 	_TIINo
.a8b1	c9 5b		cmp #$5b			cmp 	#"Z"+1
.a8b3	b0 02		bcs $a8b7			bcs 	_TIINo
.a8b5					_TIIYes:
.a8b5	38		sec				sec
.a8b6	60		rts				rts
.a8b7					_TIINo:
.a8b7	18		clc				clc
.a8b8	60		rts				rts
.a8b9					TokWriteToken:
.a8b9	92 16		sta ($16)			sta 	(zTemp1)
.a8bb	e6 16		inc $16				inc 	zTemp1
.a8bd	d0 02		bne $a8c1			bne 	_TWTExit
.a8bf	e6 17		inc $17				inc 	zTemp1+1
.a8c1					_TWTExit:
.a8c1	60		rts				rts
.a8c2					TokWriteConstant:
.a8c2	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; get current
.a8c5	29 3f		and #$3f			and		#63
.a8c7	48		pha				pha 								; save on stack
.a8c8	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check if < 64
.a8cb	29 c0		and #$c0			and 	#$C0
.a8cd	1d 00 0d	ora $0d00,x			ora 	stack1,x
.a8d0	1d 00 0e	ora $0e00,x			ora 	stack2,x
.a8d3	1d 00 0f	ora $0f00,x			ora 	stack3,x
.a8d6	f0 0d		beq $a8e5			beq 	_TWCNoCall 					; no, don't call.
.a8d8	5a		phy				phy
.a8d9	a0 06		ldy #$06			ldy 	#6
.a8db					_TWCShift:
.a8db	20 42 ab	jsr $ab42			jsr 	Unary_Shr
.a8de	88		dey				dey
.a8df	d0 fa		bne $a8db			bne 	_TWCShift
.a8e1	7a		ply				ply
.a8e2	20 c2 a8	jsr $a8c2			jsr 	TokWriteConstant
.a8e5					_TWCNoCall:
.a8e5	68		pla				pla
.a8e6	09 80		ora #$80			ora 	#$80						; make digit token
.a8e8	80 cf		bra $a8b9			bra 	TokWriteToken 				; and write it out.
.a8ea					TokQuotedString:
.a8ea	85 18		sta $18				sta 	zTemp2 						; save quote
.a8ec	49 22		eor #$22			eor 	#'"'						; now zero if double quotes
.a8ee	f0 02		beq $a8f2			beq 	_TQDouble
.a8f0	a9 01		lda #$01			lda 	#1
.a8f2					_TQDouble:
.a8f2	1a		inc a				inc 	a 							; 1 for double, 2 for single
.a8f3	20 b9 a8	jsr $a8b9			jsr 	TOKWriteToken 				; write out
.a8f6	a5 16		lda $16				lda 	zTemp1 						; copy zTemp1 to zTemp3 (byte count addr)
.a8f8	85 1a		sta $1a				sta 	zTemp3
.a8fa	a5 17		lda $17				lda 	zTemp1+1
.a8fc	85 1b		sta $1b				sta 	zTemp3+1
.a8fe	a9 03		lda #$03			lda 	#3 							; 3 is the size if it is empty - type,size,null
.a900	20 b9 a8	jsr $a8b9			jsr 	TOKWriteToken
.a903					_TQLoop:
.a903	c8		iny				iny 								; next character
.a904	b1 10		lda ($10),y			lda 	(codePtr),y
.a906	f0 0f		beq $a917			beq 	_TQExit 					; if zero exit
.a908	c5 18		cmp $18				cmp 	zTemp2 						; matching quote
.a90a	f0 0a		beq $a916			beq 	_TQSkipExit 				; skip it and exit
.a90c	20 b9 a8	jsr $a8b9			jsr 	TOKWriteToken 				; write out
.a90f	b2 1a		lda ($1a)			lda 	(zTemp3)					; inc char count
.a911	1a		inc a				inc 	a
.a912	92 1a		sta ($1a)			sta 	(zTemp3)
.a914	80 ed		bra $a903			bra 	_TQLoop						; go round
.a916					_TQSkipExit:
.a916	c8		iny				iny
.a917					_TQExit:
.a917	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.a919	20 b9 a8	jsr $a8b9			jsr 	TOKWriteToken
.a91c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/editor.asm

.a91d					EditProgram:
.a91d	ad 89 10	lda $1089			lda 	VarMemory+1
.a920	1a		inc a				inc 	a
.a921	c9 9f		cmp #$9f			cmp 	#MemoryEnd >> 8
.a923	b0 3c		bcs $a961			bcs 	_EPMemory
.a925	a2 00		ldx #$00			ldx 	#0
.a927	a9 03		lda #$03			lda 	#(TokeniseBuffer+3) & $FF
.a929	85 10		sta $10				sta 	codePtr
.a92b	a9 0a		lda #$0a			lda 	#(TokeniseBuffer+3) >> 8
.a92d	85 11		sta $11				sta 	codePtr+1
.a92f	a0 00		ldy #$00			ldy 	#0
.a931	a2 ff		ldx #$ff			ldx 	#255
.a933	20 03 a4	jsr $a403			jsr 	ExtractIntegerToTOS
.a936	98		tya				tya
.a937	18		clc				clc
.a938	65 10		adc $10				adc 	codePtr
.a93a	85 10		sta $10				sta 	codePtr
.a93c	90 02		bcc $a940			bcc 	_EPNoCarry
.a93e	e6 11		inc $11				inc 	codePtr+1
.a940					_EPNoCarry:
.a940	20 64 a9	jsr $a964			jsr 	EDFindLine
.a943	90 0f		bcc $a954			bcc 	_EPNotFound
.a945	a5 16		lda $16				lda 	zTemp1
.a947	48		pha				pha
.a948	a5 17		lda $17				lda 	zTemp1+1
.a94a	48		pha				pha
.a94b	20 9b a9	jsr $a99b			jsr 	EDDeleteLine
.a94e	68		pla				pla
.a94f	85 17		sta $17				sta 	zTemp1+1
.a951	68		pla				pla
.a952	85 16		sta $16				sta 	zTemp1
.a954					_EPNotFound:
.a954	b2 10		lda ($10)			lda 	(codePtr)
.a956	f0 03		beq $a95b			beq 	_EPNoInsert
.a958	20 c0 a9	jsr $a9c0			jsr 	EDInsertLine
.a95b					_EPNoInsert:
.a95b	20 49 a5	jsr $a549			jsr 	ResetForRun
.a95e	4c 4f a0	jmp $a04f			jmp 	NewCommand
.a961					_EPMemory:
.a961	4c e7 a5	jmp $a5e7			jmp 	OutOfMemoryError
.a964					EDFindLine:
.a964	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; set zTemp1 to start of program
.a966	85 16		sta $16				sta 	zTemp1
.a968	a9 11		lda #$11			lda 	#ProgramStart >> 8
.a96a	85 17		sta $17				sta 	zTemp1+1
.a96c					_EDFLLoop:
.a96c	a0 00		ldy #$00			ldy 	#0 							; reached the end
.a96e	b1 16		lda ($16),y			lda 	(zTemp1),y
.a970	f0 25		beq $a997			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.a972	c8		iny				iny
.a973	38		sec				sec
.a974	ad 00 0c	lda $0c00			lda 	stack0						; subtract the current from the target
.a977	f1 16		sbc ($16),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.a979	aa		tax				tax	 								; this will return 10.
.a97a	ad 00 0d	lda $0d00			lda 	stack1
.a97d	c8		iny				iny
.a97e	f1 16		sbc ($16),y			sbc 	(zTemp1),y
.a980	90 15		bcc $a997			bcc 	_EDFLFail					; if target < current then failed.
.a982	d0 04		bne $a988			bne 	_EDFLNext 					; if non-zero then goto next
.a984	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.a986	f0 11		beq $a999			beq 	_EDFLFound
.a988					_EDFLNext:
.a988	a0 00		ldy #$00			ldy 	#0 							; get offset
.a98a	18		clc				clc
.a98b	b1 16		lda ($16),y			lda 	(zTemp1),y
.a98d	65 16		adc $16				adc 	zTemp1 						; add to pointer
.a98f	85 16		sta $16				sta 	zTemp1
.a991	90 d9		bcc $a96c			bcc 	_EDFLLoop
.a993	e6 17		inc $17				inc 	zTemp1+1 					; carry out.
.a995	80 d5		bra $a96c			bra 	_EDFLLoop
.a997					_EDFLFail:
.a997	18		clc				clc
.a998	60		rts				rts
.a999					_EDFLFound:
.a999	38		sec				sec
.a99a	60		rts				rts
.a99b					EDDeleteLine:
.a99b	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.a99d	a2 00		ldx #$00			ldx 	#0
.a99f	b1 16		lda ($16),y			lda 	(zTemp1),y
.a9a1	a8		tay				tay 								; put in Y
.a9a2					_EDDelLoop:
.a9a2	b1 16		lda ($16),y			lda 	(zTemp1),y 					; get it
.a9a4	81 16		sta ($16,x)			sta 	(zTemp1,x) 					; write it.
.a9a6	a5 16		lda $16				lda 	zTemp1 						; check if pointer has reached the end of
.a9a8	cd 88 10	cmp $1088			cmp		VarMemory 					; low memory. We will have copied down an
.a9ab	d0 07		bne $a9b4			bne 	_EDDelNext 					; extra pile of stuff - technically should
.a9ad	a5 17		lda $17				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.a9af	cd 89 10	cmp $1089			cmp 	VarMemory+1					; doesn't really matter.
.a9b2	f0 08		beq $a9bc			beq		_EDDelExit
.a9b4					_EDDelNext:
.a9b4	e6 16		inc $16				inc 	zTemp1 						; go to next byte.
.a9b6	d0 ea		bne $a9a2			bne 	_EDDelLoop
.a9b8	e6 17		inc $17				inc 	zTemp1+1
.a9ba	80 e6		bra $a9a2			bra 	_EDDelLoop
.a9bc					_EDDelExit:
.a9bc	20 6f a5	jsr $a56f			jsr 	ResetVarMemory
.a9bf	60		rts				rts
.a9c0					EDInsertLine:
.a9c0	ad 88 10	lda $1088			lda 	VarMemory 					; copy high memory to zTemp3
.a9c3	85 1a		sta $1a				sta 	zTemp3
.a9c5	ad 89 10	lda $1089			lda 	VarMemory+1
.a9c8	85 1b		sta $1b				sta 	zTemp3+1
.a9ca	a0 00		ldy #$00			ldy 	#0 							; work out the line length.
.a9cc					_EDGetLength:
.a9cc	b1 10		lda ($10),y			lda 	(codePtr),y  				; get token
.a9ce	f0 0d		beq $a9dd			beq 	_EDGotLength 				; if 0, Y is the length
.a9d0	c8		iny				iny
.a9d1	c9 03		cmp #$03			cmp 	#3 							; 1 and 2 are ASCIIZ strings so skip them.
.a9d3	b0 f7		bcs $a9cc			bcs 	_EDGetLength
.a9d5	98		tya				tya 								; get original position
.a9d6	3a		dec a				dec 	a
.a9d7	18		clc				clc
.a9d8	71 10		adc ($10),y			adc 	(codePtr),y
.a9da	a8		tay				tay
.a9db	80 ef		bra $a9cc			bra 	_EDGetLength
.a9dd					_EDGotLength:
.a9dd	98		tya				tya
.a9de	18		clc				clc
.a9df	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.a9e1	48		pha				pha 								; save total size (e.g. offset)
.a9e2	85 1c		sta $1c				sta 	zTemp4 						; save for copying
.a9e4	a8		tay				tay 								; in Y
.a9e5	a2 00		ldx #$00			ldx 	#0
.a9e7					_EDInsLoop:
.a9e7	a1 1a		lda ($1a,x)			lda 	(zTemp3,x)					; copy it up
.a9e9	91 1a		sta ($1a),y			sta 	(zTemp3),y
.a9eb	a5 1a		lda $1a				lda 	zTemp3 						; reached the insert point (zTemp1)
.a9ed	c5 16		cmp $16				cmp 	zTemp1
.a9ef	d0 06		bne $a9f7			bne 	_EDINextShift
.a9f1	a5 1b		lda $1b				lda 	zTemp3+1
.a9f3	c5 17		cmp $17				cmp 	zTemp1+1
.a9f5	f0 0a		beq $aa01			beq 	_EDIShiftOver
.a9f7					_EDINextShift:
.a9f7	a5 1a		lda $1a				lda 	zTemp3 					; decrement the copy pointer.
.a9f9	d0 02		bne $a9fd			bne 	_EDINoBorrow
.a9fb	c6 1b		dec $1b				dec 	zTemp3+1
.a9fd					_EDINoBorrow:
.a9fd	c6 1a		dec $1a				dec 	zTemp3
.a9ff	80 e6		bra $a9e7			bra 	_EDInsLoop
.aa01					_EDIShiftOver:
.aa01	68		pla				pla 								; this is the size + others, e.g. offset
.aa02	a0 00		ldy #$00			ldy 	#0
.aa04	91 1a		sta ($1a),y			sta 	(zTemp3),y 					; write that out.
.aa06	ad 00 0c	lda $0c00			lda 	stack0 						; write LIne# out
.aa09	c8		iny				iny
.aa0a	91 1a		sta ($1a),y			sta 	(zTemp3),y
.aa0c	ad 00 0d	lda $0d00			lda 	stack1
.aa0f	c8		iny				iny
.aa10	91 1a		sta ($1a),y			sta 	(zTemp3),y
.aa12	c8		iny				iny 								; where the code goes.
.aa13	a2 00		ldx #$00			ldx 	#0 							; comes from
.aa15					_EDICopyCode:
.aa15	a1 10		lda ($10,x)			lda 	(codePtr,x)					; read from the current line
.aa17	91 1a		sta ($1a),y			sta 	(zTemp3),y 					; write out
.aa19	c8		iny				iny 								; bump pointers
.aa1a	e6 10		inc $10				inc 	codePtr
.aa1c	d0 02		bne $aa20			bne 	_EDINoCarry
.aa1e	e6 11		inc $11				inc 	codePtr+1
.aa20					_EDINoCarry:
.aa20	c6 1c		dec $1c				dec 	zTemp4 						; copy data in
.aa22	a5 1c		lda $1c				lda 	zTemp4 						; this is the total count - first 3 bytes seperate
.aa24	c9 03		cmp #$03			cmp 	#3 							; so exit on 3
.aa26	d0 ed		bne $aa15			bne 	_EDICopyCode
.aa28	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/stack.asm

.aa29					Stack_Empty:
.aa29	a2 00		ldx #$00			ldx 	#0
.aa2b	60		rts				rts
.aa2c					Stack_Drop:
.aa2c	ca		dex				dex
.aa2d	60		rts				rts
.aa2e					Stack_Dup:
.aa2e	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy to next up
.aa31	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.aa34	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa37	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.aa3a	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aa3d	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.aa40	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aa43	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.aa46	e8		inx				inx 								; bump stack pointer
.aa47	60		rts				rts
.aa48					Stack_Nip:
.aa48	bd 00 0c	lda $0c00,x			lda 	stack0,x	 				; copy top to 2nd
.aa4b	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.aa4e	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa51	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.aa54	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aa57	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.aa5a	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aa5d	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.aa60	ca		dex				dex 								; drop tos
.aa61	60		rts				rts
.aa62					Stack_Over:
.aa62	bd ff 0b	lda $0bff,x			lda 	stack0-1,x				; copy to next up
.aa65	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.aa68	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.aa6b	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.aa6e	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.aa71	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.aa74	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.aa77	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.aa7a	e8		inx				inx 							; bump stack pointer
.aa7b	60		rts				rts
.aa7c					Stack_Swap:
.aa7c	5a		phy				phy
.aa7d	bd 00 0c	lda $0c00,x			lda 	stack0,x
.aa80	a8		tay				tay
.aa81	bd ff 0b	lda $0bff,x			lda 	stack0-1,x
.aa84	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aa87	98		tya				tya
.aa88	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.aa8b	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa8e	a8		tay				tay
.aa8f	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.aa92	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aa95	98		tya				tya
.aa96	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.aa99	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aa9c	a8		tay				tay
.aa9d	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.aaa0	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aaa3	98		tya				tya
.aaa4	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.aaa7	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aaaa	a8		tay				tay
.aaab	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.aaae	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aab1	98		tya				tya
.aab2	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.aab5	7a		ply				ply
.aab6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/unary.asm

.aab7					Unary_Absolute:
.aab7	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aaba	30 01		bmi $aabd			bmi 	Unary_Negate
.aabc	60		rts				rts
.aabd					Unary_Negate:
.aabd	38		sec				sec
.aabe	a9 00		lda #$00			lda		#0
.aac0	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.aac3	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aac6	a9 00		lda #$00			lda		#0
.aac8	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.aacb	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aace	a9 00		lda #$00			lda		#0
.aad0	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.aad3	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aad6	a9 00		lda #$00			lda		#0
.aad8	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.aadb	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aade	60		rts				rts
.aadf					Unary_Not:
.aadf	bd 00 0c	lda $0c00,x			lda 	stack0,x
.aae2	49 ff		eor #$ff			eor 	#$FF
.aae4	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aae7	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aaea	49 ff		eor #$ff			eor 	#$FF
.aaec	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aaef	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aaf2	49 ff		eor #$ff			eor 	#$FF
.aaf4	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aaf7	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aafa	49 ff		eor #$ff			eor 	#$FF
.aafc	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aaff	60		rts				rts
.ab00					Unary_Increment:
.ab00	fe 00 0c	inc $0c00,x			inc 	stack0,x
.ab03	d0 0d		bne $ab12			bne 	_UIExit
.ab05	fe 00 0d	inc $0d00,x			inc 	stack1,x
.ab08	d0 08		bne $ab12			bne 	_UIExit
.ab0a	fe 00 0e	inc $0e00,x			inc 	stack2,x
.ab0d	d0 03		bne $ab12			bne 	_UIExit
.ab0f	fe 00 0f	inc $0f00,x			inc 	stack3,x
.ab12					_UIExit:
.ab12	60		rts				rts
.ab13					Unary_Decrement:
.ab13	38		sec				sec
.ab14	bd 00 0c	lda $0c00,x			lda 	stack0,x
.ab17	e9 01		sbc #$01			sbc 	#1
.ab19	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ab1c	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab1f	e9 00		sbc #$00			sbc 	#0
.ab21	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ab24	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ab27	e9 00		sbc #$00			sbc 	#0
.ab29	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ab2c	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ab2f	e9 00		sbc #$00			sbc 	#0
.ab31	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ab34	60		rts				rts
.ab35					Unary_Shl:
.ab35	1e 00 0c	asl $0c00,x			asl 	stack0,x
.ab38	3e 00 0d	rol $0d00,x			rol 	stack1,x
.ab3b	3e 00 0e	rol $0e00,x			rol 	stack2,x
.ab3e	3e 00 0f	rol $0f00,x			rol 	stack3,x
.ab41	60		rts				rts
.ab42					Unary_Shr:
.ab42	5e 00 0f	lsr $0f00,x			lsr 	stack3,x
.ab45	7e 00 0e	ror $0e00,x			ror 	stack2,x
.ab48	7e 00 0d	ror $0d00,x			ror 	stack1,x
.ab4b	7e 00 0c	ror $0c00,x			ror 	stack0,x
.ab4e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/memory.asm

.ab4f					Mem_Peek:
.ab4f	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.ab52	85 14		sta $14				sta 	zTemp0
.ab54	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab57	85 15		sta $15				sta 	zTemp0+1
.ab59	b2 14		lda ($14)			lda 	(zTemp0)					; read byte
.ab5b	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.ab5e	9e 00 0d	stz $0d00,x			stz 	stack1,x
.ab61	9e 00 0e	stz $0e00,x			stz 	stack2,x
.ab64	9e 00 0f	stz $0f00,x			stz 	stack3,x
.ab67	60		rts				rts
.ab68					Mem_WPeek:
.ab68	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.ab6b	85 14		sta $14				sta 	zTemp0
.ab6d	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab70	85 15		sta $15				sta 	zTemp0+1
.ab72	b2 14		lda ($14)			lda 	(zTemp0)					; read byte
.ab74	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.ab77	5a		phy				phy 								; read msb
.ab78	a0 01		ldy #$01			ldy 	#1
.ab7a	b1 14		lda ($14),y			lda 	(zTemp0),y
.ab7c	7a		ply				ply
.ab7d	9d 00 0d	sta $0d00,x			sta 	stack1,x 				; write to stack
.ab80	9e 00 0e	stz $0e00,x			stz 	stack2,x
.ab83	9e 00 0f	stz $0f00,x			stz 	stack3,x
.ab86	60		rts				rts
.ab87					Mem_DPeek:
.ab87	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.ab8a	85 14		sta $14				sta 	zTemp0
.ab8c	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab8f	85 15		sta $15				sta 	zTemp0+1
.ab91	b2 14		lda ($14)			lda 	(zTemp0)					; read byte
.ab93	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.ab96	5a		phy				phy 								; read msb
.ab97	a0 01		ldy #$01			ldy 	#1
.ab99	b1 14		lda ($14),y			lda 	(zTemp0),y
.ab9b	9d 00 0d	sta $0d00,x			sta 	stack1,x 					; write to stack
.ab9e	c8		iny				iny
.ab9f	b1 14		lda ($14),y			lda 	(zTemp0),y
.aba1	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aba4	c8		iny				iny
.aba5	b1 14		lda ($14),y			lda 	(zTemp0),y
.aba7	9d 00 0f	sta $0f00,x			sta 	stack3,x
.abaa	7a		ply				ply
.abab	60		rts				rts
.abac					Mem_Poke:
.abac	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.abaf	85 14		sta $14				sta 	zTemp0
.abb1	bd 00 0d	lda $0d00,x			lda 	stack1,x
.abb4	85 15		sta $15				sta 	zTemp0+1
.abb6	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.abb9	92 14		sta ($14)			sta 	(zTemp0)
.abbb	ca		dex				dex
.abbc	ca		dex				dex
.abbd	60		rts				rts
.abbe					Mem_WPoke:
.abbe	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.abc1	85 14		sta $14				sta 	zTemp0
.abc3	bd 00 0d	lda $0d00,x			lda 	stack1,x
.abc6	85 15		sta $15				sta 	zTemp0+1
.abc8	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.abcb	92 14		sta ($14)			sta 	(zTemp0)
.abcd	5a		phy				phy
.abce	a0 01		ldy #$01			ldy 	#1
.abd0	bd ff 0e	lda $0eff,x			lda 	stack3-1,x 				; byte to write
.abd3	91 14		sta ($14),y			sta 	(zTemp0),y
.abd5	7a		ply				ply
.abd6	ca		dex				dex
.abd7	ca		dex				dex
.abd8	60		rts				rts
.abd9					Mem_DPoke:
.abd9	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.abdc	85 14		sta $14				sta 	zTemp0
.abde	bd 00 0d	lda $0d00,x			lda 	stack1,x
.abe1	85 15		sta $15				sta 	zTemp0+1
.abe3	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 					; byte to write
.abe6	92 14		sta ($14)			sta 	(zTemp0)
.abe8	5a		phy				phy
.abe9	a0 01		ldy #$01			ldy 	#1
.abeb	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.abee	91 14		sta ($14),y			sta 	(zTemp0),y
.abf0	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.abf3	c8		iny				iny
.abf4	91 14		sta ($14),y			sta 	(zTemp0),y
.abf6	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.abf9	c8		iny				iny
.abfa	91 14		sta ($14),y			sta 	(zTemp0),y
.abfc	7a		ply				ply
.abfd	ca		dex				dex
.abfe	ca		dex				dex
.abff	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/binary.asm

.ac00					Stack_Add:
.ac00	ca		dex				dex
.ac01					Stack_Add_No_Dex:
.ac01	18		clc				clc
.ac02	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac05	7d 01 0c	adc $0c01,x			adc 	stack0+1,x
.ac08	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac0b	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac0e	7d 01 0d	adc $0d01,x			adc 	stack1+1,x
.ac11	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac14	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac17	7d 01 0e	adc $0e01,x			adc 	stack2+1,x
.ac1a	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac1d	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac20	7d 01 0f	adc $0f01,x			adc 	stack3+1,x
.ac23	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac26	60		rts				rts
.ac27					Stack_Sub:
.ac27	ca		dex				dex
.ac28	38		sec				sec
.ac29	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac2c	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.ac2f	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac32	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac35	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.ac38	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac3b	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac3e	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ac41	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac44	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac47	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ac4a	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac4d	60		rts				rts
.ac4e					Stack_And:
.ac4e	ca		dex				dex
.ac4f	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac52	3d 01 0c	and $0c01,x			and		stack0+1,x
.ac55	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac58	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac5b	3d 01 0d	and $0d01,x			and 	stack1+1,x
.ac5e	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac61	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac64	3d 01 0e	and $0e01,x			and 	stack2+1,x
.ac67	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac6a	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac6d	3d 01 0f	and $0f01,x			and 	stack3+1,x
.ac70	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac73	60		rts				rts
.ac74					Stack_Xor:
.ac74	ca		dex				dex
.ac75	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac78	5d 01 0c	eor $0c01,x			eor		stack0+1,x
.ac7b	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac7e	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac81	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.ac84	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac87	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac8a	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.ac8d	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac90	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac93	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.ac96	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac99	60		rts				rts
.ac9a					Stack_Or:
.ac9a	ca		dex				dex
.ac9b	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac9e	1d 01 0c	ora $0c01,x			ora		stack0+1,x
.aca1	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aca4	bd 00 0d	lda $0d00,x			lda		stack1,x
.aca7	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.acaa	9d 00 0d	sta $0d00,x			sta 	stack1,x
.acad	bd 00 0e	lda $0e00,x			lda		stack2,x
.acb0	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.acb3	9d 00 0e	sta $0e00,x			sta 	stack2,x
.acb6	bd 00 0f	lda $0f00,x			lda		stack3,x
.acb9	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.acbc	9d 00 0f	sta $0f00,x			sta 	stack3,x
.acbf	60		rts				rts
.acc0					Stack_Shl:
.acc0	38		sec				sec
.acc1	80 01		bra $acc4			bra 	StackShift
.acc3					Stack_Shr:
.acc3	18		clc				clc
.acc4					StackShift:
.acc4	08		php				php
.acc5	ca		dex				dex
.acc6	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; if the shift >= 32
.acc9	29 e0		and #$e0			and 	#$E0 						; going to be zero.
.accb	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.acce	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.acd1	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.acd4	d0 13		bne $ace9			bne 	_SSZero
.acd6					_SSLoop:
.acd6	de 01 0c	dec $0c01,x			dec 	stack0+1,x 					; dec check count
.acd9	30 1a		bmi $acf5			bmi 	_SSDone 					; completed ?
.acdb	28		plp				plp 								; restore flag
.acdc	08		php				php
.acdd	b0 05		bcs $ace4			bcs 	_SSLeft 					; do either shift.
.acdf	20 42 ab	jsr $ab42			jsr 	Unary_Shr
.ace2	80 f2		bra $acd6			bra 	_SSLoop
.ace4					_SSLeft:
.ace4	20 35 ab	jsr $ab35			jsr 	Unary_Shl
.ace7	80 ed		bra $acd6			bra 	_SSLoop
.ace9					_SSZero:
.ace9	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; too many shifts.
.acec	9e 00 0d	stz $0d00,x			stz 	stack1,x
.acef	9e 00 0e	stz $0e00,x			stz 	stack2,x
.acf2	9e 00 0f	stz $0f00,x			stz 	stack3,x
.acf5					_SSDone:
.acf5	28		plp				plp 								; throw flag.
.acf6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/multiply.asm

.acf7					MulInteger32:
.acf7	ca		dex				dex
.acf8	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy +0 to workspace
.acfb	85 1e		sta $1e				sta 	zLTemp1
.acfd	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ad00	85 1f		sta $1f				sta 	zLTemp1+1
.ad02	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ad05	85 20		sta $20				sta 	zLTemp1+2
.ad07	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ad0a	85 21		sta $21				sta 	zLTemp1+3
.ad0c	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; zero +0, where the result goes.
.ad0f	9e 00 0d	stz $0d00,x			stz 	stack1,x
.ad12	9e 00 0e	stz $0e00,x			stz 	stack2,x
.ad15	9e 00 0f	stz $0f00,x			stz 	stack3,x
.ad18					_BFMMultiply:
.ad18	a5 1e		lda $1e				lda 	zLTemp1 					; get LSBit of 8-11
.ad1a	29 01		and #$01			and 	#1
.ad1c	f0 03		beq $ad21			beq 	_BFMNoAdd
.ad1e	20 01 ac	jsr $ac01			jsr 	Stack_Add_No_Dex 			; co-opt this code
.ad21					_BFMNoAdd:
.ad21	1e 01 0c	asl $0c01,x			asl 	stack0+1,x 					; shift +4 left
.ad24	3e 01 0d	rol $0d01,x			rol 	stack1+1,x
.ad27	3e 01 0e	rol $0e01,x			rol 	stack2+1,x
.ad2a	3e 01 0f	rol $0f01,x			rol 	stack3+1,x
.ad2d	46 21		lsr $21				lsr 	zLTemp1+3 					; shift +8 right
.ad2f	66 20		ror $20				ror 	zLTemp1+2
.ad31	66 1f		ror $1f				ror 	zLTemp1+1
.ad33	66 1e		ror $1e				ror 	zLTemp1
.ad35	a5 1e		lda $1e				lda 	zLTemp1 					; continue if +8 is nonzero
.ad37	05 1f		ora $1f				ora 	zLTemp1+1
.ad39	05 20		ora $20				ora 	zLTemp1+2
.ad3b	05 21		ora $21				ora 	zLTemp1+3
.ad3d	d0 d9		bne $ad18			bne 	_BFMMultiply
.ad3f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/divide.asm

.ad40					DivInteger32:
.ad40	ca		dex				dex
.ad41	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check for division by zero.
.ad44	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.ad47	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.ad4a	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.ad4d	d0 14		bne $ad63			bne 	_BFDOkay
.ad4f	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>ad52	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>ad5a	20 42 59 20 5a 45 52 4f 00
.ad63					_BFDOkay:
.ad63	64 1e		stz $1e				stz 	zLTemp1 					; Q/Dividend/Left in +0
.ad65	64 1f		stz $1f				stz 	zLTemp1+1 					; M/Divisor/Right in +4
.ad67	64 20		stz $20				stz 	zLTemp1+2
.ad69	64 21		stz $21				stz 	zLTemp1+3
.ad6b	9c 23 08	stz $0823			stz 	SignCount 					; Count of signs.
.ad6e	20 c9 ad	jsr $adc9			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ad71	e8		inx				inx
.ad72	20 c9 ad	jsr $adc9			jsr 	CheckIntegerNegate
.ad75	ca		dex				dex
.ad76	5a		phy				phy 								; Y is the counter
.ad77	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.ad79					_BFDLoop:
.ad79	1e 00 0c	asl $0c00,x			asl 	stack0,x 					; shift AQ left.
.ad7c	3e 00 0d	rol $0d00,x			rol 	stack1,x
.ad7f	3e 00 0e	rol $0e00,x			rol 	stack2,x
.ad82	3e 00 0f	rol $0f00,x			rol 	stack3,x
.ad85	26 1e		rol $1e				rol 	zLTemp1
.ad87	26 1f		rol $1f				rol 	zLTemp1+1
.ad89	26 20		rol $20				rol 	zLTemp1+2
.ad8b	26 21		rol $21				rol 	zLTemp1+3
.ad8d	38		sec				sec
.ad8e	a5 1e		lda $1e				lda 	zLTemp1+0 					; Calculate A-M on stack.
.ad90	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.ad93	48		pha				pha
.ad94	a5 1f		lda $1f				lda 	zLTemp1+1
.ad96	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.ad99	48		pha				pha
.ad9a	a5 20		lda $20				lda 	zLTemp1+2
.ad9c	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ad9f	48		pha				pha
.ada0	a5 21		lda $21				lda 	zLTemp1+3
.ada2	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ada5	90 15		bcc $adbc			bcc 	_BFDNoAdd
.ada7	85 21		sta $21				sta 	zLTemp1+3 					; update A
.ada9	68		pla				pla
.adaa	85 20		sta $20				sta 	zLTemp1+2
.adac	68		pla				pla
.adad	85 1f		sta $1f				sta 	zLTemp1+1
.adaf	68		pla				pla
.adb0	85 1e		sta $1e				sta 	zLTemp1+0
.adb2	bd 00 0c	lda $0c00,x			lda 	stack0,x 			; set Q bit 1.
.adb5	09 01		ora #$01			ora 	#1
.adb7	9d 00 0c	sta $0c00,x			sta 	stack0,x
.adba	80 03		bra $adbf			bra 	_BFDNext
.adbc					_BFDNoAdd:
.adbc	68		pla				pla 								; Throw away the intermediate calculations
.adbd	68		pla				pla
.adbe	68		pla				pla
.adbf					_BFDNext:
.adbf	88		dey				dey
.adc0	d0 b7		bne $ad79			bne 	_BFDLoop
.adc2	7a		ply				ply 								; restore Y
.adc3	4e 23 08	lsr $0823			lsr 	SignCount 					; if sign count odd,
.adc6	b0 07		bcs $adcf			bcs		IntegerNegateAlways 		; negate the result
.adc8	60		rts				rts
.adc9					CheckIntegerNegate:
.adc9	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; is it -ve = MSB set ?
.adcc	30 01		bmi $adcf			bmi 	IntegerNegateAlways 		; if so negate it
.adce	60		rts				rts
.adcf					IntegerNegateAlways:
.adcf	ee 23 08	inc $0823			inc 	SignCount 					; bump the count of signs
.add2	4c bd aa	jmp $aabd			jmp 	Unary_Negate
.add5					ModInteger32:
.add5	20 40 ad	jsr $ad40			jsr 	DivInteger32
.add8	a5 1e		lda $1e				lda 	zLTemp1
.adda	9d 00 0c	sta $0c00,x			sta 	stack0,x
.addd	a5 1f		lda $1f				lda 	zLTemp1+1
.addf	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ade2	a5 20		lda $20				lda 	zLTemp1+2
.ade4	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ade7	a5 21		lda $21				lda 	zLTemp1+3
.ade9	9d 00 0f	sta $0f00,x			sta 	stack3,x
.adec	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/compare.asm

.aded					Comp_Equal:
.aded	38		sec				sec
.adee	80 01		bra $adf1			bra 	Comp_CheckEqual
.adf0					Comp_NotEqual:
.adf0	18		clc				clc
.adf1					Comp_CheckEqual:
.adf1	08		php				php
.adf2	ca		dex				dex
.adf3	bd 00 0c	lda $0c00,x			lda		stack0,x
.adf6	5d 01 0c	eor $0c01,x			eor 	stack0+1,x
.adf9	d0 16		bne $ae11			bne 	_CCENonZero
.adfb	bd 00 0d	lda $0d00,x			lda		stack1,x
.adfe	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.ae01	d0 0e		bne $ae11			bne 	_CCENonZero
.ae03	bd 00 0e	lda $0e00,x			lda		stack2,x
.ae06	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.ae09	d0 06		bne $ae11			bne 	_CCENonZero
.ae0b	bd 00 0f	lda $0f00,x			lda		stack3,x
.ae0e	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.ae11					_CCENonZero:
.ae11	f0 02		beq $ae15			beq 	_CCENotSet
.ae13	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.ae15					_CCENotSet:
.ae15					CompCheckFlip:
.ae15	28		plp				plp 								; if carry set, we want $FF if equal
.ae16	90 02		bcc $ae1a			bcc 	CompReturn
.ae18	49 ff		eor #$ff			eor 	#$FF
.ae1a					CompReturn:
.ae1a	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; save result on stack.
.ae1d	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ae20	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ae23	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ae26	60		rts				rts
.ae27					Comp_Less:
.ae27	18		clc				clc
.ae28	80 01		bra $ae2b			bra 	Comp_LessCont
.ae2a					Comp_GreaterEqual:
.ae2a	38		sec				sec
.ae2b					Comp_LessCont:
.ae2b	08		php				php
.ae2c	ca		dex				dex
.ae2d	38		sec				sec
.ae2e	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; do a subtraction w/o storing the result
.ae31	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.ae34	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ae37	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.ae3a	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ae3d	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ae40	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ae43	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ae46	50 02		bvc $ae4a			bvc 	_CLNoFlip 					; unsigned -> signed
.ae48	49 80		eor #$80			eor 	#$80
.ae4a					_CLNoFlip:
.ae4a	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.ae4c	f0 c7		beq $ae15			beq 	CompCheckFlip
.ae4e	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.ae50	80 c3		bra $ae15			bra 	CompCheckFlip
.ae52					Comp_LessEqual:
.ae52	38		sec				sec
.ae53	80 01		bra $ae56			bra 	Comp_LessEqualCont
.ae55					Comp_Greater:
.ae55	18		clc				clc
.ae56					Comp_LessEqualCont:
.ae56	08		php				php
.ae57	ca		dex				dex
.ae58	38		sec				sec
.ae59	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; do a subtraction w/o storing the result, backwards
.ae5c	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.ae5f	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.ae62	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.ae65	bd 01 0e	lda $0e01,x			lda 	stack2+1,x
.ae68	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.ae6b	bd 01 0f	lda $0f01,x			lda 	stack3+1,x
.ae6e	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.ae71	50 02		bvc $ae75			bvc 	_CLENoFlip 					; unsigned -> signed
.ae73	49 80		eor #$80			eor 	#$80
.ae75					_CLENoFlip:
.ae75	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.ae77	f0 9c		beq $ae15			beq 	CompCheckFlip
.ae79	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.ae7b	80 98		bra $ae15			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: miscellany/alloc.asm

.ae7d					Allocate:
.ae7d	bd 00 0d	lda $0d00,x			lda 	stack1,x					; check 0-32767 allocated.
.ae80	29 80		and #$80			and 	#$80
.ae82	1d 00 0e	ora $0e00,x			ora 	stack2,x
.ae85	1d 00 0f	ora $0f00,x			ora 	stack3,x
.ae88	d0 26		bne $aeb0			bne 	_ALBad
.ae8a	18		clc				clc 								; add to varmemory pointer saving
.ae8b	ad 88 10	lda $1088			lda 	VarMemory 					; address
.ae8e	48		pha				pha
.ae8f	7d 00 0c	adc $0c00,x			adc 	stack0,x
.ae92	8d 88 10	sta $1088			sta 	VarMemory
.ae95	ad 89 10	lda $1089			lda 	VarMemory+1
.ae98	48		pha				pha
.ae99	7d 00 0d	adc $0d00,x			adc 	stack1,x
.ae9c	8d 89 10	sta $1089			sta 	VarMemory+1
.ae9f	68		pla				pla 								; pop and save
.aea0	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aea3	68		pla				pla
.aea4	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aea7	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aeaa	cd 8b 10	cmp $108b			cmp 	AllocMemory+1 				; check range
.aead	b0 01		bcs $aeb0			bcs 	_ALBad
.aeaf	60		rts				rts
.aeb0					_ALBad:
.aeb0	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>aeb3	42 41 44 20 41 4c 4c 4f				.text 	"BAD ALLOC",0
>aebb	43 00

;******  Return to file: main.asm


;******  Processing file: miscellany/list.asm

.aebd					Cmd_List:
.aebd	20 3e a5	jsr $a53e			jsr 	ResetCodePointer 			; back to the beginning
.aec0	64 18		stz $18				stz 	zTemp2						; clear the lowest-number
.aec2	64 19		stz $19				stz 	zTemp2+1
.aec4	e0 00		cpx #$00			cpx 	#0 							; stack empty ?
.aec6	f0 0b		beq $aed3			beq 	_CLINone
.aec8	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; use tos as start line
.aecb	85 18		sta $18				sta 	zTemp2
.aecd	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aed0	85 19		sta $19				sta 	zTemp2+1
.aed2	ca		dex				dex 								; and pop the tos
.aed3					_CLINone:
.aed3	a9 1e		lda #$1e			lda 	#30 						; list this many lines
.aed5	85 16		sta $16				sta 	zTemp1
.aed7					_CLILoop
.aed7	b2 10		lda ($10)			lda 	(codePtr)					; check end of program
.aed9	f0 24		beq $aeff			beq 	_CLIEnd
.aedb	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.aedd	38		sec				sec
.aede	b1 10		lda ($10),y			lda 	(codePtr),y
.aee0	e5 18		sbc $18				sbc 	zTemp2
.aee2	c8		iny				iny
.aee3	b1 10		lda ($10),y			lda 	(codePtr),y
.aee5	e5 19		sbc $19				sbc 	zTemp2+1
.aee7	90 09		bcc $aef2			bcc 	_CLISkip
.aee9	da		phx				phx
.aeea	20 02 af	jsr $af02			jsr 	ListCurrent 				; list the line.
.aeed	fa		plx				plx
.aeee	c6 16		dec $16				dec 	zTemp1 						; done all lines
.aef0	f0 0d		beq $aeff			beq 	_CLIEnd
.aef2					_CLISkip:
.aef2	18		clc				clc
.aef3	b2 10		lda ($10)			lda 	(codePtr) 					; go to next
.aef5	65 10		adc $10				adc 	codePtr
.aef7	85 10		sta $10				sta 	codePtr
.aef9	90 dc		bcc $aed7			bcc 	_CLILoop
.aefb	e6 11		inc $11				inc 	codePtr+1
.aefd	80 d8		bra $aed7			bra 	_CLILoop
.aeff					_CLIEnd:
.aeff	4c 3b a0	jmp $a03b			jmp 	WarmStart
.af02					ListCurrent:
.af02	a0 03		ldy #$03			ldy 	#3
.af04	b1 10		lda ($10),y			lda 	(codePtr),y
.af06	c9 02		cmp #$02			cmp 	#2
.af08	d0 0e		bne $af18			bne 	_LCList
.af0a	a9 0d		lda #$0d			lda 	#13
.af0c	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.af0f	20 18 af	jsr $af18			jsr 	_LCList
.af12	a9 0d		lda #$0d			lda 	#13
.af14	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.af17	60		rts				rts
.af18					_LCList:
.af18	a9 05		lda #$05			lda 	#CTH_LINENO
.af1a	20 ab a2	jsr $a2ab			jsr 	ExternColour 				; set colour
.af1d	a0 01		ldy #$01			ldy 	#1							; print line#
.af1f	b1 10		lda ($10),y			lda 	(codePtr),y
.af21	48		pha				pha
.af22	c8		iny				iny
.af23	b1 10		lda ($10),y			lda 	(codePtr),y
.af25	a8		tay				tay
.af26	68		pla				pla
.af27	20 3c a6	jsr $a63c			jsr 	ErrorPrint16
.af2a	a8		tay				tay
.af2b					_LCPadOut:
.af2b	a9 20		lda #$20			lda 	#' '
.af2d	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.af30	c8		iny				iny
.af31	c0 05		cpy #$05			cpy 	#5
.af33	d0 f6		bne $af2b			bne 	_LCPadOut
.af35	a0 03		ldy #$03			ldy 	#3 							; start here
.af37					_LCLoop:
.af37	a9 20		lda #$20			lda 	#' '						; space
.af39	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.af3c					_LCLoopNoSpace:
.af3c	b1 10		lda ($10),y			lda 	(codePtr),y 				; get first
.af3e	30 44		bmi $af84			bmi 	_LCIdentConst 				; identifier or constant
.af40	d0 05		bne $af47			bne 	_LCStringToken
.af42	a9 0d		lda #$0d			lda 	#13
.af44	4c a1 a2	jmp $a2a1			jmp 	ExternPrint
.af47					_LCStringToken:
.af47	c9 10		cmp #$10			cmp 	#$10 						; if < 10 it's a string.
.af49	90 0c		bcc $af57			bcc		_LCString
.af4b	20 c5 af	jsr $afc5			jsr 	ListPrintToken
.af4e	b1 10		lda ($10),y			lda 	(codePtr),y 				; no space if ^
.af50	c8		iny				iny 								; advance pointer
.af51	c9 4d		cmp #$4d			cmp 	#KWD_HAT
.af53	f0 e7		beq $af3c			beq 	_LCLoopNoSpace
.af55	80 e0		bra $af37			bra 	_LCLoop 					; go round again.
.af57					_LCString:
.af57	4a		lsr a				lsr 	a 							; CS if 1 (string) CC if 2 (comment)
.af58	a9 05		lda #$05			lda 	#CTH_STRING 				; decide on colour.
.af5a	a2 22		ldx #$22			ldx 	#'"'
.af5c	b0 0a		bcs $af68			bcs 	_LCSSkip
.af5e	a9 0a		lda #$0a			lda 	#CTH_COMMENT
.af60	a2 27		ldx #$27			ldx 	#"'"
.af62	c0 03		cpy #$03			cpy 	#3
.af64	f0 02		beq $af68			beq 	_LCSSkip
.af66	a9 09		lda #$09			lda 	#CTH_LCOMMENT
.af68					_LCSSkip:
.af68	20 ab a2	jsr $a2ab			jsr 	ExternColour 				; set colour
.af6b	8a		txa				txa
.af6c	48		pha				pha 								; save end quote on stack.
.af6d	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.af70	c8		iny				iny 								; skip type size
.af71	c8		iny				iny
.af72					_LCSPrint:
.af72	b1 10		lda ($10),y			lda 	(codePtr),y
.af74	c8		iny				iny
.af75	c9 00		cmp #$00			cmp 	#0 							; 0 is end
.af77	f0 05		beq $af7e			beq 	_LCSExit
.af79	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.af7c	80 f4		bra $af72			bra 	_LCSPrint
.af7e					_LCSExit:
.af7e	68		pla				pla
.af7f	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.af82	80 b3		bra $af37			bra 	_LCLoop
.af84					_LCIdentConst:
.af84	c9 c0		cmp #$c0			cmp 	#$C0						; check if constant
.af86	90 1e		bcc $afa6			bcc 	_LCConstant
.af88	a9 03		lda #$03			lda 	#CTH_IDENT 					; set colour
.af8a	20 ab a2	jsr $a2ab			jsr 	ExternColour
.af8d					_LCCIdLoop:
.af8d	b1 10		lda ($10),y			lda 	(codePtr),y 				; read
.af8f	29 1f		and #$1f			and 	#$1F 						; convert
.af91	18		clc				clc
.af92	69 41		adc #$41			adc 	#'A'
.af94	c9 60		cmp #$60			cmp 	#'A'+31 					; handle '.'
.af96	d0 02		bne $af9a			bne 	_LCCNotDot
.af98	a9 2e		lda #$2e			lda 	#'.'
.af9a					_LCCNotDot:
.af9a	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.af9d	b1 10		lda ($10),y			lda 	(codePtr),y 				; at end ?
.af9f	c8		iny				iny
.afa0	c9 e0		cmp #$e0			cmp 	#$E0
.afa2	b0 93		bcs $af37			bcs 	_LCLoop
.afa4	80 e7		bra $af8d			bra 	_LCCIdLoop
.afa6					_LCConstant:
.afa6	a9 06		lda #$06			lda 	#CTH_NUMBER 				; number colour
.afa8	20 ab a2	jsr $a2ab			jsr 	ExternColour
.afab	a2 fe		ldx #$fe			ldx 	#254 						; use the topmost stack element
.afad	20 03 a4	jsr $a403			jsr 	ExtractIntegerToTOS 		; so there is a very rare case
.afb0	bd 00 0f	lda $0f00,x			lda 	stack3+0,x					; save stack top byte
.afb3	48		pha				pha
.afb4	20 61 a6	jsr $a661			jsr 	IntegerToString 			; this could corrupt stack if full :)
.afb7	20 4f a6	jsr $a64f			jsr 	ErrorPrintIntegerBuffer
.afba	68		pla				pla 								; sign back
.afbb	10 05		bpl $afc2			bpl 	_LCLoop2
.afbd	a9 2d		lda #$2d			lda 	#"-"
.afbf	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.afc2					_LCLoop2:
.afc2	4c 37 af	jmp $af37			jmp 	_LCLoop
.afc5					ListPrintToken:
.afc5	5a		phy				phy
.afc6	48		pha				pha 								; token colour
.afc7	a9 07		lda #$07			lda 	#CTH_TOKEN
.afc9	20 ab a2	jsr $a2ab			jsr 	ExternColour
.afcc	fa		plx				plx
.afcd	a9 08		lda #$08			lda 	#KeywordText & $FF
.afcf	85 14		sta $14				sta 	zTemp0
.afd1	a9 a1		lda #$a1			lda 	#KeywordText >> 8
.afd3	85 15		sta $15				sta 	zTemp0+1
.afd5					_LPTLoop:
.afd5	e0 10		cpx #$10			cpx 	#$10 						; first token is $10
.afd7	f0 0e		beq $afe7			beq 	_LPTFound
.afd9	ca		dex				dex
.afda	b2 14		lda ($14)			lda 	(zTemp0)
.afdc	38		sec				sec									; add 1, it's length+name
.afdd	65 14		adc $14				adc 	zTemp0
.afdf	85 14		sta $14				sta 	zTemp0
.afe1	90 f2		bcc $afd5			bcc 	_LPTLoop
.afe3	e6 15		inc $15				inc 	zTemp0+1
.afe5	80 ee		bra $afd5			bra 	_LPTLoop
.afe7					_LPTFound:
.afe7	a0 01		ldy #$01			ldy 	#1 							; start here.
.afe9					_LPTShow:
.afe9	b1 14		lda ($14),y			lda 	(zTemp0),y 					; get character
.afeb	c9 20		cmp #$20			cmp 	#32 						; < 32, length, so exit
.afed	90 06		bcc $aff5			bcc 	_LPTExit
.afef	c8		iny				iny
.aff0	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.aff3	80 f4		bra $afe9			bra 	_LPTShow
.aff5					_LPTExit:
.aff5	7a		ply				ply
.aff6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/renumber.asm

.aff7					Cmd_Renumber:
.aff7	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; zTemp1 line number being changed
.aff9	85 16		sta $16				sta 	zTemp1
.affb	a9 11		lda #$11			lda 	#ProgramStart >> 8
.affd	85 17		sta $17				sta 	zTemp1+1
.afff	a9 e8		lda #$e8			lda 	#1000 & $FF 				; zTemp2 new number
.b001	85 18		sta $18				sta 	zTemp2
.b003	a9 03		lda #$03			lda 	#1000 >> 8
.b005	85 19		sta $19				sta 	zTemp2+1
.b007					_CRLoop:
.b007	b2 16		lda ($16)			lda 	(zTemp1) 					; check end of program
.b009	f0 23		beq $b02e			beq 	_CRExit
.b00b	a0 01		ldy #$01			ldy 	#1 							; copy new number in
.b00d	a5 18		lda $18				lda 	zTemp2
.b00f	91 16		sta ($16),y			sta 	(zTemp1),y
.b011	c8		iny				iny
.b012	a5 19		lda $19				lda 	zTemp2+1
.b014	91 16		sta ($16),y			sta 	(zTemp1),y
.b016	18		clc				clc 								; add 10 to new number
.b017	a5 18		lda $18				lda 	zTemp2
.b019	69 0a		adc #$0a			adc 	#10
.b01b	85 18		sta $18				sta 	zTemp2
.b01d	90 02		bcc $b021			bcc 	_CRNoCarry
.b01f	e6 19		inc $19				inc 	zTemp2+1
.b021					_CRNoCarry:
.b021	18		clc				clc 								; go to next line
.b022	b2 16		lda ($16)			lda 	(zTemp1)
.b024	65 16		adc $16				adc 	zTemp1
.b026	85 16		sta $16				sta 	zTemp1
.b028	90 dd		bcc $b007			bcc 	_CRLoop
.b02a	e6 17		inc $17				inc 	zTemp1+1
.b02c	80 d9		bra $b007			bra 	_CRLoop
.b02e					_CRExit:
.b02e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/system.asm

.b02f					System_RUN:
.b02f	20 49 a5	jsr $a549			jsr		ResetForRun 				; clear vars, stacks etc.
.b032	20 3e a5	jsr $a53e			jsr 	ResetCodePointer 			; point to first thing to do.
.b035	4c 84 a3	jmp $a384			jmp 	Execute						; and run
.b038					System_END:
.b038	4c 3b a0	jmp $a03b			jmp 	WarmStart
.b03b					System_STOP:
.b03b	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b03e	53 54 4f 50 00					.text 	"STOP",0
.b043					System_Assert:
.b043	ca		dex				dex
.b044	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.b047	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.b04a	1d 02 0d	ora $0d02,x			ora 	stack1+2,x
.b04d	1d 03 0d	ora $0d03,x			ora 	stack1+3,x
.b050	d0 0a		bne $b05c			bne 	_SAOkay
.b052	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b055	41 53 53 45 52 54 00				.text 	"ASSERT",0
.b05c	60		rts		_SAOkay:rts
.b05d					System_New:
.b05d	9c 00 11	stz $1100			stz 	ProgramStart 				; zero the first offset, erases.
.b060	20 49 a5	jsr $a549			jsr		ResetForRun 				; clear vars, stacks etc.
.b063	4c 3b a0	jmp $a03b			jmp 	WarmStart
.b066					System_Old:
.b066	20 3e a5	jsr $a53e			jsr 	ResetCodePointer 			; start of first line.
.b069					_SOFindZero:
.b069	b1 10		lda ($10),y			lda 	(codePtr),y 				; look for trailing $00
.b06b	f0 15		beq $b082			beq 	_SOFoundEnd
.b06d	c8		iny				iny
.b06e	d0 f9		bne $b069			bne 	_SOFindZero
.b070	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b073	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER",0
>b07b	45 43 4f 56 45 52 00
.b082					_SOFoundEnd:
.b082	c8		iny				iny 								; update the offset
.b083	8c 00 11	sty $1100			sty 	ProgramStart
.b086	20 49 a5	jsr $a549			jsr 	ResetForRun 				; redo all stacks etc.
.b089	60		rts				rts
.b08a					System_Sys:
.b08a	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy and drop call address
.b08d	85 14		sta $14				sta 	zTemp0
.b08f	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b092	85 15		sta $15				sta 	zTemp0+1
.b094	ca		dex				dex
.b095	da		phx				phx
.b096	5a		phy				phy
.b097	ad 00 10	lda $1000			lda 	AZVariables+('A'-'A')*4		; load AXY
.b09a	ae 5c 10	ldx $105c			ldx 	AZVariables+('X'-'A')*4
.b09d	ac 60 10	ldy $1060			ldy 	AZVariables+('Y'-'A')*4
.b0a0	20 af b0	jsr $b0af			jsr 	_SSCall 					; effectively jsr (zTemp)
.b0a3	8d 00 10	sta $1000			sta 	AZVariables+('A'-'A')*4 	; store AXY
.b0a6	8e 5c 10	stx $105c			stx 	AZVariables+('X'-'A')*4
.b0a9	8c 60 10	sty $1060			sty 	AZVariables+('Y'-'A')*4
.b0ac	7a		ply				ply
.b0ad	fa		plx				plx
.b0ae	60		rts				rts
.b0af	6c 14 00	jmp ($0014)	_SSCall:jmp 	(zTemp0)
.b0b2					System_ShowStack:
.b0b2	da		phx				phx 								; save stack
.b0b3	5a		phy				phy
.b0b4	86 18		stx $18				stx 	zTemp2 						; save old TOS
.b0b6	a9 5b		lda #$5b			lda 	#"["
.b0b8	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.b0bb	e0 00		cpx #$00			cpx 	#0 							; empty
.b0bd	f0 14		beq $b0d3			beq 	_SSEnd
.b0bf	a2 01		ldx #$01			ldx 	#1 							; start here
.b0c1					_SSLoop:
.b0c1	20 61 a6	jsr $a661			jsr 	IntegerToString 			; print TOS
.b0c4	20 4f a6	jsr $a64f			jsr 	ErrorPrintIntegerBuffer
.b0c7	e4 18		cpx $18				cpx 	zTemp2 						; done TOS exit
.b0c9	f0 08		beq $b0d3			beq 	_SSEnd
.b0cb	e8		inx				inx	 								; advance pointer print ,
.b0cc	a9 2c		lda #$2c			lda 	#','
.b0ce	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.b0d1	80 ee		bra $b0c1			bra 	_SSLoop
.b0d3					_SSEnd:
.b0d3	a9 5d		lda #$5d			lda 	#"]"						; finish off.
.b0d5	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.b0d8	a9 0d		lda #$0d			lda 	#13
.b0da	20 a1 a2	jsr $a2a1			jsr 	ExternPrint
.b0dd	7a		ply				ply
.b0de	fa		plx				plx
.b0df	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/saveload.asm

.b0e0					System_Save:
.b0e0	da		phx				phx
.b0e1	5a		phy				phy
.b0e2	20 6f a5	jsr $a56f			jsr 	ResetVarMemory 				; make sure start/end are right
.b0e5	20 10 b1	jsr $b110			jsr 	SLGetFileName 				; get filename -> zTemp0
.b0e8	ad 88 10	lda $1088			lda 	VarMemory 					; end address
.b0eb	85 16		sta $16				sta 	zTemp1
.b0ed	ad 89 10	lda $1089			lda 	VarMemory+1
.b0f0	85 17		sta $17				sta 	zTemp1+1
.b0f2	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.b0f4	a0 11		ldy #$11			ldy 	#ProgramStart >> 8
.b0f6	20 fd a2	jsr $a2fd			jsr 	ExternSave
.b0f9	7a		ply				ply
.b0fa	fa		plx				plx
.b0fb	4c 3b a0	jmp $a03b			jmp 	WarmStart
.b0fe					System_Load:
.b0fe	5a		phy				phy
.b0ff	20 10 b1	jsr $b110			jsr 	SLGetFileName 				; get filename -> zTemp0
.b102	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.b104	a0 11		ldy #$11			ldy 	#ProgramStart >> 8
.b106	20 33 a3	jsr $a333			jsr 	ExternLoad
.b109	20 49 a5	jsr $a549			jsr 	ResetForRun 				; re-initialise everything
.b10c	7a		ply				ply
.b10d	4c 3b a0	jmp $a03b			jmp 	WarmStart
.b110					SLGetFileName:
.b110	e0 00		cpx #$00			cpx 	#0 							; gotta be something on the stack
.b112	f0 4d		beq $b161			beq 	_SLFNFail
.b114	bd 00 0e	lda $0e00,x			lda 	stack2,x 					; must be a tokenise buffer address
.b117	1d 00 0f	ora $0f00,x			ora 	stack3,x
.b11a	d0 45		bne $b161			bne 	_SLFNFail
.b11c	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b11f	c9 0a		cmp #$0a			cmp 	#TokeniseBuffer >> 8
.b121	d0 3e		bne $b161			bne 	_SLFNFail
.b123	85 17		sta $17				sta 	zTemp1+1 					; copy the filename address to zTemp0/1
.b125	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b128	85 16		sta $16				sta 	zTemp1
.b12a	a9 00		lda #$00			lda 	#InputBuffer & $FF 			; f/n in input buffer.
.b12c	85 14		sta $14				sta 	zTemp0
.b12e	a9 09		lda #$09			lda 	#InputBuffer >> 8
.b130	85 15		sta $15				sta 	zTemp0+1
.b132	da		phx				phx 								; save XY
.b133	5a		phy				phy
.b134	a0 ff		ldy #$ff			ldy 	#255 						; go to the end, copying into input buffer
.b136					_SLCheckEnd:
.b136	c8		iny				iny
.b137	b1 16		lda ($16),y			lda 	(zTemp1),y
.b139	99 00 09	sta $0900,y			sta 	InputBuffer,y
.b13c	d0 f8		bne $b136			bne 	_SLCheckEnd
.b13e	84 18		sty $18				sty 	zTemp2 						; save end position
.b140	a2 03		ldx #$03			ldx 	#3 							; check to see if ends in .RPL
.b142					_SLCheckDotRPL:
.b142	88		dey				dey
.b143	bd 71 b1	lda $b171,x			lda 	_SLEXT,x
.b146	d1 16		cmp ($16),y			cmp 	(zTemp1),y
.b148	d0 05		bne $b14f			bne 	_SLNotMatch
.b14a	ca		dex				dex
.b14b	10 f5		bpl $b142			bpl 	_SLCheckDotRPL
.b14d	80 0f		bra $b15e			bra 	_SLExit 					; yes it does
.b14f					_SLNotMatch:
.b14f	a2 00		ldx #$00			ldx 	#0
.b151	a4 18		ldy $18				ldy 	zTemp2
.b153					_SLAppend:
.b153	bd 71 b1	lda $b171,x			lda 	_SLEXT,x
.b156	91 14		sta ($14),y			sta 	(zTemp0),y
.b158	f0 04		beq $b15e			beq 	_SLExit
.b15a	e8		inx				inx
.b15b	c8		iny				iny
.b15c	80 f5		bra $b153			bra 	_SLAppend
.b15e					_SLExit:
.b15e	7a		ply				ply
.b15f	fa		plx				plx
.b160	60		rts				rts
.b161					_SLFNFail:
.b161	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b164	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>b16c	4e 41 4d 45 00
.b171					_SLEXT:
>b171	2e 52 50 4c 00					.text 	".RPL",0

;******  Return to file: main.asm


;******  Processing file: miscellany/variables.asm

.b176					Identifier:
.b176	88		dey				dey 								; wind back to identifier start
.b177	20 55 a4	jsr $a455			jsr 	IdentifierSearch 			; try to find it.
.b17a	90 2f		bcc $b1ab			bcc 	_IDUnknown 					; not known, give up.
.b17c	48		pha				pha
.b17d					_IDSkip:
.b17d	b1 10		lda ($10),y			lda 	(codePtr),y
.b17f	c8		iny				iny
.b180	c9 e0		cmp #$e0			cmp 	#$E0
.b182	90 f9		bcc $b17d			bcc 	_IDSkip
.b184	68		pla				pla
.b185	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; check a variable
.b187	d0 36		bne $b1bf			bne 	_IDCall
.b189	20 73 b2	jsr $b273			jsr 	IndexCheck 					; check index/subscript
.b18c	5a		phy				phy
.b18d	e8		inx				inx 								; make space on stack
.b18e	a0 00		ldy #$00			ldy 	#0 							; copy it back
.b190	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b192	9d 00 0c	sta $0c00,x			sta 	stack0,x
.b195	c8		iny				iny
.b196	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b198	9d 00 0d	sta $0d00,x			sta 	stack1,x
.b19b	c8		iny				iny
.b19c	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b19e	9d 00 0e	sta $0e00,x			sta 	stack2,x
.b1a1	c8		iny				iny
.b1a2	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b1a4	9d 00 0f	sta $0f00,x			sta 	stack3,x
.b1a7	7a		ply				ply
.b1a8	4c 84 a3	jmp $a384			jmp 	Execute
.b1ab					_IDUnknown:
.b1ab	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b1ae	55 4e 4b 4e 4f 57 4e 20				.text 	"UNKNOWN VARIABLE",0
>b1b6	56 41 52 49 41 42 4c 45 00
.b1bf					_IDCall:
.b1bf	c9 50		cmp #$50			cmp 	#IDT_PROCEDURE
.b1c1	d0 1b		bne $b1de			bne 	_IDCode
.b1c3	20 25 b4	jsr $b425			jsr 	StructPushCurrent 			; push current on the stack.
.b1c6	a9 43		lda #$43			lda 	#STM_CALL 					; push marker
.b1c8	c6 12		dec $12				dec 	StructSP
.b1ca	92 12		sta ($12)			sta 	(StructSP)
.b1cc	a0 01		ldy #$01			ldy 	#1 							; line address
.b1ce	b2 22		lda ($22)			lda 	(idDataAddr)
.b1d0	85 10		sta $10				sta 	codePtr
.b1d2	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b1d4	85 11		sta $11				sta 	codePtr+1
.b1d6	a0 03		ldy #$03			ldy 	#3 							; line position
.b1d8	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b1da	a8		tay				tay
.b1db	4c 84 a3	jmp $a384			jmp 	Execute
.b1de					_IDCode:
.b1de	b2 22		lda ($22)			lda 	(idDataAddr) 				; copy the address
.b1e0	85 14		sta $14				sta 	zTemp0
.b1e2	5a		phy				phy
.b1e3	a0 01		ldy #$01			ldy 	#1
.b1e5	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b1e7	85 15		sta $15				sta 	zTemp0+1
.b1e9	7a		ply				ply
.b1ea	20 f0 b1	jsr $b1f0			jsr 	_IDCallZTemp0 				; call the routine
.b1ed	4c 84 a3	jmp $a384			jmp 	Execute
.b1f0					_IDCallZTemp0:
.b1f0	6c 14 00	jmp ($0014)			jmp 	(zTemp0)
.b1f3					ProcReturn:
.b1f3					ProcReturn2:
.b1f3	b2 12		lda ($12)			lda 	(StructSP)					; check it's CALL
.b1f5	c9 43		cmp #$43			cmp 	#STM_CALL
.b1f7	a0 01		ldy #$01			ldy 	#1 							; restore the position
.b1f9	20 59 b4	jsr $b459			jsr 	StructPopCurrent
.b1fc	a9 05		lda #$05			lda 	#5 							; pop 5 elements off structure stack.
.b1fe	20 1f b4	jsr $b41f			jsr 	StructPopCount
.b201	60		rts				rts
.b202					WriteVariable:
.b202	b1 10		lda ($10),y			lda 	(codePtr),y 				; check variable
.b204	c9 c0		cmp #$c0			cmp 	#$C0
.b206	90 5d		bcc $b265			bcc 	_WVTypeError
.b208	20 55 a4	jsr $a455			jsr 	IdentifierSearch 			; does it exist
.b20b	90 06		bcc $b213			bcc 	_WVNoIdentifier
.b20d	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.b20f	f0 12		beq $b223			beq 	_WVWriteTOS 				; if so write TOS to it.
.b211	80 52		bra $b265			bra 	_WVTypeError 				; not, then can't do anything.
.b213					_WVNoIdentifier:
.b213	5a		phy				phy 								; get current line number
.b214	a0 01		ldy #$01			ldy 	#1
.b216	b1 10		lda ($10),y			lda 	(codePtr),y
.b218	c8		iny				iny
.b219	11 10		ora ($10),y			ora 	(codePtr),y
.b21b	f0 2e		beq $b24b			beq 	_WVCantCreate 				; if zero (command line) no new vars
.b21d	7a		ply				ply
.b21e	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; create identifier
.b220	20 bc a4	jsr $a4bc			jsr 	IdentifierCreate 			; try to find it
.b223					_WVWriteTOS:
.b223	88		dey				dey 								; skip over identifier.
.b224					_WVSkipIdentifier:
.b224	b1 10		lda ($10),y			lda 	(codePtr),y
.b226	c8		iny				iny
.b227	c9 e0		cmp #$e0			cmp 	#$E0
.b229	90 f9		bcc $b224			bcc 	_WVSkipIdentifier
.b22b	20 73 b2	jsr $b273			jsr 	IndexCheck 					; check index/subscript
.b22e	5a		phy				phy									; copy TOS in
.b22f	a0 00		ldy #$00			ldy 	#0
.b231	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b234	91 22		sta ($22),y			sta 	(idDataAddr),y
.b236	c8		iny				iny
.b237	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b23a	91 22		sta ($22),y			sta 	(idDataAddr),y
.b23c	c8		iny				iny
.b23d	bd 00 0e	lda $0e00,x			lda 	stack2,x
.b240	91 22		sta ($22),y			sta 	(idDataAddr),y
.b242	c8		iny				iny
.b243	bd 00 0f	lda $0f00,x			lda 	stack3,x
.b246	91 22		sta ($22),y			sta 	(idDataAddr),y
.b248	7a		ply				ply
.b249	ca		dex				dex 								; drop
.b24a	60		rts				rts									; go back and execute again.
.b24b					_WVCantCreate:
.b24b	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b24e	43 41 4e 4e 4f 54 20 43				.text 	"CANNOT CREATE VARIABLE",0
>b256	52 45 41 54 45 20 56 41 52 49 41 42 4c 45 00
.b265					_WVTypeError:
.b265	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b268	57 52 4f 4e 47 20 54 59				.text 	"WRONG TYPE",0
>b270	50 45 00

;******  Return to file: main.asm


;******  Processing file: miscellany/indexing.asm

.b273					IndexCheck:
.b273	b1 10		lda ($10),y			lda 	(codePtr),y 				; check next character
.b275	c9 4b		cmp #$4b			cmp 	#KWD_LSQPAREN 				; is it [ ?
.b277	d0 10		bne $b289			bne 	_ICExit
.b279	c8		iny				iny
.b27a	b1 10		lda ($10),y			lda 	(codePtr),y 				; next is ] ?
.b27c	c9 4c		cmp #$4c			cmp 	#KWD_RSQPAREN
.b27e	f0 23		beq $b2a3			beq 	_ICArrayAccess
.b280	29 c0		and #$c0			and 	#$C0 						; is it a constant
.b282	c9 80		cmp #$80			cmp 	#$80
.b284	f0 04		beq $b28a			beq 	_ICConstAccess
.b286					_ICSyntax:
.b286	4c d7 a5	jmp $a5d7			jmp 	SyntaxError
.b289					_ICExit:
.b289	60		rts				rts
.b28a					_ICConstAccess:
.b28a	b1 10		lda ($10),y			lda 	(codePtr),y 				; get constant, copy in.
.b28c	29 3f		and #$3f			and 	#$3F 						; to subscript in zTemp1
.b28e	85 16		sta $16				sta 	zTemp1
.b290	64 17		stz $17				stz 	zTemp1+1
.b292	c8		iny				iny
.b293	b1 10		lda ($10),y			lda 	(codePtr),y 				; get next
.b295	c8		iny				iny
.b296	c9 4e		cmp #$4e			cmp 	#KWD_CONSTANT_PLUS 			; ok if K+
.b298	d0 ec		bne $b286			bne 	_ICSyntax
.b29a	b1 10		lda ($10),y			lda 	(codePtr),y 				; get next
.b29c	c8		iny				iny
.b29d	c9 4c		cmp #$4c			cmp 	#KWD_RSQPAREN 				; ok if ]
.b29f	d0 e5		bne $b286			bne 	_ICSyntax
.b2a1	80 0c		bra $b2af			bra 	_ICAddSubscript
.b2a3					_ICArrayAccess:
.b2a3	c8		iny				iny 								; point to next
.b2a4	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy TOS to zTemp1
.b2a7	85 16		sta $16				sta 	zTemp1 						; no point in the rest !
.b2a9	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b2ac	85 17		sta $17				sta 	zTemp1+1
.b2ae	ca		dex				dex
.b2af					_ICAddSubscript:
.b2af	06 16		asl $16				asl 	zTemp1 						; subscript x 4
.b2b1	26 17		rol $17				rol 	zTemp1+1
.b2b3	06 16		asl $16				asl 	zTemp1
.b2b5	26 17		rol $17				rol 	zTemp1+1
.b2b7	5a		phy				phy
.b2b8	b2 22		lda ($22)			lda 	(idDataAddr)				; check indirecting through 0
.b2ba	a0 01		ldy #$01			ldy 	#1
.b2bc	11 22		ora ($22),y			ora 	(idDataAddr),y 				; probably means uninitialised
.b2be	c8		iny				iny
.b2bf	11 22		ora ($22),y			ora 	(idDataAddr),y
.b2c1	c8		iny				iny
.b2c2	11 22		ora ($22),y			ora 	(idDataAddr),y
.b2c4	f0 17		beq $b2dd			beq 	_ICZero
.b2c6	18		clc				clc									; add zTemp1 to value at (idDataAddr)
.b2c7	b2 22		lda ($22)			lda 	(idDataAddr)
.b2c9	65 16		adc $16				adc 	zTemp1
.b2cb	48		pha				pha
.b2cc	a0 01		ldy #$01			ldy 	#1
.b2ce	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b2d0	65 17		adc $17				adc 	zTemp1+1
.b2d2	85 23		sta $23				sta 	idDataAddr+1 				; write it out
.b2d4	68		pla				pla
.b2d5	85 22		sta $22				sta 	idDataAddr
.b2d7	64 24		stz $24				stz 	idDataAddr+2 				; extend to 32 bits
.b2d9	64 25		stz $25				stz 	idDataAddr+3
.b2db	7a		ply				ply
.b2dc	60		rts				rts
.b2dd					_ICZero:
.b2dd	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b2e0	55 4e 49 4e 49 54 49 41				.text 	"UNINITIALISED ARRAY",0
>b2e8	4c 49 53 45 44 20 41 52 52 41 59 00

;******  Return to file: main.asm


;******  Processing file: structures/if.asm

.b2f4					Struct_IF:
.b2f4	ca		dex				dex 								; drop TOS
.b2f5	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check TOS
.b2f8	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.b2fb	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.b2fe	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.b301	f0 01		beq $b304			beq 	_SIFSkipForward
.b303	60		rts				rts
.b304					_SIFSkipForward:
.b304	a9 2c		lda #$2c			lda 	#KWD_ELSE
.b306	4c 0f b3	jmp $b30f			jmp 	StructSkipForward
.b309					Struct_ELSE:
.b309	a9 2e		lda #$2e			lda 	#KWD_ENDIF
.b30b	4c 0f b3	jmp $b30f			jmp 	StructSkipForward
.b30e					Struct_ENDIF:
.b30e	60		rts				rts
.b30f					StructSkipForward:
.b30f	85 14		sta $14				sta 	zTemp0 						; 2nd match
.b311					_SSFLoop:
.b311	b1 10		lda ($10),y			lda 	(codePtr),y 				; read it
.b313	f0 14		beq $b329			beq 	_SSFExit 					; if EOL then exit
.b315	c8		iny				iny 								; advance past it
.b316	c9 2e		cmp #$2e			cmp 	#KWD_ENDIF 					; exit if ENDIF or 2nd match
.b318	f0 0f		beq $b329			beq 	_SSFExit
.b31a	c5 14		cmp $14				cmp 	zTemp0
.b31c	f0 0b		beq $b329			beq 	_SSFExit
.b31e	c9 03		cmp #$03			cmp 	#3 							; if not 1,2 go round again
.b320	b0 ef		bcs $b311			bcs 	_SSFLoop
.b322	98		tya				tya 								; add length offset
.b323	3a		dec a				dec 	a
.b324	71 10		adc ($10),y			adc 	(codePtr),y
.b326	a8		tay				tay
.b327	80 e8		bra $b311			bra 	_SSFLoop
.b329					_SSFExit:
.b329	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: structures/fornext.asm

.b32a					Command_For:
.b32a	20 25 b4	jsr $b425			jsr 	StructPushCurrent 			; push current on the stack.
.b32d	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check zero
.b330	1d 00 0d	ora $0d00,x			ora 	stack1,x
.b333	1d 00 0e	ora $0e00,x			ora 	stack2,x
.b336	1d 00 0f	ora $0f00,x			ora 	stack3,x
.b339	f0 2c		beq $b367			beq 	_CFZero
.b33b	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; push 1's complement of index on
.b33e	49 ff		eor #$ff			eor 	#$FF 						; structure stack.
.b340	c6 12		dec $12				dec 	StructSP
.b342	92 12		sta ($12)			sta 	(StructSP)
.b344	bd 00 0e	lda $0e00,x			lda 	stack2,x
.b347	49 ff		eor #$ff			eor 	#$FF
.b349	c6 12		dec $12				dec 	StructSP
.b34b	92 12		sta ($12)			sta 	(StructSP)
.b34d	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b350	49 ff		eor #$ff			eor 	#$FF
.b352	c6 12		dec $12				dec 	StructSP
.b354	92 12		sta ($12)			sta 	(StructSP)
.b356	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b359	49 ff		eor #$ff			eor 	#$FF
.b35b	c6 12		dec $12				dec 	StructSP
.b35d	92 12		sta ($12)			sta 	(StructSP)
.b35f	ca		dex				dex 								; pop stack value
.b360	a9 46		lda #$46			lda 	#STM_FOR 					; push FOR marker
.b362	c6 12		dec $12				dec 	StructSP
.b364	92 12		sta ($12)			sta 	(StructSP)
.b366	60		rts				rts
.b367					_CFZero:
.b367	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b36a	46 4f 52 20 43 4f 55 4e				.text 	"FOR COUNT ZERO",0
>b372	54 20 5a 45 52 4f 00
.b379					Command_Next:
.b379	b2 12		lda ($12)			lda 	(StructSP)					; check it's FOR.
.b37b	c9 46		cmp #$46			cmp 	#STM_FOR
.b37d	d0 28		bne $b3a7			bne 	CNNoFor
.b37f	5a		phy				phy
.b380	a0 00		ldy #$00			ldy 	#0
.b382					_CNIncrement:
.b382	c8		iny				iny
.b383	b1 12		lda ($12),y			lda 	(StructSP),y 				; increment the index
.b385	1a		inc a				inc 	a
.b386	91 12		sta ($12),y			sta 	(StructSP),y
.b388	f0 f8		beq $b382			beq		_CNIncrement 				; carry out.
.b38a	a0 01		ldy #$01			ldy 	#1 							; now and all the counts together
.b38c	b1 12		lda ($12),y			lda 	(StructSP),y 				; on the last time round they
.b38e	c8		iny				iny 								; will all be $FF
.b38f	31 12		and ($12),y			and 	(StructSP),y
.b391	c8		iny				iny
.b392	31 12		and ($12),y			and 	(StructSP),y
.b394	c8		iny				iny
.b395	31 12		and ($12),y			and 	(StructSP),y
.b397	7a		ply				ply 								; restore Y
.b398	1a		inc a				inc 	a 							; so this will be zero last time round
.b399	d0 06		bne $b3a1			bne 	_CNLoop 					; loop back if non-zero
.b39b	a9 09		lda #$09			lda 	#9 							; pop 9 elements off structure stack.
.b39d	20 1f b4	jsr $b41f			jsr 	StructPopCount
.b3a0	60		rts				rts
.b3a1					_CNLoop:
.b3a1	a0 05		ldy #$05			ldy 	#5 							; restore the position
.b3a3	20 59 b4	jsr $b459			jsr 	StructPopCurrent
.b3a6	60		rts				rts
.b3a7					CNNoFor:
.b3a7	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b3aa	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>b3b2	46 4f 52 00
.b3b6					Command_Index:
.b3b6	b2 12		lda ($12)			lda 	(StructSP)					; check it's FOR.
.b3b8	c9 46		cmp #$46			cmp 	#STM_FOR
.b3ba	d0 eb		bne $b3a7			bne 	CNNoFor
.b3bc	5a		phy				phy
.b3bd	a0 01		ldy #$01			ldy 	#1 							; get the stack position of
.b3bf	e8		inx				inx
.b3c0	38		sec				sec
.b3c1	a9 fe		lda #$fe			lda 	#$FE
.b3c3	f1 12		sbc ($12),y			sbc 	(StructSP),y
.b3c5	9d 00 0c	sta $0c00,x			sta 	stack0,x
.b3c8	c8		iny				iny
.b3c9	a9 ff		lda #$ff			lda 	#$FF
.b3cb	f1 12		sbc ($12),y			sbc 	(StructSP),y
.b3cd	9d 00 0d	sta $0d00,x			sta 	stack1,x
.b3d0	c8		iny				iny
.b3d1	a9 ff		lda #$ff			lda 	#$FF
.b3d3	f1 12		sbc ($12),y			sbc 	(StructSP),y
.b3d5	9d 00 0e	sta $0e00,x			sta 	stack2,x
.b3d8	c8		iny				iny
.b3d9	a9 ff		lda #$ff			lda 	#$FF
.b3db	f1 12		sbc ($12),y			sbc 	(StructSP),y
.b3dd	9d 00 0f	sta $0f00,x			sta 	stack3,x
.b3e0	7a		ply				ply
.b3e1	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: structures/repeat.asm

.b3e2					Command_Repeat:
.b3e2	20 25 b4	jsr $b425			jsr 	StructPushCurrent 			; push current on the stack.
.b3e5	a9 52		lda #$52			lda 	#STM_REPEAT 				; push marker
.b3e7	c6 12		dec $12				dec 	StructSP
.b3e9	92 12		sta ($12)			sta 	(StructSP)
.b3eb	60		rts				rts
.b3ec					Command_Until:
.b3ec	b2 12		lda ($12)			lda 	(StructSP)					; check it's REPEAT
.b3ee	c9 52		cmp #$52			cmp 	#STM_REPEAT
.b3f0	d0 1b		bne $b40d			bne 	_CUNoRepeat
.b3f2	ca		dex				dex 								; pop
.b3f3	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check old TOS zero
.b3f6	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.b3f9	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.b3fc	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.b3ff	f0 06		beq $b407			beq 	_CULoop
.b401	a9 05		lda #$05			lda 	#5 							; pop 5 elements off structure stack.
.b403	20 1f b4	jsr $b41f			jsr 	StructPopCount
.b406	60		rts				rts
.b407					_CULoop:
.b407	a0 01		ldy #$01			ldy 	#1 							; restore the position
.b409	20 59 b4	jsr $b459			jsr 	StructPopCurrent
.b40c	60		rts				rts
.b40d					_CUNoRepeat:
.b40d	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b410	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>b418	52 45 50 45 41 54 00

;******  Return to file: main.asm


;******  Processing file: structures/structures.asm

.b41f					StructPopCount:
.b41f	18		clc				clc
.b420	65 12		adc $12				adc 	StructSP
.b422	85 12		sta $12				sta 	StructSP
.b424	60		rts				rts
.b425					StructPushCurrent:
.b425	a5 12		lda $12				lda 	StructSP 					; check space for more
.b427	c9 0a		cmp #$0a			cmp 	#10
.b429	90 18		bcc $b443			bcc 	_SPCSpace
.b42b	a9 00		lda #$00			lda 	#0							; push bank
.b42d	c6 12		dec $12				dec 	StructSP
.b42f	92 12		sta ($12)			sta 	(StructSP)
.b431	98		tya				tya									; y Offset
.b432	c6 12		dec $12				dec 	StructSP
.b434	92 12		sta ($12)			sta 	(StructSP)
.b436	a5 11		lda $11				lda 	codePtr+1 					; codeptr high
.b438	c6 12		dec $12				dec 	StructSP
.b43a	92 12		sta ($12)			sta 	(StructSP)
.b43c	a5 10		lda $10				lda 	codePtr 					; codeptr low
.b43e	c6 12		dec $12				dec 	StructSP
.b440	92 12		sta ($12)			sta 	(StructSP)
.b442	60		rts				rts
.b443					_SPCSpace:
.b443	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b446	52 45 54 55 52 4e 20 53				.text 	"RETURN STACK SPACE",0
>b44e	54 41 43 4b 20 53 50 41 43 45 00
.b459					StructPopCurrent:
.b459	b1 12		lda ($12),y			lda 	(StructSP),y 				; codeptr low
.b45b	85 10		sta $10				sta 	codePtr
.b45d	c8		iny				iny
.b45e	b1 12		lda ($12),y			lda 	(StructSP),y 				; codeptr high
.b460	85 11		sta $11				sta 	codePtr+1
.b462	c8		iny				iny
.b463	b1 12		lda ($12),y			lda 	(StructSP),y				; y offset
.b465	a8		tay				tay
.b466	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/hashes.inc

.b467					libfunc_1000:
>b467	00 00					.word 0
>b469	ff b5 00 00				.dword IO_Clear
>b46d	71 b4					.word libfunc_1000_name
>b46f	00 43					.byte 0,'C'
.b471					libfunc_1000_name:
>b471	c2 cb f2				.byte $c2,$cb,$f2
.b474					libfunc_1001:
>b474	67 b4					.word libfunc_1000
>b476	93 b6 00 00				.dword Vera_Sprite
>b47a	7e b4					.word libfunc_1001_name
>b47c	00 43					.byte 0,'C'
.b47e					libfunc_1001_name:
>b47e	d5 c4 d1 c0 df f2			.byte $d5,$c4,$d1,$c0,$df,$f2
.b484					libfunc_1002:
>b484	00 00					.word 0
>b486	92 b5 00 00				.dword System_Random
>b48a	8e b4					.word libfunc_1002_name
>b48c	00 43					.byte 0,'C'
.b48e					libfunc_1002_name:
>b48e	d1 cd e3				.byte $d1,$cd,$e3
.b491					libfunc_1003:
>b491	84 b4					.word libfunc_1002
>b493	04 b6 00 00				.dword IO_Emit
>b497	9b b4					.word libfunc_1003_name
>b499	00 43					.byte 0,'C'
.b49b					libfunc_1003_name:
>b49b	c4 cc c8 f3				.byte $c4,$cc,$c8,$f3
.b49f					libfunc_1004:
>b49f	91 b4					.word libfunc_1003
>b4a1	3e b6 00 00				.dword Vera_SetAddress
>b4a5	a9 b4					.word libfunc_1004_name
>b4a7	00 43					.byte 0,'C'
.b4a9					libfunc_1004_name:
>b4a9	d5 c4 d1 c0 df d2 c4 f3			.byte $d5,$c4,$d1,$c0,$df,$d2,$c4,$f3
.b4b1					libfunc_1005:
>b4b1	9f b4					.word libfunc_1004
>b4b3	58 b6 00 00				.dword Vera_GetAddress
>b4b7	bb b4					.word libfunc_1005_name
>b4b9	00 43					.byte 0,'C'
.b4bb					libfunc_1005_name:
>b4bb	d5 c4 d1 c0 df c6 c4 f3			.byte $d5,$c4,$d1,$c0,$df,$c6,$c4,$f3
.b4c3					libfunc_1006:
>b4c3	b1 b4					.word libfunc_1005
>b4c5	4d b7 00 00				.dword Vera_Load
>b4c9	cd b4					.word libfunc_1006_name
>b4cb	00 43					.byte 0,'C'
.b4cd					libfunc_1006_name:
>b4cd	d5 c4 d1 c0 df cb ce c0			.byte $d5,$c4,$d1,$c0,$df,$cb,$ce,$c0,$e3
>b4d5	e3
.b4d6					libfunc_1007:
>b4d6	00 00					.word 0
>b4d8	6f b6 00 00				.dword Vera_SetPalette
>b4dc	e0 b4					.word libfunc_1007_name
>b4de	00 43					.byte 0,'C'
.b4e0					libfunc_1007_name:
>b4e0	d5 c4 d1 c0 df cf c0 cb			.byte $d5,$c4,$d1,$c0,$df,$cf,$c0,$cb,$c4,$d3,$d3,$e4
>b4e8	c4 d3 d3 e4
.b4ec					libfunc_1008:
>b4ec	d6 b4					.word libfunc_1007
>b4ee	bd b6 00 00				.dword Vera_SpriteMove
>b4f2	f6 b4					.word libfunc_1008_name
>b4f4	00 43					.byte 0,'C'
.b4f6					libfunc_1008_name:
>b4f6	d5 c4 d1 c0 df d2 df cc			.byte $d5,$c4,$d1,$c0,$df,$d2,$df,$cc,$ce,$d5,$e4
>b4fe	ce d5 e4
.b501					libfunc_1009:
>b501	ec b4					.word libfunc_1008
>b503	05 b7 00 00				.dword Vera_SetSize
>b507	0b b5					.word libfunc_1009_name
>b509	00 43					.byte 0,'C'
.b50b					libfunc_1009_name:
>b50b	d5 c4 d1 c0 df d2 df d2			.byte $d5,$c4,$d1,$c0,$df,$d2,$df,$d2,$c8,$d9,$e4
>b513	c8 d9 e4
.b516					libfunc_1010:
>b516	00 00					.word 0
>b518	a1 b6 00 00				.dword Vera_SpriteDisable
>b51c	20 b5					.word libfunc_1010_name
>b51e	00 43					.byte 0,'C'
.b520					libfunc_1010_name:
>b520	d5 c4 d1 c0 df d2 df ce			.byte $d5,$c4,$d1,$c0,$df,$d2,$df,$ce,$c5,$e5
>b528	c5 e5
.b52a					libfunc_1011:
>b52a	00 00					.word 0
>b52c	23 b7 00 00				.dword Vera_ByteW
>b530	34 b5					.word libfunc_1011_name
>b532	00 43					.byte 0,'C'
.b534					libfunc_1011_name:
>b534	d5 c4 d1 c0 df f6			.byte $d5,$c4,$d1,$c0,$df,$f6
.b53a					libfunc_1012:
>b53a	00 00					.word 0
>b53c	d5 b6 00 00				.dword Vera_SpriteSetup
>b540	44 b5					.word libfunc_1012_name
>b542	00 43					.byte 0,'C'
.b544					libfunc_1012_name:
>b544	d5 c4 d1 c0 df d2 df c6			.byte $d5,$c4,$d1,$c0,$df,$d2,$df,$c6,$c5,$f7
>b54c	c5 f7
.b54e					libfunc_1013:
>b54e	00 00					.word 0
>b550	0b b6 00 00				.dword String_Len
>b554	58 b5					.word libfunc_1013_name
>b556	00 43					.byte 0,'C'
.b558					libfunc_1013_name:
>b558	d2 d3 d1 df cb c4 ed			.byte $d2,$d3,$d1,$df,$cb,$c4,$ed
.b55f					libfunc_1014:
>b55f	4e b5					.word libfunc_1013
>b561	9d b6 00 00				.dword Vera_SpriteEnable
>b565	69 b5					.word libfunc_1014_name
>b567	00 43					.byte 0,'C'
.b569					libfunc_1014_name:
>b569	d5 c4 d1 c0 df d2 df ce			.byte $d5,$c4,$d1,$c0,$df,$d2,$df,$ce,$ed
>b571	ed
.b572					DefaultHashTable:
>b572	00 00					.word 0
>b574	00 00					.word 0
>b576	74 b4					.word libfunc_1001
>b578	c3 b4					.word libfunc_1006
>b57a	01 b5					.word libfunc_1009
>b57c	16 b5					.word libfunc_1010
>b57e	2a b5					.word libfunc_1011
>b580	3a b5					.word libfunc_1012
>b582	00 00					.word 0
>b584	00 00					.word 0
>b586	00 00					.word 0
>b588	00 00					.word 0
>b58a	00 00					.word 0
>b58c	5f b5					.word libfunc_1014
>b58e	00 00					.word 0
>b590	00 00					.word 0

;******  Return to file: main.asm


;******  Processing file: generated/library.inc

.0826					RandomSeed:
>0826							.dword 		?
.b592					System_Random:
.b592	ad 26 08	lda $0826		lda 	RandomSeed
.b595	0d 27 08	ora $0827		ora 	RandomSeed+1
.b598	0d 28 08	ora $0828		ora 	RandomSeed+2
.b59b	0d 29 08	ora $0829		ora 	RandomSeed+3
.b59e	d0 09		bne $b5a9		bne 	_SRSeeded
.b5a0	ee 27 08	inc $0827		inc 	RandomSeed+1
.b5a3	ce 29 08	dec $0829		dec 	RandomSeed+3
.b5a6	20 92 b5	jsr $b592		jsr 	System_Random
.b5a9					_SRSeeded:
.b5a9	5a		phy			phy
.b5aa	ac 28 08	ldy $0828		ldy RandomSeed+2 ; will move to RandomSeed+3 at the end
.b5ad	ad 27 08	lda $0827		lda RandomSeed+1
.b5b0	8d 28 08	sta $0828		sta RandomSeed+2
.b5b3	ad 29 08	lda $0829		lda RandomSeed+3 ; original high byte
.b5b6	4a		lsr a			lsr
.b5b7	8d 27 08	sta $0827		sta RandomSeed+1 ; reverse: 100011
.b5ba	4a		lsr a			lsr
.b5bb	4a		lsr a			lsr
.b5bc	4a		lsr a			lsr
.b5bd	4a		lsr a			lsr
.b5be	4d 27 08	eor $0827		eor RandomSeed+1
.b5c1	4a		lsr a			lsr
.b5c2	4d 27 08	eor $0827		eor RandomSeed+1
.b5c5	4d 26 08	eor $0826		eor RandomSeed+0 ; combine with original low byte
.b5c8	8d 27 08	sta $0827		sta RandomSeed+1
.b5cb	ad 29 08	lda $0829		lda RandomSeed+3 ; original high byte
.b5ce	0a		asl a			asl
.b5cf	4d 29 08	eor $0829		eor RandomSeed+3
.b5d2	0a		asl a			asl
.b5d3	0a		asl a			asl
.b5d4	0a		asl a			asl
.b5d5	0a		asl a			asl
.b5d6	4d 29 08	eor $0829		eor RandomSeed+3
.b5d9	0a		asl a			asl
.b5da	0a		asl a			asl
.b5db	4d 29 08	eor $0829		eor RandomSeed+3
.b5de	8c 29 08	sty $0829		sty RandomSeed+3 ; finish rotating byte 2 into 3
.b5e1	8d 26 08	sta $0826		sta RandomSeed+0
.b5e4	e8		inx			inx
.b5e5	ad 26 08	lda $0826		lda	RandomSeed+0
.b5e8	9d 00 0c	sta $0c00,x		sta stack0,x
.b5eb	ad 27 08	lda $0827		lda	RandomSeed+1
.b5ee	9d 00 0d	sta $0d00,x		sta stack1,x
.b5f1	ad 28 08	lda $0828		lda	RandomSeed+2
.b5f4	9d 00 0e	sta $0e00,x		sta stack2,x
.b5f7	ad 29 08	lda $0829		lda	RandomSeed+3
.b5fa	9d 00 0f	sta $0f00,x		sta stack3,x
.b5fd	7a		ply			ply
.b5fe	60		rts			rts
.b5ff					IO_Clear:
.b5ff	a9 93		lda #$93		lda 	#SCM_CLS
.b601	4c a1 a2	jmp $a2a1		jmp 	ExternPrint
.b604					IO_Emit:
.b604	bd 00 0c	lda $0c00,x		lda 	stack0,x
.b607	ca		dex			dex
.b608	4c a1 a2	jmp $a2a1		jmp 	ExternPrint
.b60b					String_Len:
.b60b	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy string address
.b60e	85 14		sta $14				sta 	zTemp0
.b610	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b613	85 15		sta $15				sta 	zTemp0+1
.b615	5a		phy				phy
.b616	a0 ff		ldy #$ff			ldy 	#255 						; find string length
.b618	c8		iny		_SLLoop:iny
.b619	c0 ff		cpy #$ff			cpy 	#255 						; cant find EOS.
.b61b	f0 13		beq $b630			beq 	_SLFail
.b61d	b1 14		lda ($14),y			lda 	(zTemp0),y
.b61f	d0 f7		bne $b618			bne 	_SLLoop
.b621	98		tya				tya
.b622	7a		ply				ply
.b623	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; return string
.b626	9e 00 0d	stz $0d00,x			stz 	stack1,x
.b629	9e 00 0e	stz $0e00,x			stz 	stack2,x
.b62c	9e 00 0f	stz $0f00,x			stz 	stack3,x
.b62f	60		rts				rts
.b630					_SLFail:
.b630	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b633	4e 4f 54 20 53 54 52 49				.text 	"NOT STRING",0
>b63b	4e 47 00
=$9f20					Vera_Base = $9F20
.082a					veraCurrentLayer:
>082a							.byte 		? 						; current layer (0-1)
.082b					veraCurrentSprite:
>082b							.byte 		?						; current sprite (0-127)
.082c					veraSpriteMode:
>082c							.byte 		? 						; 0 4 bit, 1 8 bit
.b63e					Vera_SetAddress:
.b63e	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b641	8d 20 9f	sta $9f20			sta 	Vera_Base
.b644	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b647	8d 21 9f	sta $9f21			sta 	Vera_Base+1
.b64a	bd 00 0e	lda $0e00,x			lda 	stack2,x
.b64d	c9 10		cmp #$10			cmp 	#16
.b64f	b0 02		bcs $b653			bcs 	_VSASetInc
.b651	09 10		ora #$10			ora 	#16
.b653					_VSASetInc:
.b653	8d 22 9f	sta $9f22			sta 	Vera_Base+2
.b656	ca		dex				dex
.b657	60		rts				rts
.b658					Vera_GetAddress:
.b658	e8		inx				inx
.b659	ad 20 9f	lda $9f20			lda 	Vera_Base
.b65c	9d 00 0c	sta $0c00,x			sta 	stack0,x
.b65f	ad 21 9f	lda $9f21			lda 	Vera_Base+1
.b662	9d 00 0d	sta $0d00,x			sta 	stack1,x
.b665	ad 22 9f	lda $9f22			lda 	Vera_Base+2
.b668	9d 00 0e	sta $0e00,x			sta 	stack2,x
.b66b	9e 00 0f	stz $0f00,x			stz 	stack3,x
.b66e	60		rts				rts
.b66f					Vera_SetPalette:
.b66f	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b672	8d 20 9f	sta $9f20			sta 	Vera_Base
.b675	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b678	29 01		and #$01			and 	#$01
.b67a	09 10		ora #$10			ora 	#$10
.b67c	8d 21 9f	sta $9f21			sta 	Vera_Base+1
.b67f	a9 1f		lda #$1f			lda 	#$1F
.b681	8d 22 9f	sta $9f22			sta 	Vera_Base+2
.b684	ca		dex				dex
.b685	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b688	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b68b	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b68e	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b691	ca		dex				dex
.b692	60		rts				rts
.b693					Vera_Sprite:
.b693	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b696	29 7f		and #$7f			and 	#$7F
.b698	8d 2b 08	sta $082b			sta 	veraCurrentSprite
.b69b	ca		dex				dex
.b69c	60		rts				rts
.b69d					Vera_SpriteEnable:
.b69d	a9 01		lda #$01			lda 	#1
.b69f	80 02		bra $b6a3			bra 	Vera_SpriteControl
.b6a1					Vera_SpriteDisable:
.b6a1	a9 00		lda #$00			lda 	#0
.b6a3					Vera_SpriteControl:
.b6a3	48		pha				pha
.b6a4	a9 00		lda #$00			lda 	#$00
.b6a6	8d 20 9f	sta $9f20			sta 	Vera_Base
.b6a9	a9 40		lda #$40			lda 	#$40
.b6ab	8d 21 9f	sta $9f21			sta 	Vera_Base+1
.b6ae	a9 1f		lda #$1f			lda 	#$1F
.b6b0	8d 22 9f	sta $9f22			sta 	Vera_Base+2
.b6b3	68		pla				pla
.b6b4	29 01		and #$01			and 	#1
.b6b6	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b6b9	9c 23 9f	stz $9f23			stz 	Vera_Base+3
.b6bc	60		rts				rts
.b6bd					Vera_SpriteMove:
.b6bd	a9 02		lda #$02			lda 	#2 							; physical position
.b6bf	20 2b b7	jsr $b72b			jsr 	Vera_CurrentSprite
.b6c2	20 c5 b6	jsr $b6c5			jsr 	_VSMOutPosition
.b6c5					_VSMOutPosition:
.b6c5	ca		dex				dex
.b6c6	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.b6c9	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b6cc	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.b6cf	29 03		and #$03			and 	#$03
.b6d1	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b6d4	60		rts				rts
.b6d5					Vera_SpriteSetup:
.b6d5	a9 00		lda #$00			lda 	#0
.b6d7	20 2b b7	jsr $b72b			jsr 	Vera_CurrentSprite
.b6da	ca		dex				dex
.b6db	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.b6de	85 14		sta $14				sta 	zTemp0
.b6e0	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.b6e3	85 15		sta $15				sta 	zTemp0+1
.b6e5	bd 01 0e	lda $0e01,x			lda 	stack2+1,x
.b6e8	85 16		sta $16				sta 	zTemp1
.b6ea	5a		phy				phy
.b6eb	a0 05		ldy #$05			ldy 	#5
.b6ed	46 16		lsr $16		_VSSS:	lsr 	zTemp1
.b6ef	66 15		ror $15				ror 	zTemp0+1
.b6f1	66 14		ror $14				ror 	zTemp0
.b6f3	88		dey				dey
.b6f4	d0 f7		bne $b6ed			bne 	_VSSS
.b6f6	7a		ply				ply
.b6f7	a5 14		lda $14				lda 	zTemp0
.b6f9	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b6fc	a5 15		lda $15				lda 	zTemp0+1
.b6fe	0d 2c 08	ora $082c			ora 	veraSpriteMode
.b701	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b704	60		rts				rts
.b705					Vera_SetSize:
.b705	a9 06		lda #$06			lda 	#6
.b707	20 2b b7	jsr $b72b			jsr 	Vera_CurrentSprite
.b70a	a9 1c		lda #$1c			lda 	#$1C
.b70c	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b70f	ca		dex				dex
.b710	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.b713	29 03		and #$03			and 	#3
.b715	85 14		sta $14				sta 	zTemp0
.b717	0a		asl a				asl 	a
.b718	0a		asl a				asl 	a
.b719	05 14		ora $14				ora 	zTemp0
.b71b	0a		asl a				asl 	a
.b71c	0a		asl a				asl 	a
.b71d	0a		asl a				asl 	a
.b71e	0a		asl a				asl 	a
.b71f	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b722	60		rts				rts
.b723					Vera_ByteW:
.b723	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b726	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b729	ca		dex				dex
.b72a	60		rts				rts
.b72b					Vera_CurrentSprite:
.b72b	48		pha				pha 								; save offset
.b72c	ad 2b 08	lda $082b			lda 	veraCurrentSprite 			; address in zTemp0
.b72f	0a		asl a				asl 	a
.b730	85 14		sta $14				sta 	zTemp0		 				; sprite# x 2
.b732	64 15		stz $15				stz 	zTemp0+1
.b734	06 14		asl $14				asl 	zTemp0 						; x 8
.b736	26 15		rol $15				rol 	zTemp0+1
.b738	06 14		asl $14				asl 	zTemp0
.b73a	68		pla				pla 								; fix up address
.b73b	05 14		ora $14				ora 	zTemp0
.b73d	8d 20 9f	sta $9f20			sta  	Vera_Base+0
.b740	a5 15		lda $15				lda 	zTemp0+1
.b742	09 50		ora #$50			ora 	#$50
.b744	8d 21 9f	sta $9f21			sta 	Vera_Base+1
.b747	a9 1f		lda #$1f			lda 	#$1F
.b749	8d 22 9f	sta $9f22			sta 	Vera_Base+2
.b74c	60		rts				rts
.b74d					Vera_Load:
.b74d	da		phx				phx
.b74e	5a		phy				phy
.b74f	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; filename in XY
.b752	85 14		sta $14				sta 	zTemp0
.b754	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b757	85 15		sta $15				sta 	zTemp0+1
.b759	a2 00		ldx #$00			ldx 	#0
.b75b	bd 84 b7	lda $b784,x	_VLCopy:lda 	_VLCopiableCode,x
.b75e	9d 00 09	sta $0900,x			sta 	InputBuffer,x
.b761	e8		inx				inx
.b762	e0 42		cpx #$42			cpx 	#_VLCopiableEnd-_VLCopiableCode
.b764	d0 f5		bne $b75b			bne 	_VLCopy
.b766	20 65 a3	jsr $a365			jsr 	EXGetLength 				; get file name length -> A
.b769	20 00 09	jsr $0900			jsr 	InputBuffer
.b76c	b0 04		bcs $b772			bcs 	_VLError
.b76e	7a		ply				ply
.b76f	fa		plx				plx
.b770	ca		dex				dex 								; drop tos
.b771	60		rts				rts
.b772					_VLError:
.b772	20 f8 a5	jsr $a5f8			jsr 	ErrorHandler
>b775	56 45 52 41 20 4c 4f 41				.text 	"VERA LOAD FAIL",0
>b77d	44 20 46 41 49 4c 00
.b784					_VLCopiableCode:
.b784	aa		tax				tax 								; length in X
.b785	ad 61 9f	lda $9f61			lda 	$9F61 						; save current bank
.b788	48		pha				pha
.b789	a9 fe		lda #$fe			lda 	#254 						; switch to useable buffer
.b78b	8d 61 9f	sta $9f61			sta 	$9F61
.b78e	8a		txa				txa
.b78f	a6 14		ldx $14				ldx 	zTemp0
.b791	a4 15		ldy $15				ldy 	zTemp0+1
.b793	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.b796	a9 01		lda #$01			lda 	#1
.b798	a2 01		ldx #$01			ldx 	#1	 						; device #1
.b79a	a0 00		ldy #$00			ldy 	#0
.b79c	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.b79f	a0 a0		ldy #$a0			ldy 	#$A0 						; restore target to YX and call load
.b7a1	a9 00		lda #$00			lda 	#$00
.b7a3	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.b7a6	b0 19		bcs $b7c1			bcs 	_VLExit
.b7a8	a9 a0		lda #$a0			lda 	#$A0 						; send it all to VERA
.b7aa	85 15		sta $15				sta 	zTemp0+1
.b7ac	64 14		stz $14				stz 	zTemp0
.b7ae	a0 00		ldy #$00			ldy 	#0
.b7b0					_VLSendVera:
.b7b0	b1 14		lda ($14),y			lda 	(zTemp0),y
.b7b2	8d 23 9f	sta $9f23			sta 	$9F23
.b7b5	c8		iny				iny
.b7b6	d0 f8		bne $b7b0			bne 	_VLSendVera
.b7b8	e6 15		inc $15				inc 	zTemp0+1
.b7ba	a5 15		lda $15				lda 	zTemp0+1
.b7bc	c9 c0		cmp #$c0			cmp 	#$C0
.b7be	d0 f0		bne $b7b0			bne 	_VLSendVera
.b7c0	18		clc				clc
.b7c1					_VLExit:
.b7c1	68		pla				pla 								; restore original bank
.b7c2	8d 61 9f	sta $9f61			sta 	$9F61
.b7c5	60		rts				rts
.b7c6					_VLCopiableEnd:

;******  Return to file: main.asm


;******  Processing file: generated/testcode.inc

>1100	15 64 00 02 11 20 74 65			.byte $15,$64,$00,$02,$11,$20,$74,$65,$73,$74,$20,$70,$72,$6f,$67,$72,$61,$6d,$20,$00,$00,$14,$6e,$00,$01,$07,$44,$45,$4d,$4f,$00,$d5,$c4,$d1,$c0,$df,$cb,$ce,$c0,$e3,$00,$06,$78,$00,$16,$2d,$00
>1108	73 74 20 70 72 6f 67 72 61 6d 20 00 00 14 6e 00
>1118	01 07 44 45 4d 4f 00 d5 c4 d1 c0 df cb ce c0 e3
>1128	00 06 78 00 16 2d 00

;******  Return to file: main.asm

>112f	00						.byte 	0

;******  End of listing
