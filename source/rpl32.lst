
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl32.prg -L rpl32.lst main.asm
; Fri Oct  4 21:02:48 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; build the interpreter here
=$0c00					StackAddress = $0C00 						; 1k of stack space (256 x 32 bits)
=$1000					MemoryStart = $1000 						; system memory starts here
=$6000					MemoryEnd = $6000 							; and ends here.
=$0bff					StructureStack = $0BFF 						; structure stack (works down to $xx00)
=16					HashTableSize = 16 							; hash tables to search.
>0000					CodePtr: 		.word ? 					; code pointer
>0002					StructSP: 		.word ?						; structure stack pointer
>0004					zTemp0:			.word ?						; temporary words
>0006					zTemp1: 		.word ?
>0008					zTemp2: 		.word ?
>000a					zLTemp1:		.dword ?					; temporary longs
>000e					breakCount:		.byte ? 					; used to stop break firing every execution.
>000f					idDataAddr:		.word ? 					; data address.
>0011					SignCount:		.byte ?						; sign count for divide
>0012					ForAddr:		.byte ? 					; points to current FOR structure
>1000					AZVariables:	.fill	26*4 				; 26 x 4 byte variables, which are A-Z
>1068					HashTable: 		.fill 	HashTableSize * 2 	; n x 2 links for the hash tables.
>1088	00 00				VarMemory:		.word 	0 					; next free byte available for VARIABLES (going up)
>108a	00 00				AllocMemory: 	.word 	0 					; last free byte availabel for ALLOC (going down)
>108c	00				CurrentBase:	.byte 	0 					; base used for printing and tokenising constants.
=4352					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0c00					stack0 = StackAddress
=3328					stack1 = StackAddress+256
=3584					stack2 = StackAddress+512
=3840					stack3 = StackAddress+768
="V"					IDT_VARIABLE = 'V'							; type markers for the information store.
="P"					IDT_PROCEDURE = 'P'							; standard procedure (e.g. in code)
="C"					IDT_CODEPROC = 'C'							; machine language procedure.
="F"					STM_FOR = 'F'								; structure markers (for/next)
="C"					STM_CALL = 'C'								; call & return  (& ;)
="R"					STM_REPEAT = 'R'							; repeat & until

;******  Return to file: main.asm


;******  Processing file: macro.asm


;******  Return to file: main.asm

.0f00	4c 00 a0	jmp $a000			jmp 	Start
.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	a9 0a		lda #$0a			lda 	#10 						; reset the base
.a005	8d 8c 10	sta $108c			sta 	CurrentBase
.a008	20 ff a2	jsr $a2ff			jsr 	ResetForRun
.a00b	20 f4 a2	jsr $a2f4			jsr 	ResetCodePointer
.a00e	4c 0f a8	jmp $a80f			jmp 	System_RUN

;******  Processing file: generated/tables.inc

.a011					KeywordText:
>a011	01 20					.byte $01,$20                          ; $10
>a013	01 21					.byte $01,$21                          ; $11 !
>a015	01 26					.byte $01,$26                          ; $12 &
>a017	01 2a					.byte $01,$2a                          ; $13 *
>a019	01 2b					.byte $01,$2b                          ; $14 +
>a01b	02 2b 2b				.byte $02,$2b,$2b                      ; $15 ++
>a01e	01 2d					.byte $01,$2d                          ; $16 -
>a020	02 2d 2d				.byte $02,$2d,$2d                      ; $17 --
>a023	01 2f					.byte $01,$2f                          ; $18 /
>a025	01 3b					.byte $01,$3b                          ; $19 ;
>a027	01 3c					.byte $01,$3c                          ; $1a <
>a029	02 3c 3c				.byte $02,$3c,$3c                      ; $1b <<
>a02c	02 3c 3d				.byte $02,$3c,$3d                      ; $1c <=
>a02f	02 3c 3e				.byte $02,$3c,$3e                      ; $1d <>
>a032	01 3d					.byte $01,$3d                          ; $1e =
>a034	01 3e					.byte $01,$3e                          ; $1f >
>a036	02 3e 3d				.byte $02,$3e,$3d                      ; $20 >=
>a039	02 3e 3e				.byte $02,$3e,$3e                      ; $21 >>
>a03c	01 00					.byte $01,$00                          ; $22 @
>a03e	03 01 02 13				.byte $03,$01,$02,$13                  ; $23 ABS
>a042	05 01 0c 0c 0f 03			.byte $05,$01,$0c,$0c,$0f,$03          ; $24 ALLOC
>a048	03 01 0e 04				.byte $03,$01,$0e,$04                  ; $25 AND
>a04c	02 03 21				.byte $02,$03,$21                      ; $26 C!
>a04f	02 03 00				.byte $02,$03,$00                      ; $27 C@
>a052	03 04 05 06				.byte $03,$04,$05,$06                  ; $28 DEF
>a056	04 04 12 0f 10				.byte $04,$04,$12,$0f,$10              ; $29 DROP
>a05b	03 04 15 10				.byte $03,$04,$15,$10                  ; $2a DUP
>a05f	04 05 0c 13 05				.byte $04,$05,$0c,$13,$05              ; $2b ELSE
>a064	05 05 0d 10 14 19			.byte $05,$05,$0d,$10,$14,$19          ; $2c EMPTY
>a06a	03 05 0e 04				.byte $03,$05,$0e,$04                  ; $2d END
>a06e	03 06 0f 12				.byte $03,$06,$0f,$12                  ; $2e FOR
>a072	02 09 06				.byte $02,$09,$06                      ; $2f IF
>a075	05 09 0e 04 05 18			.byte $05,$09,$0e,$04,$05,$18          ; $30 INDEX
>a07b	04 0c 09 13 14				.byte $04,$0c,$09,$13,$14              ; $31 LIST
>a080	03 0d 0f 04				.byte $03,$0d,$0f,$04                  ; $32 MOD
>a084	06 0e 05 07 01 14 05			.byte $06,$0e,$05,$07,$01,$14,$05      ; $33 NEGATE
>a08b	03 0e 05 17				.byte $03,$0e,$05,$17                  ; $34 NEW
>a08f	04 0e 05 18 14				.byte $04,$0e,$05,$18,$14              ; $35 NEXT
>a094	03 0e 09 10				.byte $03,$0e,$09,$10                  ; $36 NIP
>a098	03 0e 0f 14				.byte $03,$0e,$0f,$14                  ; $37 NOT
>a09c	03 0f 0c 04				.byte $03,$0f,$0c,$04                  ; $38 OLD
>a0a0	02 0f 12				.byte $02,$0f,$12                      ; $39 OR
>a0a3	04 0f 16 05 12				.byte $04,$0f,$16,$05,$12              ; $3a OVER
>a0a8	06 12 05 10 05 01 14			.byte $06,$12,$05,$10,$05,$01,$14      ; $3b REPEAT
>a0af	03 12 15 0e				.byte $03,$12,$15,$0e                  ; $3c RUN
>a0b3	04 13 14 0f 10				.byte $04,$13,$14,$0f,$10              ; $3d STOP
>a0b8	04 13 17 01 10				.byte $04,$13,$17,$01,$10              ; $3e SWAP
>a0bd	03 13 19 13				.byte $03,$13,$19,$13                  ; $3f SYS
>a0c1	04 14 08 05 0e				.byte $04,$14,$08,$05,$0e              ; $40 THEN
>a0c6	05 15 0e 14 09 0c			.byte $05,$15,$0e,$14,$09,$0c          ; $41 UNTIL
>a0cc	02 17 21				.byte $02,$17,$21                      ; $42 W!
>a0cf	02 17 00				.byte $02,$17,$00                      ; $43 W@
>a0d2	03 18 0f 12				.byte $03,$18,$0f,$12                  ; $44 XOR
>a0d6	02 1b 1d				.byte $02,$1b,$1d                      ; $45 []
>a0d9	01 1e					.byte $01,$1e                          ; $46 ^
>a0db	01 2d					.byte $01,$2d                          ; $47 {-}
>a0dd	00					.byte $00
.a0de					KeywordVectorTable:
>a0de	af a9					.word SyntaxError                      ; $10
>a0e0	a5 a5					.word Mem_DPoke                        ; $11 !
>a0e2	af a9					.word SyntaxError                      ; $12 &
>a0e4	8c a6					.word MulInteger32                     ; $13 *
>a0e6	cc a5					.word Stack_Add                        ; $14 +
>a0e8	cc a4					.word Unary_Increment                  ; $15 ++
>a0ea	f3 a5					.word Stack_Sub                        ; $16 -
>a0ec	df a4					.word Unary_Decrement                  ; $17 --
>a0ee	d5 a6					.word DivInteger32                     ; $18 /
>a0f0	af a9					.word SyntaxError                      ; $19 ;
>a0f2	b9 a7					.word Comp_Less                        ; $1a <
>a0f4	01 a5					.word Unary_Shl                        ; $1b <<
>a0f6	e4 a7					.word Comp_LessEqual                   ; $1c <=
>a0f8	82 a7					.word Comp_NotEqual                    ; $1d <>
>a0fa	7f a7					.word Comp_Equal                       ; $1e =
>a0fc	e7 a7					.word Comp_Greater                     ; $1f >
>a0fe	bc a7					.word Comp_GreaterEqual                ; $20 >=
>a100	0e a5					.word Unary_Shr                        ; $21 >>
>a102	53 a5					.word Mem_DPeek                        ; $22 @
>a104	83 a4					.word Unary_Absolute                   ; $23 ABS
>a106	af a9					.word SyntaxError                      ; $24 ALLOC
>a108	1a a6					.word Stack_And                        ; $25 AND
>a10a	78 a5					.word Mem_Poke                         ; $26 C!
>a10c	1b a5					.word Mem_Peek                         ; $27 C@
>a10e	af a9					.word SyntaxError                      ; $28 DEF
>a110	f8 a3					.word Stack_Drop                       ; $29 DROP
>a112	fa a3					.word Stack_Dup                        ; $2a DUP
>a114	af a9					.word SyntaxError                      ; $2b ELSE
>a116	f5 a3					.word Stack_Empty                      ; $2c EMPTY
>a118	18 a8					.word System_END                       ; $2d END
>a11a	e7 a8					.word Command_For                      ; $2e FOR
>a11c	af a9					.word SyntaxError                      ; $2f IF
>a11e	af a9					.word SyntaxError                      ; $30 INDEX
>a120	af a9					.word SyntaxError                      ; $31 LIST
>a122	67 a7					.word ModInteger32                     ; $32 MOD
>a124	89 a4					.word Unary_Negate                     ; $33 NEGATE
>a126	27 a8					.word System_New                       ; $34 NEW
>a128	3e a9					.word Command_Next                     ; $35 NEXT
>a12a	14 a4					.word Stack_Nip                        ; $36 NIP
>a12c	ab a4					.word Unary_Not                        ; $37 NOT
>a12e	af a9					.word SyntaxError                      ; $38 OLD
>a130	66 a6					.word Stack_Or                         ; $39 OR
>a132	2e a4					.word Stack_Over                       ; $3a OVER
>a134	af a9					.word SyntaxError                      ; $3b REPEAT
>a136	0f a8					.word System_RUN                       ; $3c RUN
>a138	1c a8					.word System_STOP                      ; $3d STOP
>a13a	48 a4					.word Stack_Swap                       ; $3e SWAP
>a13c	af a9					.word SyntaxError                      ; $3f SYS
>a13e	af a9					.word SyntaxError                      ; $40 THEN
>a140	af a9					.word SyntaxError                      ; $41 UNTIL
>a142	8a a5					.word Mem_WPoke                        ; $42 W!
>a144	34 a5					.word Mem_WPeek                        ; $43 W@
>a146	40 a6					.word Stack_Xor                        ; $44 XOR
>a148	af a9					.word SyntaxError                      ; $45 []
>a14a	88 a8					.word WriteVariable                    ; $46 ^
>a14c	89 a4					.word Unary_Const_Minus                ; $47 {-}
=$10					KWD_SPACE = $10                  ; $10
=$11					KWD_PLING = $11                  ; $11 !
=$12					KWD_AMPERSAND = $12              ; $12 &
=$13					KWD_ASTERISK = $13               ; $13 *
=$14					KWD_PLUS = $14                   ; $14 +
=$15					KWD_PLUSPLUS = $15               ; $15 ++
=$16					KWD_MINUS = $16                  ; $16 -
=$17					KWD_MINUSMINUS = $17             ; $17 --
=$18					KWD_SLASH = $18                  ; $18 /
=$19					KWD_SEMICOLON = $19              ; $19 ;
=$1a					KWD_LESS = $1a                   ; $1a <
=$1b					KWD_LESSLESS = $1b               ; $1b <<
=$1c					KWD_LESSEQUAL = $1c              ; $1c <=
=$1d					KWD_LESSGREATER = $1d            ; $1d <>
=$1e					KWD_EQUAL = $1e                  ; $1e =
=$1f					KWD_GREATER = $1f                ; $1f >
=$20					KWD_GREATEREQUAL = $20           ; $20 >=
=$21					KWD_GREATERGREATER = $21         ; $21 >>
=$22					KWD_AT = $22                     ; $22 @
=$23					KWD_ABS = $23                    ; $23 ABS
=$24					KWD_ALLOC = $24                  ; $24 ALLOC
=$25					KWD_AND = $25                    ; $25 AND
=$26					KWD_CPLING = $26                 ; $26 C!
=$27					KWD_CAT = $27                    ; $27 C@
=$28					KWD_DEF = $28                    ; $28 DEF
=$29					KWD_DROP = $29                   ; $29 DROP
=$2a					KWD_DUP = $2a                    ; $2a DUP
=$2b					KWD_ELSE = $2b                   ; $2b ELSE
=$2c					KWD_EMPTY = $2c                  ; $2c EMPTY
=$2d					KWD_END = $2d                    ; $2d END
=$2e					KWD_FOR = $2e                    ; $2e FOR
=$2f					KWD_IF = $2f                     ; $2f IF
=$30					KWD_INDEX = $30                  ; $30 INDEX
=$31					KWD_LIST = $31                   ; $31 LIST
=$32					KWD_MOD = $32                    ; $32 MOD
=$33					KWD_NEGATE = $33                 ; $33 NEGATE
=$34					KWD_NEW = $34                    ; $34 NEW
=$35					KWD_NEXT = $35                   ; $35 NEXT
=$36					KWD_NIP = $36                    ; $36 NIP
=$37					KWD_NOT = $37                    ; $37 NOT
=$38					KWD_OLD = $38                    ; $38 OLD
=$39					KWD_OR = $39                     ; $39 OR
=$3a					KWD_OVER = $3a                   ; $3a OVER
=$3b					KWD_REPEAT = $3b                 ; $3b REPEAT
=$3c					KWD_RUN = $3c                    ; $3c RUN
=$3d					KWD_STOP = $3d                   ; $3d STOP
=$3e					KWD_SWAP = $3e                   ; $3e SWAP
=$3f					KWD_SYS = $3f                    ; $3f SYS
=$40					KWD_THEN = $40                   ; $40 THEN
=$41					KWD_UNTIL = $41                  ; $41 UNTIL
=$42					KWD_WPLING = $42                 ; $42 W!
=$43					KWD_WAT = $43                    ; $43 W@
=$44					KWD_XOR = $44                    ; $44 XOR
=$45					KWD_LSQPARENRSQPAREN = $45       ; $45 []
=$46					KWD_HAT = $46                    ; $46 ^
=$47					KWD_CONSTANT_MINUS = $47         ; $47 {-}

;******  Return to file: main.asm


;******  Processing file: system/extern.asm

.a14e					ExternCheckBreak:
.a14e	da		phx				phx 								; make sure we keep XY
.a14f	5a		phy				phy
.a150	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a153	f0 03		beq $a158			beq		_ECBExit 					; stopped
.a155	7a		ply				ply 								; restore and exit.
.a156	fa		plx				plx
.a157	60		rts				rts
.a158					_ECBExit:
.a158	4c b2 a9	jmp $a9b2			jmp 	WarmStart

;******  Return to file: main.asm


;******  Processing file: system/execute.asm

.a15b					EXNextLine:
.a15b	b2 00		lda ($00)			lda 	(codePtr) 					; is it run from the buffer (offset 0)
.a15d	f0 0f		beq $a16e			beq 	_EXNLWarmStart
.a15f	18		clc				clc 								; advance code pointer to next line
.a160	65 00		adc $00				adc 	codePtr
.a162	85 00		sta $00				sta 	codePtr
.a164	90 02		bcc $a168			bcc 	_EXNLNoBump
.a166	e6 00		inc $00				inc 	codePtr
.a168					_EXNLNoBump:
.a168	a0 03		ldy #$03			ldy 	#3 							; position in that line
.a16a	b2 00		lda ($00)			lda 	(codePtr) 					; read offset
.a16c	d0 03		bne $a171			bne 	Execute 					; not end of program
.a16e					_EXNLWarmStart:
.a16e	4c 18 a8	jmp $a818			jmp 	System_END
.a171					Execute:
.a171	e6 0e		inc $0e				inc 	BreakCount 					; break occasionally. too slow otherwise.
.a173	d0 03		bne $a178			bne 	_EXNoBreak
.a175	20 4e a1	jsr $a14e			jsr 	ExternCheckBreak
.a178					_EXNoBreak:
.a178					_EXGetNext:
.a178	b1 00		lda ($00),y			lda 	(codePtr),y 				; load the character
.a17a	f0 df		beq $a15b			beq 	EXNextLine 					; reached end of the line.
.a17c	c8		iny				iny 								; advance pointer.
.a17d	c9 10		cmp #$10			cmp 	#KWD_SPACE 					; skip spaces
.a17f	f0 f7		beq $a178			beq 	_ExGetNext
.a181	c9 10		cmp #$10			cmp 	#$10 						; is it 01-0F, which means a string/comment ?
.a183	90 65		bcc $a1ea			bcc 	EXStringComment
.a185	c9 80		cmp #$80			cmp 	#$80 						; if it 10-7F, token
.a187	90 4b		bcc $a1d4			bcc 	EXTokenExecute
.a189	c9 c0		cmp #$c0			cmp 	#$C0 						; is it a numeric constant 80-BF
.a18b	90 03		bcc $a190			bcc 	EXPushConstant
.a18d	4c 2e a8	jmp $a82e			jmp 	Identifier 					; it's an identifier C0-FF
.a190					EXPushConstant:
.a190	e8		inx				inx 								; make stack space
.a191	29 3f		and #$3f			and 	#$3F 						; to start with, it's just that value
.a193	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a196	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a199	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a19c	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a19f					_EXConstantLoop:
.a19f	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next ?
.a1a1	29 c0		and #$c0			and 	#$C0 						; in range 80-FF e.g. 10xx xxxx
.a1a3	c9 80		cmp #$80			cmp 	#$80
.a1a5	d0 ca		bne $a171			bne		Execute 					; no do the next.
.a1a7	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; put the MSB in A
.a1aa	48		pha				pha
.a1ab	bd 00 0e	lda $0e00,x			lda 	stack2,x 					; shift every byte up one, e.g. x 256
.a1ae	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a1b1	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a1b4	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a1b7	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a1ba	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a1bd	9e 00 0c	stz $0c00,x			stz 	stack0,x
.a1c0	68		pla				pla
.a1c1	20 0c a2	jsr $a20c			jsr 	EXShiftTOSRight 				; shift the whole A:Top of Stack right twice
.a1c4	20 0c a2	jsr $a20c			jsr 	EXShiftTOSRight				; which will be x64
.a1c7	b1 00		lda ($00),y			lda 	(codePtr),y 				; get and skip constant shift
.a1c9	c8		iny				iny
.a1ca	29 3f		and #$3f			and 	#$3F
.a1cc	1d 00 0c	ora $0c00,x			ora 	stack0,x 					; or into low byte
.a1cf	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a1d2	80 cb		bra $a19f			bra 	_EXConstantLoop
.a1d4					EXTokenExecute:
.a1d4	0a		asl a				asl 	a 							; double token, also clears carry
.a1d5	da		phx				phx 								; save X, put token x 2 in X
.a1d6	aa		tax				tax
.a1d7	bd be a0	lda $a0be,x			lda 	KeywordVectorTable-$20,x 	; copy vector. The -$20 is because the tokens
.a1da	85 04		sta $04				sta 	zTemp0 						; start at $10.
.a1dc	bd bf a0	lda $a0bf,x			lda 	KeywordVectorTable-$20+1,x
.a1df	85 05		sta $05				sta 	zTemp0+1
.a1e1	fa		plx				plx 								; restore X
.a1e2	20 e7 a1	jsr $a1e7			jsr 	_EXTCall 					; call the routine
.a1e5	80 8a		bra $a171			bra 	Execute
.a1e7					_EXTCall:
.a1e7	6c 04 00	jmp ($0004)			jmp 	(zTemp0)
.a1ea					EXStringComment:
.a1ea	c9 02		cmp #$02			cmp 	#$02 						; 02 is the token for single quoted string
.a1ec	f0 15		beq $a203			beq 	EXStringSkip 				; (comment), so just skip it.
.a1ee	e8		inx				inx 								; push Y + 1 + codePtr on the stack
.a1ef	98		tya				tya
.a1f0	38		sec				sec
.a1f1	65 00		adc $00				adc 	codePtr
.a1f3	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a1f6	a5 01		lda $01				lda 	codePtr+1
.a1f8	69 00		adc #$00			adc 	#0
.a1fa	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a1fd	9e 00 0e	stz $0e00,x			stz 	stack2,x 					; clear the upper 2 bytes.
.a200	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a203					EXStringSkip:
.a203	98		tya				tya 								; the current position in A
.a204	18		clc				clc
.a205	71 00		adc ($00),y			adc 	(codePtr),y					; add the total length
.a207	a8		tay				tay 			 					; and make that the current position.
.a208	88		dey				dey 								; back one because of the initial skip
.a209	4c 71 a1	jmp $a171			jmp 	Execute
.a20c					EXShiftTOSRight:
.a20c	4a		lsr a				lsr 	a
.a20d	7e 00 0f	ror $0f00,x			ror 	stack3,x
.a210	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a213	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a216	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a219	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/identifier.asm

.a21a					IdentifierSearch:
.a21a	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.a21c	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a fast var ?
.a21e	90 12		bcc $a232			bcc 	_ISSlow
.a220	c9 fa		cmp #$fa			cmp 	#$F9+1
.a222	b0 0e		bcs $a232			bcs 	_ISSlow
.a224	29 1f		and #$1f			and 	#$1F 						; index, then x 4
.a226	0a		asl a				asl 	a
.a227	0a		asl a				asl		a
.a228	85 0f		sta $0f				sta 	idDataAddr					; set up addres
.a22a	a9 10		lda #$10			lda 	#AZVariables >> 8
.a22c	85 10		sta $10				sta 	idDataAddr+1
.a22e	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; type
.a230	38		sec				sec 								; return with CS.
.a231	60		rts				rts
.a232					_ISSlow:
.a232	20 e6 a2	jsr $a2e6			jsr 	IdentifierSetupHashPtr 		; set up hash table.
.a235	98		tya				tya 								; set (zTemp1) to point to the
.a236	18		clc				clc 	 							; identifier to be searched.
.a237	65 00		adc $00				adc 	codePtr
.a239	85 06		sta $06				sta 	zTemp1
.a23b	a5 01		lda $01				lda 	codePtr+1
.a23d	69 00		adc #$00			adc 	#0
.a23f	85 07		sta $07				sta 	zTemp1+1
.a241	5a		phy				phy 								; save Y
.a242	b2 04		lda ($04)	_ISLoop:lda 	(zTemp0)					; follow link
.a244	48		pha				pha
.a245	a0 01		ldy #$01			ldy 	#1
.a247	b1 04		lda ($04),y			lda 	(zTemp0),y
.a249	85 05		sta $05				sta 	zTemp0+1
.a24b	68		pla				pla
.a24c	85 04		sta $04				sta 	zTemp0
.a24e	05 05		ora $05				ora 	zTemp0+1 					; if zero, then fail.
.a250	f0 2c		beq $a27e			beq 	_ISFail
.a252	a0 06		ldy #$06			ldy 	#6 							; copy name into zTemp2
.a254	b1 04		lda ($04),y			lda 	(zTemp0),y
.a256	85 08		sta $08				sta 	zTemp2
.a258	c8		iny				iny
.a259	b1 04		lda ($04),y			lda 	(zTemp0),y
.a25b	85 09		sta $09				sta 	zTemp2+1
.a25d	a0 00		ldy #$00			ldy 	#0 							; compare names at zTemp1/zTemp2
.a25f					_ISCompare:
.a25f	b1 06		lda ($06),y			lda 	(zTemp1),y
.a261	d1 08		cmp ($08),y			cmp 	(zTemp2),y
.a263	d0 dd		bne $a242			bne		_ISLoop 					; different ?
.a265	c8		iny				iny
.a266	c9 e0		cmp #$e0			cmp 	#$E0 						; until end identifiers matched.
.a268	90 f5		bcc $a25f			bcc 	_ISCompare
.a26a	18		clc				clc 								; set up the data pointer
.a26b	a5 04		lda $04				lda 	zTemp0
.a26d	69 02		adc #$02			adc 	#2
.a26f	85 0f		sta $0f				sta 	idDataAddr
.a271	a5 05		lda $05				lda 	zTemp0+1
.a273	69 00		adc #$00			adc		#0
.a275	85 10		sta $10				sta 	idDataAddr+1
.a277	a0 09		ldy #$09			ldy 	#9 							; get the type
.a279	b1 04		lda ($04),y			lda 	(zTemp0),y
.a27b	7a		ply				ply
.a27c	38		sec				sec
.a27d	60		rts				rts
.a27e					_ISFail:
.a27e	7a		ply				ply
.a27f	18		clc				clc
.a280	60		rts				rts
.a281					IdentifierCreate:
.a281	5a		phy				phy 								; save Y
.a282	48		pha				pha 								; save type on stack
.a283	20 e6 a2	jsr $a2e6			jsr 	IdentifierSetUpHashPtr 		; zTemp0 = address of table.
.a286	ad 88 10	lda $1088			lda 	VarMemory 					; copy VarMemory to zTemp1
.a289	85 06		sta $06				sta 	zTemp1
.a28b	ad 89 10	lda $1089			lda 	VarMemory+1
.a28e	85 07		sta $07				sta 	zTemp1+1
.a290	5a		phy				phy 								; save Y (code offset)
.a291	a0 00		ldy #$00			ldy 	#0 							; copy next link in.
.a293	b1 04		lda ($04),y			lda 	(zTemp0),y 					; +0,+1 is the link.
.a295	91 06		sta ($06),y			sta 	(zTemp1),y
.a297	c8		iny				iny
.a298	b1 04		lda ($04),y			lda 	(zTemp0),y
.a29a	91 06		sta ($06),y			sta 	(zTemp1),y
.a29c	c8		iny				iny
.a29d					_IDCErase:
.a29d	a9 00		lda #$00			lda 	#0
.a29f	91 06		sta ($06),y			sta 	(zTemp1),y
.a2a1	c8		iny				iny
.a2a2	c0 06		cpy #$06			cpy 	#6
.a2a4	d0 f7		bne $a29d			bne 	_IDCErase
.a2a6	68		pla				pla 								; original Y
.a2a7	18		clc				clc
.a2a8	65 00		adc $00				adc		codePtr 					; address of identifier +6,+7
.a2aa	91 06		sta ($06),y			sta 	(zTemp1),y
.a2ac	c8		iny				iny
.a2ad	a5 01		lda $01				lda 	codePtr+1
.a2af	69 00		adc #$00			adc 	#0
.a2b1	91 06		sta ($06),y			sta 	(zTemp1),y
.a2b3	c8		iny				iny
.a2b4	a9 00		lda #$00			lda 	#0 							; +8 bank (0)
.a2b6	91 06		sta ($06),y			sta 	(zTemp1),y
.a2b8	68		pla				pla 								; restore type
.a2b9	c8		iny				iny
.a2ba	91 06		sta ($06),y			sta 	(zTemp1),y 					; store at +9
.a2bc	c8		iny				iny
.a2bd	98		tya				tya									; add offset to VarMemory
.a2be	18		clc				clc
.a2bf	6d 88 10	adc $1088			adc 	VarMemory
.a2c2	8d 88 10	sta $1088			sta 	VarMemory
.a2c5	ad 89 10	lda $1089			lda 	VarMemory+1
.a2c8	69 00		adc #$00			adc 	#0
.a2ca	8d 89 10	sta $1089			sta 	VarMemory+1
.a2cd	a5 06		lda $06				lda 	zTemp1 						; overwrite hash table entry
.a2cf	92 04		sta ($04)			sta 	(zTemp0)
.a2d1	a0 01		ldy #$01			ldy 	#1
.a2d3	a5 07		lda $07				lda 	zTemp1+1
.a2d5	91 04		sta ($04),y			sta 	(zTemp0),y
.a2d7	a5 06		lda $06				lda 	zTemp1 						; set up idDataAddr
.a2d9	18		clc				clc
.a2da	69 02		adc #$02			adc 	#2
.a2dc	85 0f		sta $0f				sta 	idDataAddr
.a2de	a5 07		lda $07				lda 	zTemp1+1
.a2e0	69 00		adc #$00			adc 	#0
.a2e2	85 10		sta $10				sta 	idDataAddr+1
.a2e4	7a		ply				ply 								; restore Y and exit
.a2e5	60		rts				rts
.a2e6					IdentifierSetUpHashPtr:
.a2e6	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first operator
.a2e8	29 0f		and #$0f			and 	#(HashTableSize-1)			; convert to a hash index
.a2ea	0a		asl a				asl 	a 							; convert to an offset, clc
.a2eb	69 68		adc #$68			adc 	#(HashTable & $FF)			; set zTemp0 to point to hashTable entry
.a2ed	85 04		sta $04				sta 	zTemp0
.a2ef	a9 10		lda #$10			lda 	#(HashTable >> 8) 			; assumes table in one page
.a2f1	85 05		sta $05				sta 	zTemp0+1
.a2f3	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/reset.asm

.a2f4					ResetCodePointer:
.a2f4	48		pha				pha
.a2f5	a9 11		lda #$11			lda 	#ProgramStart >> 8 			; set up line pointer
.a2f7	85 01		sta $01				sta 	codePtr+1
.a2f9	64 00		stz $00				stz 	codePtr
.a2fb	a0 03		ldy #$03			ldy 	#3 							; point to first piece of code
.a2fd	68		pla				pla
.a2fe	60		rts				rts
.a2ff					ResetForRun:
.a2ff	48		pha				pha
.a300	5a		phy				phy
.a301	a2 00		ldx #$00			ldx 	#0 							; erase the hash table
.a303					_RRErase:
.a303	9e 68 10	stz $1068,x			stz		HashTable,x
.a306	e8		inx				inx
.a307	e0 20		cpx #$20			cpx 	#HashTableSize * 2
.a309	d0 f8		bne $a303			bne 	_RRErase
.a30b	20 f4 a2	jsr $a2f4			jsr 	ResetCodePointer 			; code Pointer to start of program
.a30e					_RRFindEnd:
.a30e	b2 00		lda ($00)			lda 	(codePtr)					; at end ?
.a310	f0 0b		beq $a31d			beq 	_RRFoundEnd
.a312	18		clc				clc 								; no, add offset to pointer.
.a313	65 00		adc $00				adc 	codePtr
.a315	85 00		sta $00				sta 	codePtr
.a317	90 f5		bcc $a30e			bcc 	_RRFindEnd
.a319	e6 01		inc $01				inc 	codePtr+1
.a31b	80 f1		bra $a30e			bra 	_RRFindEnd
.a31d					_RRFoundEnd:
.a31d	18		clc				clc 								; add 1 to this, as it points to the last
.a31e	a5 00		lda $00				lda 	codePtr 					; offset, and store in Variable Memory pointer
.a320	69 01		adc #$01			adc 	#1
.a322	8d 88 10	sta $1088			sta 	VarMemory
.a325	a5 01		lda $01				lda 	codePtr+1
.a327	69 00		adc #$00			adc 	#0
.a329	8d 89 10	sta $1089			sta 	VarMemory+1
.a32c	a9 60		lda #$60			lda 	#MemoryEnd >> 8
.a32e	8d 8b 10	sta $108b			sta 	AllocMemory+1
.a331	9c 8a 10	stz $108a			stz 	AllocMemory
.a334	a9 ff		lda #$ff			lda 	#StructureStack & $FF
.a336	85 02		sta $02				sta 	StructSP
.a338	a9 0b		lda #$0b			lda 	#StructureStack >> 8
.a33a	85 03		sta $03				sta 	StructSP+1
.a33c	a9 ff		lda #$ff			lda 	#$FF 						; put a value that will fail structure tests
.a33e	92 02		sta ($02)			sta 	(StructSP)
.a340	20 48 a3	jsr $a348			jsr 	ProcedureScan
.a343	a2 00		ldx #$00			ldx 	#0 							; empty the stack
.a345	7a		ply				ply
.a346	68		pla				pla
.a347	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/scan.asm

.a348					ProcedureScan:
.a348	20 f4 a2	jsr $a2f4			jsr 	ResetCodePointer 			; reset the code pointer.
.a34b	b2 00		lda ($00)	_PSMain:lda 	(codePtr)					; check if end
.a34d	f0 3c		beq $a38b			beq 	_PSExit
.a34f	a0 03		ldy #$03			ldy 	#3 							; start of line
.a351					_PSSkipSpace:
.a351	b1 00		lda ($00),y			lda 	(codePtr),y 				; skip over spaces
.a353	c8		iny				iny
.a354	c9 10		cmp #$10			cmp 	#KWD_SPACE
.a356	f0 f9		beq $a351			beq 	_PSSkipSpace
.a358	c9 28		cmp #$28			cmp 	#KWD_DEF 					; first thing is DEF ?
.a35a	d0 22		bne $a37e			bne 	_PSNext
.a35c					_PSSkipSpace2:
.a35c	c8		iny				iny 								; skip over def first, any following spaces
.a35d	b1 00		lda ($00),y			lda 	(codePtr),y
.a35f	c9 10		cmp #$10			cmp 	#KWD_SPACE
.a361	f0 f9		beq $a35c			beq 	_PSSkipSpace2
.a363	a9 50		lda #$50			lda 	#IDT_PROCEDURE 				; create a procedure
.a365	20 81 a2	jsr $a281			jsr 	IdentifierCreate
.a368					_PSSkipIdentifier:
.a368	b1 00		lda ($00),y			lda 	(codePtr),y
.a36a	c8		iny				iny
.a36b	c9 c0		cmp #$c0			cmp 	#$C0
.a36d	b0 f9		bcs $a368			bcs 	_PSSkipIdentifier
.a36f	88		dey				dey 								; undo last, points at first non ID
.a370	98		tya				tya  								; save the address in the data slot.
.a371	18		clc				clc 								; changing Y doesn't matter.
.a372	65 00		adc $00				adc 	codePtr
.a374	92 0f		sta ($0f)			sta 	(idDataAddr)
.a376	a5 01		lda $01				lda 	codePtr+1
.a378	69 00		adc #$00			adc 	#0
.a37a	a0 01		ldy #$01			ldy 	#1
.a37c	91 0f		sta ($0f),y			sta 	(idDataAddr),y
.a37e					_PSNext:
.a37e	18		clc				clc 								; go to next
.a37f	b2 00		lda ($00)			lda 	(codePtr)
.a381	65 00		adc $00				adc 	codePtr
.a383	85 00		sta $00				sta 	codeptr
.a385	90 c4		bcc $a34b			bcc 	_PSMain
.a387	e6 01		inc $01				inc 	codePtr+1
.a389	80 c0		bra $a34b			bra 	_PSMain
.a38b					_PSExit:
.a38b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/indexing.asm

.a38c					IndexCheck:
.a38c	b1 00		lda ($00),y			lda 	(codePtr),y 				; check next character
.a38e	c9 45		cmp #$45			cmp 	#KWD_LSQPARENRSQPAREN 		; left/right square bracket ?
.a390	f0 12		beq $a3a4			beq 	_ICArrayAccess
.a392	29 c0		and #$c0			and 	#$C0 						; constant (e.g. 10xx xxxx)
.a394	c9 80		cmp #$80			cmp 	#$80
.a396	b0 01		bcs $a399			bcs 	_ICSubscript
.a398					_ICExit:
.a398	60		rts				rts
.a399					_ICSubscript:
.a399	b1 00		lda ($00),y			lda 	(codePtr),y
.a39b	c8		iny				iny 								; skip over subscript
.a39c	29 3f		and #$3f			and 	#$3F 						; lower 6 bits only.
.a39e	85 06		sta $06				sta 	zTemp1 						; save in zTemp1
.a3a0	64 07		stz $07				stz 	zTemp1+1
.a3a2	80 0c		bra $a3b0			bra 	_ICAddSubscript 			; double and add to value.
.a3a4					_ICArrayAccess:
.a3a4	c8		iny				iny 								; point to next
.a3a5	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy TOS to zTemp1
.a3a8	85 07		sta $07				sta 	zTemp1+1 					; no point in the rest !
.a3aa	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a3ad	85 06		sta $06				sta 	zTemp1
.a3af	ca		dex				dex
.a3b0					_ICAddSubscript:
.a3b0	06 06		asl $06				asl 	zTemp1 						; subscript x 4
.a3b2	26 07		rol $07				rol 	zTemp1+1
.a3b4	06 06		asl $06				asl 	zTemp1
.a3b6	26 07		rol $07				rol 	zTemp1+1
.a3b8	5a		phy				phy
.a3b9	b2 0f		lda ($0f)			lda 	(idDataAddr)				; check indirecting through 0
.a3bb	a0 01		ldy #$01			ldy 	#1
.a3bd	11 0f		ora ($0f),y			ora 	(idDataAddr),y 				; probably means uninitialised
.a3bf	c8		iny				iny
.a3c0	11 0f		ora ($0f),y			ora 	(idDataAddr),y
.a3c2	c8		iny				iny
.a3c3	11 0f		ora ($0f),y			ora 	(idDataAddr),y
.a3c5	f0 17		beq $a3de			beq 	_ICZero
.a3c7	18		clc				clc									; add zTemp1 to value at (idDataAddr)
.a3c8	b2 0f		lda ($0f)			lda 	(idDataAddr)
.a3ca	65 06		adc $06				adc 	zTemp1
.a3cc	48		pha				pha
.a3cd	a0 01		ldy #$01			ldy 	#1
.a3cf	b1 0f		lda ($0f),y			lda 	(idDataAddr),y
.a3d1	65 07		adc $07				adc 	zTemp1+1
.a3d3	85 10		sta $10				sta 	idDataAddr+1 				; write it out
.a3d5	68		pla				pla
.a3d6	85 0f		sta $0f				sta 	idDataAddr
.a3d8	64 11		stz $11				stz 	idDataAddr+2 				; extend to 32 bits
.a3da	64 12		stz $12				stz 	idDataAddr+3
.a3dc	7a		ply				ply
.a3dd	60		rts				rts
.a3de					_ICZero:
.a3de	20 b5 a9	jsr $a9b5			jsr 	ErrorHandler
>a3e1	55 6e 69 6e 69 74 69 61				.text 	"Uninitialised array",0
>a3e9	6c 69 73 65 64 20 61 72 72 61 79 00

;******  Return to file: main.asm


;******  Processing file: functions/stack.asm

.a3f5					Stack_Empty:
.a3f5	a2 00		ldx #$00			ldx 	#0
.a3f7	60		rts				rts
.a3f8					Stack_Drop:
.a3f8	ca		dex				dex
.a3f9	60		rts				rts
.a3fa					Stack_Dup:
.a3fa	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy to next up
.a3fd	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.a400	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a403	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.a406	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a409	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.a40c	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a40f	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.a412	e8		inx				inx 								; bump stack pointer
.a413	60		rts				rts
.a414					Stack_Nip:
.a414	bd 00 0c	lda $0c00,x			lda 	stack0,x	 				; copy top to 2nd
.a417	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.a41a	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a41d	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.a420	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a423	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.a426	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a429	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.a42c	ca		dex				dex 								; drop tos
.a42d	60		rts				rts
.a42e					Stack_Over:
.a42e	bd ff 0b	lda $0bff,x			lda 	stack0-1,x				; copy to next up
.a431	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.a434	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a437	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.a43a	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a43d	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.a440	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a443	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.a446	e8		inx				inx 							; bump stack pointer
.a447	60		rts				rts
.a448					Stack_Swap:
.a448	5a		phy				phy
.a449	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a44c	a8		tay				tay
.a44d	bd ff 0b	lda $0bff,x			lda 	stack0-1,x
.a450	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a453	98		tya				tya
.a454	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.a457	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a45a	a8		tay				tay
.a45b	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a45e	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a461	98		tya				tya
.a462	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.a465	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a468	a8		tay				tay
.a469	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a46c	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a46f	98		tya				tya
.a470	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.a473	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a476	a8		tay				tay
.a477	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a47a	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a47d	98		tya				tya
.a47e	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.a481	7a		ply				ply
.a482	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/unary.asm

.a483					Unary_Absolute:
.a483	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a486	30 01		bmi $a489			bmi 	Unary_Negate
.a488	60		rts				rts
.a489					Unary_Negate:
.a489					Unary_Const_Minus:
.a489	38		sec				sec
.a48a	a9 00		lda #$00			lda		#0
.a48c	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.a48f	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a492	a9 00		lda #$00			lda		#0
.a494	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.a497	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a49a	a9 00		lda #$00			lda		#0
.a49c	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.a49f	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a4a2	a9 00		lda #$00			lda		#0
.a4a4	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.a4a7	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a4aa	60		rts				rts
.a4ab					Unary_Not:
.a4ab	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a4ae	49 ff		eor #$ff			eor 	#$FF
.a4b0	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a4b3	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a4b6	49 ff		eor #$ff			eor 	#$FF
.a4b8	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a4bb	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a4be	49 ff		eor #$ff			eor 	#$FF
.a4c0	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a4c3	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a4c6	49 ff		eor #$ff			eor 	#$FF
.a4c8	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a4cb	60		rts				rts
.a4cc					Unary_Increment:
.a4cc	fe 00 0c	inc $0c00,x			inc 	stack0,x
.a4cf	d0 0d		bne $a4de			bne 	_UIExit
.a4d1	fe 00 0d	inc $0d00,x			inc 	stack1,x
.a4d4	d0 08		bne $a4de			bne 	_UIExit
.a4d6	fe 00 0e	inc $0e00,x			inc 	stack2,x
.a4d9	d0 03		bne $a4de			bne 	_UIExit
.a4db	fe 00 0f	inc $0f00,x			inc 	stack3,x
.a4de					_UIExit:
.a4de	60		rts				rts
.a4df					Unary_Decrement:
.a4df	38		sec				sec
.a4e0	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a4e3	e9 01		sbc #$01			sbc 	#1
.a4e5	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a4e8	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a4eb	e9 00		sbc #$00			sbc 	#0
.a4ed	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a4f0	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a4f3	e9 00		sbc #$00			sbc 	#0
.a4f5	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a4f8	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a4fb	e9 00		sbc #$00			sbc 	#0
.a4fd	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a500	60		rts				rts
.a501					Unary_Shl:
.a501	1e 00 0c	asl $0c00,x			asl 	stack0,x
.a504	3e 00 0d	rol $0d00,x			rol 	stack1,x
.a507	3e 00 0e	rol $0e00,x			rol 	stack2,x
.a50a	3e 00 0f	rol $0f00,x			rol 	stack3,x
.a50d	60		rts				rts
.a50e					Unary_Shr:
.a50e	5e 00 0f	lsr $0f00,x			lsr 	stack3,x
.a511	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a514	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a517	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a51a	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/memory.asm

.a51b					Mem_Peek:
.a51b	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a51e	85 04		sta $04				sta 	zTemp0
.a520	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a523	85 05		sta $05				sta 	zTemp0+1
.a525	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a527	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a52a	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a52d	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a530	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a533	60		rts				rts
.a534					Mem_WPeek:
.a534	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a537	85 04		sta $04				sta 	zTemp0
.a539	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a53c	85 05		sta $05				sta 	zTemp0+1
.a53e	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a540	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a543	5a		phy				phy 								; read msb
.a544	a0 01		ldy #$01			ldy 	#1
.a546	b1 04		lda ($04),y			lda 	(zTemp0),y
.a548	7a		ply				ply
.a549	9d 00 0d	sta $0d00,x			sta 	stack1,x 				; write to stack
.a54c	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a54f	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a552	60		rts				rts
.a553					Mem_DPeek:
.a553	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a556	85 04		sta $04				sta 	zTemp0
.a558	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a55b	85 05		sta $05				sta 	zTemp0+1
.a55d	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a55f	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a562	5a		phy				phy 								; read msb
.a563	a0 01		ldy #$01			ldy 	#1
.a565	b1 04		lda ($04),y			lda 	(zTemp0),y
.a567	9d 00 0d	sta $0d00,x			sta 	stack1,x 					; write to stack
.a56a	c8		iny				iny
.a56b	b1 04		lda ($04),y			lda 	(zTemp0),y
.a56d	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a570	c8		iny				iny
.a571	b1 04		lda ($04),y			lda 	(zTemp0),y
.a573	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a576	7a		ply				ply
.a577	60		rts				rts
.a578					Mem_Poke:
.a578	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a57b	85 04		sta $04				sta 	zTemp0
.a57d	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a580	85 05		sta $05				sta 	zTemp0+1
.a582	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.a585	92 04		sta ($04)			sta 	(zTemp0)
.a587	ca		dex				dex
.a588	ca		dex				dex
.a589	60		rts				rts
.a58a					Mem_WPoke:
.a58a	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a58d	85 04		sta $04				sta 	zTemp0
.a58f	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a592	85 05		sta $05				sta 	zTemp0+1
.a594	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.a597	92 04		sta ($04)			sta 	(zTemp0)
.a599	5a		phy				phy
.a59a	a0 01		ldy #$01			ldy 	#1
.a59c	bd ff 0e	lda $0eff,x			lda 	stack3-1,x 				; byte to write
.a59f	91 04		sta ($04),y			sta 	(zTemp0),y
.a5a1	7a		ply				ply
.a5a2	ca		dex				dex
.a5a3	ca		dex				dex
.a5a4	60		rts				rts
.a5a5					Mem_DPoke:
.a5a5	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a5a8	85 04		sta $04				sta 	zTemp0
.a5aa	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a5ad	85 05		sta $05				sta 	zTemp0+1
.a5af	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 					; byte to write
.a5b2	92 04		sta ($04)			sta 	(zTemp0)
.a5b4	5a		phy				phy
.a5b5	a0 01		ldy #$01			ldy 	#1
.a5b7	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a5ba	91 04		sta ($04),y			sta 	(zTemp0),y
.a5bc	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a5bf	c8		iny				iny
.a5c0	91 04		sta ($04),y			sta 	(zTemp0),y
.a5c2	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a5c5	c8		iny				iny
.a5c6	91 04		sta ($04),y			sta 	(zTemp0),y
.a5c8	7a		ply				ply
.a5c9	ca		dex				dex
.a5ca	ca		dex				dex
.a5cb	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/binary.asm

.a5cc					Stack_Add:
.a5cc	ca		dex				dex
.a5cd					Stack_Add_No_Dex:
.a5cd	18		clc				clc
.a5ce	bd 00 0c	lda $0c00,x			lda		stack0,x
.a5d1	7d 01 0c	adc $0c01,x			adc 	stack0+1,x
.a5d4	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a5d7	bd 00 0d	lda $0d00,x			lda		stack1,x
.a5da	7d 01 0d	adc $0d01,x			adc 	stack1+1,x
.a5dd	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a5e0	bd 00 0e	lda $0e00,x			lda		stack2,x
.a5e3	7d 01 0e	adc $0e01,x			adc 	stack2+1,x
.a5e6	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a5e9	bd 00 0f	lda $0f00,x			lda		stack3,x
.a5ec	7d 01 0f	adc $0f01,x			adc 	stack3+1,x
.a5ef	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a5f2	60		rts				rts
.a5f3					Stack_Sub:
.a5f3	ca		dex				dex
.a5f4	38		sec				sec
.a5f5	bd 00 0c	lda $0c00,x			lda		stack0,x
.a5f8	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.a5fb	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a5fe	bd 00 0d	lda $0d00,x			lda		stack1,x
.a601	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.a604	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a607	bd 00 0e	lda $0e00,x			lda		stack2,x
.a60a	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.a60d	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a610	bd 00 0f	lda $0f00,x			lda		stack3,x
.a613	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.a616	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a619	60		rts				rts
.a61a					Stack_And:
.a61a	ca		dex				dex
.a61b	bd 00 0c	lda $0c00,x			lda		stack0,x
.a61e	3d 01 0c	and $0c01,x			and		stack0+1,x
.a621	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a624	bd 00 0d	lda $0d00,x			lda		stack1,x
.a627	3d 01 0d	and $0d01,x			and 	stack1+1,x
.a62a	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a62d	bd 00 0e	lda $0e00,x			lda		stack2,x
.a630	3d 01 0e	and $0e01,x			and 	stack2+1,x
.a633	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a636	bd 00 0f	lda $0f00,x			lda		stack3,x
.a639	3d 01 0f	and $0f01,x			and 	stack3+1,x
.a63c	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a63f	60		rts				rts
.a640					Stack_Xor:
.a640	ca		dex				dex
.a641	bd 00 0c	lda $0c00,x			lda		stack0,x
.a644	5d 01 0c	eor $0c01,x			eor		stack0+1,x
.a647	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a64a	bd 00 0d	lda $0d00,x			lda		stack1,x
.a64d	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.a650	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a653	bd 00 0e	lda $0e00,x			lda		stack2,x
.a656	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.a659	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a65c	bd 00 0f	lda $0f00,x			lda		stack3,x
.a65f	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.a662	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a665	60		rts				rts
.a666					Stack_Or:
.a666	ca		dex				dex
.a667	bd 00 0c	lda $0c00,x			lda		stack0,x
.a66a	1d 01 0c	ora $0c01,x			ora		stack0+1,x
.a66d	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a670	bd 00 0d	lda $0d00,x			lda		stack1,x
.a673	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.a676	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a679	bd 00 0e	lda $0e00,x			lda		stack2,x
.a67c	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.a67f	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a682	bd 00 0f	lda $0f00,x			lda		stack3,x
.a685	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.a688	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a68b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/multiply.asm

.a68c					MulInteger32:
.a68c	ca		dex				dex
.a68d	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy +0 to workspace
.a690	85 0a		sta $0a				sta 	zLTemp1
.a692	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a695	85 0b		sta $0b				sta 	zLTemp1+1
.a697	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a69a	85 0c		sta $0c				sta 	zLTemp1+2
.a69c	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a69f	85 0d		sta $0d				sta 	zLTemp1+3
.a6a1	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; zero +0, where the result goes.
.a6a4	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a6a7	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a6aa	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a6ad					_BFMMultiply:
.a6ad	a5 0a		lda $0a				lda 	zLTemp1 					; get LSBit of 8-11
.a6af	29 01		and #$01			and 	#1
.a6b1	f0 03		beq $a6b6			beq 	_BFMNoAdd
.a6b3	20 cd a5	jsr $a5cd			jsr 	Stack_Add_No_Dex 			; co-opt this code
.a6b6					_BFMNoAdd:
.a6b6	1e 01 0c	asl $0c01,x			asl 	stack0+1,x 					; shift +4 left
.a6b9	3e 01 0d	rol $0d01,x			rol 	stack1+1,x
.a6bc	3e 01 0e	rol $0e01,x			rol 	stack2+1,x
.a6bf	3e 01 0f	rol $0f01,x			rol 	stack3+1,x
.a6c2	46 0d		lsr $0d				lsr 	zLTemp1+3 					; shift +8 right
.a6c4	66 0c		ror $0c				ror 	zLTemp1+2
.a6c6	66 0b		ror $0b				ror 	zLTemp1+1
.a6c8	66 0a		ror $0a				ror 	zLTemp1
.a6ca	a5 0a		lda $0a				lda 	zLTemp1 					; continue if +8 is nonzero
.a6cc	05 0b		ora $0b				ora 	zLTemp1+1
.a6ce	05 0c		ora $0c				ora 	zLTemp1+2
.a6d0	05 0d		ora $0d				ora 	zLTemp1+3
.a6d2	d0 d9		bne $a6ad			bne 	_BFMMultiply
.a6d4	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/divide.asm

.a6d5					DivInteger32:
.a6d5	ca		dex				dex
.a6d6	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check for division by zero.
.a6d9	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.a6dc	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.a6df	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.a6e2	d0 14		bne $a6f8			bne 	_BFDOkay
.a6e4	20 b5 a9	jsr $a9b5			jsr 	ErrorHandler
>a6e7	44 69 76 69 73 69 6f 6e				.text 	"Division by Zero",0
>a6ef	20 62 79 20 5a 65 72 6f 00
.a6f8					_BFDOkay:
.a6f8	64 0a		stz $0a				stz 	zLTemp1 					; Q/Dividend/Left in +0
.a6fa	64 0b		stz $0b				stz 	zLTemp1+1 					; M/Divisor/Right in +4
.a6fc	64 0c		stz $0c				stz 	zLTemp1+2
.a6fe	64 0d		stz $0d				stz 	zLTemp1+3
.a700	64 11		stz $11				stz 	SignCount 					; Count of signs.
.a702	20 5c a7	jsr $a75c			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.a705	e8		inx				inx
.a706	20 5c a7	jsr $a75c			jsr 	CheckIntegerNegate
.a709	ca		dex				dex
.a70a	5a		phy				phy 								; Y is the counter
.a70b	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.a70d					_BFDLoop:
.a70d	1e 00 0c	asl $0c00,x			asl 	stack0,x 					; shift AQ left.
.a710	3e 00 0d	rol $0d00,x			rol 	stack1,x
.a713	3e 00 0e	rol $0e00,x			rol 	stack2,x
.a716	3e 00 0f	rol $0f00,x			rol 	stack3,x
.a719	26 0a		rol $0a				rol 	zLTemp1
.a71b	26 0b		rol $0b				rol 	zLTemp1+1
.a71d	26 0c		rol $0c				rol 	zLTemp1+2
.a71f	26 0d		rol $0d				rol 	zLTemp1+3
.a721	38		sec				sec
.a722	a5 0a		lda $0a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.a724	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.a727	48		pha				pha
.a728	a5 0b		lda $0b				lda 	zLTemp1+1
.a72a	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.a72d	48		pha				pha
.a72e	a5 0c		lda $0c				lda 	zLTemp1+2
.a730	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.a733	48		pha				pha
.a734	a5 0d		lda $0d				lda 	zLTemp1+3
.a736	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.a739	90 15		bcc $a750			bcc 	_BFDNoAdd
.a73b	85 0d		sta $0d				sta 	zLTemp1+3 					; update A
.a73d	68		pla				pla
.a73e	85 0c		sta $0c				sta 	zLTemp1+2
.a740	68		pla				pla
.a741	85 0b		sta $0b				sta 	zLTemp1+1
.a743	68		pla				pla
.a744	85 0a		sta $0a				sta 	zLTemp1+0
.a746	bd 00 0c	lda $0c00,x			lda 	stack0,x 			; set Q bit 1.
.a749	09 01		ora #$01			ora 	#1
.a74b	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a74e	80 03		bra $a753			bra 	_BFDNext
.a750					_BFDNoAdd:
.a750	68		pla				pla 								; Throw away the intermediate calculations
.a751	68		pla				pla
.a752	68		pla				pla
.a753					_BFDNext:
.a753	88		dey				dey
.a754	d0 b7		bne $a70d			bne 	_BFDLoop
.a756	7a		ply				ply 								; restore Y
.a757	46 11		lsr $11				lsr 	SignCount 					; if sign count odd,
.a759	b0 07		bcs $a762			bcs		IntegerNegateAlways 		; negate the result
.a75b	60		rts				rts
.a75c					CheckIntegerNegate:
.a75c	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; is it -ve = MSB set ?
.a75f	30 01		bmi $a762			bmi 	IntegerNegateAlways 		; if so negate it
.a761	60		rts				rts
.a762					IntegerNegateAlways:
.a762	e6 11		inc $11				inc 	SignCount 					; bump the count of signs
.a764	4c 89 a4	jmp $a489			jmp 	Unary_Negate
.a767					ModInteger32:
.a767	20 d5 a6	jsr $a6d5			jsr 	DivInteger32
.a76a	a5 0a		lda $0a				lda 	zLTemp1
.a76c	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a76f	a5 0b		lda $0b				lda 	zLTemp1+1
.a771	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a774	a5 0c		lda $0c				lda 	zLTemp1+2
.a776	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a779	a5 0d		lda $0d				lda 	zLTemp1+3
.a77b	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a77e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/compare.asm

.a77f					Comp_Equal:
.a77f	38		sec				sec
.a780	80 01		bra $a783			bra 	Comp_CheckEqual
.a782					Comp_NotEqual:
.a782	18		clc				clc
.a783					Comp_CheckEqual:
.a783	08		php				php
.a784	ca		dex				dex
.a785	bd 00 0c	lda $0c00,x			lda		stack0,x
.a788	5d 01 0c	eor $0c01,x			eor 	stack0+1,x
.a78b	d0 16		bne $a7a3			bne 	_CCENonZero
.a78d	bd 00 0d	lda $0d00,x			lda		stack1,x
.a790	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.a793	d0 0e		bne $a7a3			bne 	_CCENonZero
.a795	bd 00 0e	lda $0e00,x			lda		stack2,x
.a798	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.a79b	d0 06		bne $a7a3			bne 	_CCENonZero
.a79d	bd 00 0f	lda $0f00,x			lda		stack3,x
.a7a0	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.a7a3					_CCENonZero:
.a7a3	f0 02		beq $a7a7			beq 	_CCENotSet
.a7a5	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.a7a7					_CCENotSet:
.a7a7					CompCheckFlip:
.a7a7	28		plp				plp 								; if carry set, we want $FF if equal
.a7a8	90 02		bcc $a7ac			bcc 	CompReturn
.a7aa	49 ff		eor #$ff			eor 	#$FF
.a7ac					CompReturn:
.a7ac	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; save result on stack.
.a7af	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a7b2	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a7b5	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a7b8	60		rts				rts
.a7b9					Comp_Less:
.a7b9	18		clc				clc
.a7ba	80 01		bra $a7bd			bra 	Comp_LessCont
.a7bc					Comp_GreaterEqual:
.a7bc	38		sec				sec
.a7bd					Comp_LessCont:
.a7bd	08		php				php
.a7be	ca		dex				dex
.a7bf	38		sec				sec
.a7c0	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; do a subtraction w/o storing the result
.a7c3	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.a7c6	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a7c9	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.a7cc	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a7cf	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.a7d2	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a7d5	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.a7d8	50 02		bvc $a7dc			bvc 	_CLNoFlip 					; unsigned -> signed
.a7da	49 80		eor #$80			eor 	#$80
.a7dc					_CLNoFlip:
.a7dc	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.a7de	f0 c7		beq $a7a7			beq 	CompCheckFlip
.a7e0	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.a7e2	80 c3		bra $a7a7			bra 	CompCheckFlip
.a7e4					Comp_LessEqual:
.a7e4	38		sec				sec
.a7e5	80 01		bra $a7e8			bra 	Comp_LessEqualCont
.a7e7					Comp_Greater:
.a7e7	18		clc				clc
.a7e8					Comp_LessEqualCont:
.a7e8	08		php				php
.a7e9	ca		dex				dex
.a7ea	38		sec				sec
.a7eb	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; do a subtraction w/o storing the result, backwards
.a7ee	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.a7f1	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.a7f4	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.a7f7	bd 01 0e	lda $0e01,x			lda 	stack2+1,x
.a7fa	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.a7fd	bd 01 0f	lda $0f01,x			lda 	stack3+1,x
.a800	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.a803	50 02		bvc $a807			bvc 	_CLENoFlip 					; unsigned -> signed
.a805	49 80		eor #$80			eor 	#$80
.a807					_CLENoFlip:
.a807	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.a809	f0 9c		beq $a7a7			beq 	CompCheckFlip
.a80b	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.a80d	80 98		bra $a7a7			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: miscellany/system.asm

.a80f					System_RUN:
.a80f	20 ff a2	jsr $a2ff			jsr		ResetForRun 				; clear vars, stacks etc.
.a812	20 f4 a2	jsr $a2f4			jsr 	ResetCodePointer 			; point to first thing to do.
.a815	4c 71 a1	jmp $a171			jmp 	Execute						; and run
.a818					System_END:
>a818	ff						.byte 	$FF
.a819	4c b2 a9	jmp $a9b2			jmp 	WarmStart
.a81c					System_STOP:
.a81c	4c ff ff	jmp $ffff			jmp 	$FFFF
.a81f	20 b5 a9	jsr $a9b5			jsr 	ErrorHandler
>a822	53 54 4f 50 00					.text 	"STOP",0
.a827					System_New:
.a827	9c 00 11	stz $1100			stz 	ProgramStart 				; zero the first offset, erases.
.a82a	20 ff a2	jsr $a2ff			jsr		ResetForRun 				; clear vars, stacks etc.
.a82d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/variables.asm

.a82e					Identifier:
.a82e	88		dey				dey 								; wind back to identifier start
.a82f	20 1a a2	jsr $a21a			jsr 	IdentifierSearch 			; try to find it.
.a832	90 2b		bcc $a85f			bcc 	_IDUnknown 					; not known, give up.
.a834	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.a836	d0 3b		bne $a873			bne 	IDTypeError
.a838	c8		iny		_IDSkip:iny
.a839	b1 00		lda ($00),y			lda 	(codePtr),y
.a83b	c9 c0		cmp #$c0			cmp 	#$C0
.a83d	b0 f9		bcs $a838			bcs 	_IDSkip
.a83f	20 8c a3	jsr $a38c			jsr 	IndexCheck 					; check index/subscript
.a842	5a		phy				phy
.a843	e8		inx				inx 								; make space on stack
.a844	a0 00		ldy #$00			ldy 	#0 							; copy it back
.a846	b1 0f		lda ($0f),y			lda 	(idDataAddr),y
.a848	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a84b	c8		iny				iny
.a84c	b1 0f		lda ($0f),y			lda 	(idDataAddr),y
.a84e	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a851	c8		iny				iny
.a852	b1 0f		lda ($0f),y			lda 	(idDataAddr),y
.a854	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a857	c8		iny				iny
.a858	b1 0f		lda ($0f),y			lda 	(idDataAddr),y
.a85a	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a85d	7a		ply				ply
.a85e	60		rts				rts
.a85f					_IDUnknown:
.a85f	20 b5 a9	jsr $a9b5			jsr 	ErrorHandler
>a862	55 6e 6b 6e 6f 77 6e 20				.text 	"Unknown variable",0
>a86a	76 61 72 69 61 62 6c 65 00
.a873					IDTypeError:
.a873	20 b5 a9	jsr $a9b5			jsr 	ErrorHandler
>a876	56 61 72 69 61 62 6c 65				.text 	"Variable Required",0
>a87e	20 52 65 71 75 69 72 65 64 00
.a888					WriteVariable:
.a888	20 1a a2	jsr $a21a			jsr 	IdentifierSearch 			; does it exist
.a88b	90 06		bcc $a893			bcc 	_WVNoIdentifier
.a88d	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.a88f	f0 12		beq $a8a3			beq 	_WVWriteTOS 				; if so write TOS to it.
.a891	80 e0		bra $a873			bra 	IDTypeError 				; not, then can't do anything.
.a893					_WVNoIdentifier:
.a893	5a		phy				phy 								; get current line number
.a894	a0 01		ldy #$01			ldy 	#1
.a896	b1 00		lda ($00),y			lda 	(codePtr),y
.a898	c8		iny				iny
.a899	11 00		ora ($00),y			ora 	(codePtr),y
.a89b	7a		ply				ply
.a89c	f0 2f		beq $a8cd			beq 	_WVCantCreate 				; if zero (command line) no new vars
.a89e	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; create identifier
.a8a0	20 81 a2	jsr $a281			jsr 	IdentifierCreate 			; try to find it
.a8a3					_WVWriteTOS:
.a8a3	88		dey				dey 								; skip over identifier.
.a8a4					_WVSkipIdentifier:
.a8a4	c8		iny				iny
.a8a5	b1 00		lda ($00),y			lda 	(codePtr),y
.a8a7	c9 c0		cmp #$c0			cmp 	#$C0
.a8a9	b0 f9		bcs $a8a4			bcs 	_WVSkipIdentifier
.a8ab	20 8c a3	jsr $a38c			jsr 	IndexCheck 					; check index/subscript
.a8ae	5a		phy				phy									; copy TOS in
.a8af	a0 00		ldy #$00			ldy 	#0
.a8b1	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a8b4	91 0f		sta ($0f),y			sta 	(idDataAddr),y
.a8b6	c8		iny				iny
.a8b7	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a8ba	91 0f		sta ($0f),y			sta 	(idDataAddr),y
.a8bc	c8		iny				iny
.a8bd	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a8c0	91 0f		sta ($0f),y			sta 	(idDataAddr),y
.a8c2	c8		iny				iny
.a8c3	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a8c6	91 0f		sta ($0f),y			sta 	(idDataAddr),y
.a8c8	7a		ply				ply
.a8c9	ca		dex				dex 								; drop
.a8ca	4c 71 a1	jmp $a171			jmp 	Execute 					; go back and execute again.
.a8cd					_WVCantCreate:
.a8cd	20 b5 a9	jsr $a9b5			jsr 	ErrorHandler
>a8d0	43 61 6e 6e 6f 74 20 63				.text 	"Cannot create variable",0
>a8d8	72 65 61 74 65 20 76 61 72 69 61 62 6c 65 00

;******  Return to file: main.asm


;******  Processing file: miscellany/inttostr.asm


;******  Return to file: main.asm


;******  Processing file: miscellany/intfromstr.asm


;******  Return to file: main.asm


;******  Processing file: structures/fornext.asm

.a8e7					Command_For:
.a8e7	20 89 a9	jsr $a989			jsr 	StructPushCurrent 			; push current on the stack.
.a8ea	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check zero
.a8ed	1d 00 0d	ora $0d00,x			ora 	stack1,x
.a8f0	1d 00 0e	ora $0e00,x			ora 	stack2,x
.a8f3	1d 00 0f	ora $0f00,x			ora 	stack3,x
.a8f6	f0 34		beq $a92c			beq 	_CFZero
.a8f8	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; push 1's complement of index on
.a8fb	49 ff		eor #$ff			eor 	#$FF 						; structure stack.
.a8fd	c6 02		dec $02				dec 	StructSP
.a8ff	92 02		sta ($02)			sta 	(StructSP)
.a901	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a904	49 ff		eor #$ff			eor 	#$FF
.a906	c6 02		dec $02				dec 	StructSP
.a908	92 02		sta ($02)			sta 	(StructSP)
.a90a	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a90d	49 ff		eor #$ff			eor 	#$FF
.a90f	c6 02		dec $02				dec 	StructSP
.a911	92 02		sta ($02)			sta 	(StructSP)
.a913	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a916	49 ff		eor #$ff			eor 	#$FF
.a918	c6 02		dec $02				dec 	StructSP
.a91a	92 02		sta ($02)			sta 	(StructSP)
.a91c	ca		dex				dex 								; pop stack value
.a91d	a9 46		lda #$46			lda 	#STM_FOR 					; push FOR marker
.a91f	c6 02		dec $02				dec 	StructSP
.a921	92 02		sta ($02)			sta 	(StructSP)
.a923	a5 02		lda $02				lda 	StructSP 					; copy current so it can access it.
.a925	85 12		sta $12				sta 	ForAddr
.a927	a5 03		lda $03				lda 	StructSP+1
.a929	85 13		sta $13				sta 	ForAddr+1
.a92b	60		rts				rts
.a92c					_CFZero:
.a92c	20 b5 a9	jsr $a9b5			jsr 	ErrorHandler
>a92f	46 4f 52 20 63 6f 75 6e				.text 	"FOR count zero",0
>a937	74 20 7a 65 72 6f 00
.a93e					Command_Next:
.a93e	b2 02		lda ($02)			lda 	(StructSP)					; check it's FOR.
.a940	c9 46		cmp #$46			cmp 	#STM_FOR
.a942	d0 30		bne $a974			bne 	_CNNoFor
.a944	5a		phy				phy
.a945	a0 00		ldy #$00			ldy 	#0
.a947					_CNIncrement:
.a947	c8		iny				iny
.a948	b1 02		lda ($02),y			lda 	(StructSP),y 				; increment the index
.a94a	1a		inc a				inc 	a
.a94b	91 02		sta ($02),y			sta 	(StructSP),y
.a94d	f0 f8		beq $a947			beq		_CNIncrement 				; carry out.
.a94f	a0 01		ldy #$01			ldy 	#1 							; now and all the counts together
.a951	b1 02		lda ($02),y			lda 	(StructSP),y 				; on the last time round they
.a953	c8		iny				iny 								; will all be $FF
.a954	31 02		and ($02),y			and 	(StructSP),y
.a956	c8		iny				iny
.a957	31 02		and ($02),y			and 	(StructSP),y
.a959	c8		iny				iny
.a95a	31 02		and ($02),y			and 	(StructSP),y
.a95c	7a		ply				ply 								; restore Y
.a95d	1a		inc a				inc 	a 							; so this will be zero last time round
.a95e	d0 06		bne $a966			bne 	_CNLoop 					; loop back if non-zero
.a960	a9 09		lda #$09			lda 	#9 							; pop 9 elements off structure stack.
.a962	20 83 a9	jsr $a983			jsr 	StructPopCount
.a965	60		rts				rts
.a966					_CNLoop:
.a966	a5 02		lda $02				lda 	StructSP 					; copy current so it can access it.
.a968	85 12		sta $12				sta 	ForAddr
.a96a	a5 03		lda $03				lda 	StructSP+1
.a96c	85 13		sta $13				sta 	ForAddr+1
.a96e	a0 05		ldy #$05			ldy 	#5 							; restore the position
.a970	20 a1 a9	jsr $a9a1			jsr 	StructPopCurrent
.a973	60		rts				rts
.a974					_CNNoFor:
.a974	20 b5 a9	jsr $a9b5			jsr 	ErrorHandler
>a977	4d 69 73 73 69 6e 67 20				.text 	"Missing FOR",0
>a97f	46 4f 52 00

;******  Return to file: main.asm


;******  Processing file: structures/structures.asm

.a983					StructPopCount:
.a983	18		clc				clc
.a984	65 02		adc $02				adc 	StructSP
.a986	85 02		sta $02				sta 	StructSP
.a988	60		rts				rts
.a989					StructPushCurrent:
.a989	a9 00		lda #$00			lda 	#0							; push bank
.a98b	c6 02		dec $02				dec 	StructSP
.a98d	92 02		sta ($02)			sta 	(StructSP)
.a98f	98		tya				tya									; y Offset
.a990	c6 02		dec $02				dec 	StructSP
.a992	92 02		sta ($02)			sta 	(StructSP)
.a994	a5 01		lda $01				lda 	codePtr+1 					; codeptr high
.a996	c6 02		dec $02				dec 	StructSP
.a998	92 02		sta ($02)			sta 	(StructSP)
.a99a	a5 00		lda $00				lda 	codePtr 					; codeptr low
.a99c	c6 02		dec $02				dec 	StructSP
.a99e	92 02		sta ($02)			sta 	(StructSP)
.a9a0	60		rts				rts
.a9a1					StructPopCurrent:
.a9a1	b1 02		lda ($02),y			lda 	(StructSP),y 				; codeptr low
.a9a3	85 00		sta $00				sta 	codePtr
.a9a5	c8		iny				iny
.a9a6	b1 02		lda ($02),y			lda 	(StructSP),y 				; codeptr high
.a9a8	85 01		sta $01				sta 	codePtr+1
.a9aa	c8		iny				iny
.a9ab	b1 02		lda ($02),y			lda 	(StructSP),y				; y offset
.a9ad	a8		tay				tay
.a9ae	60		rts				rts

;******  Return to file: main.asm

.a9af					SyntaxError:
>a9af	ff						.byte 	$FF
.a9b0	a2 02		ldx #$02			ldx 	#2
.a9b2					WarmStart:
>a9b2	ff						.byte 	$FF
.a9b3	a2 03		ldx #$03			ldx 	#3
.a9b5					ErrorHandler:
>a9b5	ff						.byte 	$FF
.a9b6	a2 04		ldx #$04			ldx 	#4

;******  Processing file: generated/testcode.inc

>1100	07 e8 03 83 80 b9 00 05			.byte $07,$e8,$03,$83,$80,$b9,$00,$05,$f2,$03,$80,$00,$09,$fc,$03,$82,$9c,$90,$10,$2e,$00,$06,$06,$04,$85,$14,$00,$05,$10,$04,$35,$00,$09,$1a,$04,$8d,$90,$b1,$10,$3d,$00,$0f,$24,$04,$28,$10,$c1,$c2,$e3,$10,$81,$10,$82,$10,$83,$00,$12,$2e,$04,$28,$10,$c1,$c0,$d3,$df,$c2,$e2,$10,$84,$10,$85,$10,$86,$00,$11,$38,$04,$28,$10,$c7,$c4,$cb,$cb,$ce,$df,$d6,$ce,$d1,$cb,$e3,$00
>1108	f2 03 80 00 09 fc 03 82 9c 90 10 2e 00 06 06 04
>1118	85 14 00 05 10 04 35 00 09 1a 04 8d 90 b1 10 3d
>1128	00 0f 24 04 28 10 c1 c2 e3 10 81 10 82 10 83 00
>1138	12 2e 04 28 10 c1 c0 d3 df c2 e2 10 84 10 85 10
>1148	86 00 11 38 04 28 10 c7 c4 cb cb ce df d6 ce d1
>1158	cb e3 00

;******  Return to file: main.asm

>115b	00						.byte 	0

;******  End of listing
