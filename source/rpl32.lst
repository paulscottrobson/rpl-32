
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl32.prg -L rpl32.lst main.asm
; Sat Oct  5 23:56:17 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; build the interpreter here
=$0c00					StackAddress = $0C00 						; 1k of stack space (256 x 32 bits)
=$1000					MemoryStart = $1000 						; system memory starts here
=$6000					MemoryEnd = $6000 							; and ends here.
=$0bff					StructureStack = $0BFF 						; structure stack (works down to $xx00)
=$0a00					ExtDataArea = $0A00 						; space where non zp data goes
=16					HashTableSize = 16 							; hash tables to search.
>0000					CodePtr: 		.word ? 					; code pointer
>0002					StructSP: 		.word ?						; structure stack pointer
>0004					zTemp0:			.word ?						; temporary words
>0006					zTemp1: 		.word ?
>0008					zTemp2: 		.word ?
>000a					zLTemp1:		.dword ?					; temporary longs
>000e					idDataAddr:		.word ? 					; data address.
>0010					ForAddr:		.byte ? 					; points to current FOR structure
>0a00					SBuffer:		.fill 32 					; string buffer
>0a20					SBPosition:		.byte ? 					; position in String Buffer
>0a21					NumConvCount:	.byte ? 					; used in int to string
>0a22					breakCount:		.byte ? 					; used to stop break firing every execution.
>0a23					SignCount:		.byte ?						; sign count for divide
>0a24					NumSuppress:	.byte ? 					; zero suppression flag
>1000					AZVariables:	.fill	26*4 				; 26 x 4 byte variables, which are A-Z
>1068					HashTable: 		.fill 	HashTableSize * 2 	; n x 2 links for the hash tables.
>1088	00 00				VarMemory:		.word 	0 					; next free byte available for VARIABLES (going up)
>108a	00 00				AllocMemory: 	.word 	0 					; last free byte availabel for ALLOC (going down)
=4352					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0c00					stack0 = StackAddress
=3328					stack1 = StackAddress+256
=3584					stack2 = StackAddress+512
=3840					stack3 = StackAddress+768
="V"					IDT_VARIABLE = 'V'							; type markers for the information store.
="P"					IDT_PROCEDURE = 'P'							; standard procedure (e.g. in code)
="C"					IDT_CODEPROC = 'C'							; machine language procedure.
="F"					STM_FOR = 'F'								; structure markers (for/next)
="C"					STM_CALL = 'C'								; call & return  (& ;)
="R"					STM_REPEAT = 'R'							; repeat & until
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=5					CTH_ERROR = COL_MAGENTA
=2					CTH_TOKEN = COL_GREEN
=3					CTH_IDENT = COL_YELLOW
=7					CTH_COMMENT = COL_WHITE
=5					CTH_STRING = COL_MAGENTA
=6					CTH_NUMBER = COL_CYAN

;******  Return to file: main.asm


;******  Processing file: macro.asm


;******  Return to file: main.asm

.0f00	4c 00 a0	jmp $a000			jmp 	Start
.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 a7 a1	jsr $a1a7			jsr 	ExternInitialise 			; interface setup
.a006	a2 00		ldx #$00			ldx 	#0 							; display boot message
.a008					_Display:
.a008	bd 1d a0	lda $a01d,x			lda 	BootMessage,x
.a00b	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a00e	e8		inx				inx
.a00f	bd 1d a0	lda $a01d,x			lda 	BootMessage,x
.a012	d0 f4		bne $a008			bne 	_Display
.a014	20 94 a3	jsr $a394			jsr 	ResetForRun
.a017	20 89 a3	jsr $a389			jsr 	ResetCodePointer
.a01a	4c 1e ab	jmp $ab1e			jmp 	System_RUN
.a01d					BootMessage:

;******  Processing file: generated/bootmessage.inc

>a01d	2a 2a 2a 2a 20 52 50 4c			.byte $2a,$2a,$2a,$2a,$20,$52,$50,$4c,$2f,$33,$32,$20,$49,$4e,$54,$45,$52,$50,$52,$45,$54,$45,$52,$20,$2a,$2a,$2a,$2a,$0d,$0d,$42,$55,$49,$4c,$44,$3a,$44,$45,$56,$20,$44,$41,$54,$45,$3a,$30,$35,$2d,$4f,$43,$54,$2d,$32,$30,$31,$39,$0d,$0d,$00
>a025	2f 33 32 20 49 4e 54 45 52 50 52 45 54 45 52 20
>a035	2a 2a 2a 2a 0d 0d 42 55 49 4c 44 3a 44 45 56 20
>a045	44 41 54 45 3a 30 35 2d 4f 43 54 2d 32 30 31 39
>a055	0d 0d 00

;******  Return to file: main.asm


;******  Processing file: generated/tables.inc

.a058					KeywordText:
>a058	01 20					.byte $01,$20                          ; $10
>a05a	01 21					.byte $01,$21                          ; $11 !
>a05c	01 26					.byte $01,$26                          ; $12 &
>a05e	01 2a					.byte $01,$2a                          ; $13 *
>a060	01 2b					.byte $01,$2b                          ; $14 +
>a062	02 2b 2b				.byte $02,$2b,$2b                      ; $15 ++
>a065	01 2d					.byte $01,$2d                          ; $16 -
>a067	02 2d 2d				.byte $02,$2d,$2d                      ; $17 --
>a06a	01 2f					.byte $01,$2f                          ; $18 /
>a06c	01 3b					.byte $01,$3b                          ; $19 ;
>a06e	01 3c					.byte $01,$3c                          ; $1a <
>a070	02 3c 3c				.byte $02,$3c,$3c                      ; $1b <<
>a073	02 3c 3d				.byte $02,$3c,$3d                      ; $1c <=
>a076	02 3c 3e				.byte $02,$3c,$3e                      ; $1d <>
>a079	01 3d					.byte $01,$3d                          ; $1e =
>a07b	01 3e					.byte $01,$3e                          ; $1f >
>a07d	02 3e 3d				.byte $02,$3e,$3d                      ; $20 >=
>a080	02 3e 3e				.byte $02,$3e,$3e                      ; $21 >>
>a083	01 40					.byte $01,$40                          ; $22 @
>a085	03 41 42 53				.byte $03,$41,$42,$53                  ; $23 ABS
>a089	05 41 4c 4c 4f 43			.byte $05,$41,$4c,$4c,$4f,$43          ; $24 ALLOC
>a08f	03 41 4e 44				.byte $03,$41,$4e,$44                  ; $25 AND
>a093	06 41 53 53 45 52 54			.byte $06,$41,$53,$53,$45,$52,$54      ; $26 ASSERT
>a09a	02 43 21				.byte $02,$43,$21                      ; $27 C!
>a09d	02 43 40				.byte $02,$43,$40                      ; $28 C@
>a0a0	03 44 45 46				.byte $03,$44,$45,$46                  ; $29 DEF
>a0a4	04 44 52 4f 50				.byte $04,$44,$52,$4f,$50              ; $2a DROP
>a0a9	03 44 55 50				.byte $03,$44,$55,$50                  ; $2b DUP
>a0ad	04 45 4c 53 45				.byte $04,$45,$4c,$53,$45              ; $2c ELSE
>a0b2	05 45 4d 50 54 59			.byte $05,$45,$4d,$50,$54,$59          ; $2d EMPTY
>a0b8	03 45 4e 44				.byte $03,$45,$4e,$44                  ; $2e END
>a0bc	05 45 4e 44 49 46			.byte $05,$45,$4e,$44,$49,$46          ; $2f ENDIF
>a0c2	03 46 4f 52				.byte $03,$46,$4f,$52                  ; $30 FOR
>a0c6	02 49 46				.byte $02,$49,$46                      ; $31 IF
>a0c9	05 49 4e 44 45 58			.byte $05,$49,$4e,$44,$45,$58          ; $32 INDEX
>a0cf	04 4c 49 53 54				.byte $04,$4c,$49,$53,$54              ; $33 LIST
>a0d4	03 4d 4f 44				.byte $03,$4d,$4f,$44                  ; $34 MOD
>a0d8	06 4e 45 47 41 54 45			.byte $06,$4e,$45,$47,$41,$54,$45      ; $35 NEGATE
>a0df	03 4e 45 57				.byte $03,$4e,$45,$57                  ; $36 NEW
>a0e3	04 4e 45 58 54				.byte $04,$4e,$45,$58,$54              ; $37 NEXT
>a0e8	03 4e 49 50				.byte $03,$4e,$49,$50                  ; $38 NIP
>a0ec	03 4e 4f 54				.byte $03,$4e,$4f,$54                  ; $39 NOT
>a0f0	03 4f 4c 44				.byte $03,$4f,$4c,$44                  ; $3a OLD
>a0f4	02 4f 52				.byte $02,$4f,$52                      ; $3b OR
>a0f7	04 4f 56 45 52				.byte $04,$4f,$56,$45,$52              ; $3c OVER
>a0fc	06 52 45 50 45 41 54			.byte $06,$52,$45,$50,$45,$41,$54      ; $3d REPEAT
>a103	03 52 55 4e				.byte $03,$52,$55,$4e                  ; $3e RUN
>a107	05 53 54 41 43 4b			.byte $05,$53,$54,$41,$43,$4b          ; $3f STACK
>a10d	04 53 54 4f 50				.byte $04,$53,$54,$4f,$50              ; $40 STOP
>a112	04 53 57 41 50				.byte $04,$53,$57,$41,$50              ; $41 SWAP
>a117	03 53 59 53				.byte $03,$53,$59,$53                  ; $42 SYS
>a11b	05 55 4e 54 49 4c			.byte $05,$55,$4e,$54,$49,$4c          ; $43 UNTIL
>a121	02 57 21				.byte $02,$57,$21                      ; $44 W!
>a124	02 57 40				.byte $02,$57,$40                      ; $45 W@
>a127	03 58 4f 52				.byte $03,$58,$4f,$52                  ; $46 XOR
>a12b	02 5b 5d				.byte $02,$5b,$5d                      ; $47 []
>a12e	01 5e					.byte $01,$5e                          ; $48 ^
>a130	01 2d					.byte $01,$2d                          ; $49 {-}
>a132	00					.byte $00
.a133					KeywordVectorTable:
>a133	8a a4					.word SyntaxError                      ; $10
>a135	b1 a8					.word Mem_DPoke                        ; $11 !
>a137	8a a4					.word SyntaxError                      ; $12 &
>a139	98 a9					.word MulInteger32                     ; $13 *
>a13b	d8 a8					.word Stack_Add                        ; $14 +
>a13d	d8 a7					.word Unary_Increment                  ; $15 ++
>a13f	ff a8					.word Stack_Sub                        ; $16 -
>a141	eb a7					.word Unary_Decrement                  ; $17 --
>a143	e1 a9					.word DivInteger32                     ; $18 /
>a145	8a a4					.word SyntaxError                      ; $19 ;
>a147	c8 aa					.word Comp_Less                        ; $1a <
>a149	0d a8					.word Unary_Shl                        ; $1b <<
>a14b	f3 aa					.word Comp_LessEqual                   ; $1c <=
>a14d	91 aa					.word Comp_NotEqual                    ; $1d <>
>a14f	8e aa					.word Comp_Equal                       ; $1e =
>a151	f6 aa					.word Comp_Greater                     ; $1f >
>a153	cb aa					.word Comp_GreaterEqual                ; $20 >=
>a155	1a a8					.word Unary_Shr                        ; $21 >>
>a157	5f a8					.word Mem_DPeek                        ; $22 @
>a159	8f a7					.word Unary_Absolute                   ; $23 ABS
>a15b	8a a4					.word SyntaxError                      ; $24 ALLOC
>a15d	26 a9					.word Stack_And                        ; $25 AND
>a15f	36 ab					.word System_Assert                    ; $26 ASSERT
>a161	84 a8					.word Mem_Poke                         ; $27 C!
>a163	27 a8					.word Mem_Peek                         ; $28 C@
>a165	8a a4					.word SyntaxError                      ; $29 DEF
>a167	04 a7					.word Stack_Drop                       ; $2a DROP
>a169	06 a7					.word Stack_Dup                        ; $2b DUP
>a16b	8a a4					.word SyntaxError                      ; $2c ELSE
>a16d	01 a7					.word Stack_Empty                      ; $2d EMPTY
>a16f	27 ab					.word System_END                       ; $2e END
>a171	8a a4					.word SyntaxError                      ; $2f ENDIF
>a173	8f ac					.word Command_For                      ; $30 FOR
>a175	8a a4					.word SyntaxError                      ; $31 IF
>a177	2b ad					.word Command_Index                    ; $32 INDEX
>a179	01 a6					.word Cmd_List                         ; $33 LIST
>a17b	76 aa					.word ModInteger32                     ; $34 MOD
>a17d	95 a7					.word Unary_Negate                     ; $35 NEGATE
>a17f	50 ab					.word System_New                       ; $36 NEW
>a181	e6 ac					.word Command_Next                     ; $37 NEXT
>a183	20 a7					.word Stack_Nip                        ; $38 NIP
>a185	b7 a7					.word Unary_Not                        ; $39 NOT
>a187	57 ab					.word System_Old                       ; $3a OLD
>a189	72 a9					.word Stack_Or                         ; $3b OR
>a18b	3a a7					.word Stack_Over                       ; $3c OVER
>a18d	8a a4					.word SyntaxError                      ; $3d REPEAT
>a18f	1e ab					.word System_RUN                       ; $3e RUN
>a191	a3 ab					.word System_Stack                     ; $3f STACK
>a193	2b ab					.word System_STOP                      ; $40 STOP
>a195	54 a7					.word Stack_Swap                       ; $41 SWAP
>a197	7b ab					.word System_Sys                       ; $42 SYS
>a199	8a a4					.word SyntaxError                      ; $43 UNTIL
>a19b	96 a8					.word Mem_WPoke                        ; $44 W!
>a19d	40 a8					.word Mem_WPeek                        ; $45 W@
>a19f	4c a9					.word Stack_Xor                        ; $46 XOR
>a1a1	8a a4					.word SyntaxError                      ; $47 []
>a1a3	2c ac					.word WriteVariable                    ; $48 ^
>a1a5	95 a7					.word Unary_Const_Minus                ; $49 {-}
=$10					KWD_SPACE = $10                  ; $10
=$11					KWD_PLING = $11                  ; $11 !
=$12					KWD_AMPERSAND = $12              ; $12 &
=$13					KWD_ASTERISK = $13               ; $13 *
=$14					KWD_PLUS = $14                   ; $14 +
=$15					KWD_PLUSPLUS = $15               ; $15 ++
=$16					KWD_MINUS = $16                  ; $16 -
=$17					KWD_MINUSMINUS = $17             ; $17 --
=$18					KWD_SLASH = $18                  ; $18 /
=$19					KWD_SEMICOLON = $19              ; $19 ;
=$1a					KWD_LESS = $1a                   ; $1a <
=$1b					KWD_LESSLESS = $1b               ; $1b <<
=$1c					KWD_LESSEQUAL = $1c              ; $1c <=
=$1d					KWD_LESSGREATER = $1d            ; $1d <>
=$1e					KWD_EQUAL = $1e                  ; $1e =
=$1f					KWD_GREATER = $1f                ; $1f >
=$20					KWD_GREATEREQUAL = $20           ; $20 >=
=$21					KWD_GREATERGREATER = $21         ; $21 >>
=$22					KWD_AT = $22                     ; $22 @
=$23					KWD_ABS = $23                    ; $23 ABS
=$24					KWD_ALLOC = $24                  ; $24 ALLOC
=$25					KWD_AND = $25                    ; $25 AND
=$26					KWD_ASSERT = $26                 ; $26 ASSERT
=$27					KWD_CPLING = $27                 ; $27 C!
=$28					KWD_CAT = $28                    ; $28 C@
=$29					KWD_DEF = $29                    ; $29 DEF
=$2a					KWD_DROP = $2a                   ; $2a DROP
=$2b					KWD_DUP = $2b                    ; $2b DUP
=$2c					KWD_ELSE = $2c                   ; $2c ELSE
=$2d					KWD_EMPTY = $2d                  ; $2d EMPTY
=$2e					KWD_END = $2e                    ; $2e END
=$2f					KWD_ENDIF = $2f                  ; $2f ENDIF
=$30					KWD_FOR = $30                    ; $30 FOR
=$31					KWD_IF = $31                     ; $31 IF
=$32					KWD_INDEX = $32                  ; $32 INDEX
=$33					KWD_LIST = $33                   ; $33 LIST
=$34					KWD_MOD = $34                    ; $34 MOD
=$35					KWD_NEGATE = $35                 ; $35 NEGATE
=$36					KWD_NEW = $36                    ; $36 NEW
=$37					KWD_NEXT = $37                   ; $37 NEXT
=$38					KWD_NIP = $38                    ; $38 NIP
=$39					KWD_NOT = $39                    ; $39 NOT
=$3a					KWD_OLD = $3a                    ; $3a OLD
=$3b					KWD_OR = $3b                     ; $3b OR
=$3c					KWD_OVER = $3c                   ; $3c OVER
=$3d					KWD_REPEAT = $3d                 ; $3d REPEAT
=$3e					KWD_RUN = $3e                    ; $3e RUN
=$3f					KWD_STACK = $3f                  ; $3f STACK
=$40					KWD_STOP = $40                   ; $40 STOP
=$41					KWD_SWAP = $41                   ; $41 SWAP
=$42					KWD_SYS = $42                    ; $42 SYS
=$43					KWD_UNTIL = $43                  ; $43 UNTIL
=$44					KWD_WPLING = $44                 ; $44 W!
=$45					KWD_WAT = $45                    ; $45 W@
=$46					KWD_XOR = $46                    ; $46 XOR
=$47					KWD_LSQPARENRSQPAREN = $47       ; $47 []
=$48					KWD_HAT = $48                    ; $48 ^
=$49					KWD_CONSTANT_MINUS = $49         ; $49 {-}

;******  Return to file: main.asm


;******  Processing file: system/extern.asm

.a1a7					ExternInitialise:
.a1a7	a9 07		lda #$07			lda 	#$07 						; set colour
.a1a9	8d 86 02	sta $0286			sta 	646
.a1ac	a9 0e		lda #$0e			lda 	#14							; lower case
.a1ae	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1b1	a9 93		lda #$93			lda 	#147 						; clear screen
.a1b3	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1b6	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a1b8	4c d2 a1	jmp $a1d2			jmp 	ExternColour
.a1bb					ExternCheckBreak:
.a1bb	da		phx				phx 								; make sure we keep XY
.a1bc	5a		phy				phy
.a1bd	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a1c0	f0 03		beq $a1c5			beq		_ECBExit 					; stopped
.a1c2	7a		ply				ply 								; restore and exit.
.a1c3	fa		plx				plx
.a1c4	60		rts				rts
.a1c5					_ECBExit:
.a1c5	4c de a4	jmp $a4de			jmp 	WarmStart
.a1c8					ExternPrint:
.a1c8	48		pha				pha
.a1c9	da		phx				phx
.a1ca	5a		phy				phy
.a1cb	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1ce	7a		ply				ply
.a1cf	fa		plx				plx
.a1d0	68		pla				pla
.a1d1	60		rts				rts
.a1d2					ExternColour:
.a1d2	48		pha				pha
.a1d3	da		phx				phx
.a1d4	aa		tax				tax
.a1d5	bd de a1	lda $a1de,x			lda 	_ECTable,x
.a1d8	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a1db	fa		plx				plx
.a1dc	68		pla				pla
.a1dd	60		rts				rts
.a1de					_ECTable:
>a1de	90						.byte 	144
>a1df	1c						.byte 	28
>a1e0	1e						.byte 	30
>a1e1	9e						.byte 	158
>a1e2	1f						.byte 	31
>a1e3	9c						.byte 	156
>a1e4	9f						.byte 	159
>a1e5	05						.byte 	5

;******  Return to file: main.asm


;******  Processing file: system/execute.asm

.a1e6					EXNextLine:
.a1e6	b2 00		lda ($00)			lda 	(codePtr) 					; is it run from the buffer (offset 0)
.a1e8	f0 0f		beq $a1f9			beq 	_EXNLWarmStart
.a1ea	18		clc				clc 								; advance code pointer to next line
.a1eb	65 00		adc $00				adc 	codePtr
.a1ed	85 00		sta $00				sta 	codePtr
.a1ef	90 02		bcc $a1f3			bcc 	_EXNLNoBump
.a1f1	e6 01		inc $01				inc 	codePtr+1
.a1f3					_EXNLNoBump:
.a1f3	a0 03		ldy #$03			ldy 	#3 							; position in that line
.a1f5	b2 00		lda ($00)			lda 	(codePtr) 					; read offset
.a1f7	d0 03		bne $a1fc			bne 	Execute 					; not end of program
.a1f9					_EXNLWarmStart:
.a1f9	4c 27 ab	jmp $ab27			jmp 	System_END
.a1fc					Execute:
.a1fc	ee 22 0a	inc $0a22			inc 	BreakCount 					; break occasionally. too slow otherwise.
.a1ff	d0 03		bne $a204			bne 	_EXNoBreak
.a201	20 bb a1	jsr $a1bb			jsr 	ExternCheckBreak
.a204					_EXNoBreak:
.a204					_EXGetNext:
.a204	b1 00		lda ($00),y			lda 	(codePtr),y 				; load the character
.a206	f0 de		beq $a1e6			beq 	EXNextLine 					; reached end of the line.
.a208	c8		iny				iny 								; advance pointer.
.a209	c9 10		cmp #$10			cmp 	#KWD_SPACE 					; skip spaces
.a20b	f0 f7		beq $a204			beq 	_ExGetNext
.a20d	c9 10		cmp #$10			cmp 	#$10 						; is it 01-0F, which means a string/comment ?
.a20f	90 27		bcc $a238			bcc 	EXStringComment
.a211	c9 80		cmp #$80			cmp 	#$80 						; if it 10-7F, token
.a213	90 0d		bcc $a222			bcc 	EXTokenExecute
.a215	c9 c0		cmp #$c0			cmp 	#$C0 						; is it a numeric constant 80-BF
.a217	90 03		bcc $a21c			bcc 	EXPushConstant
.a219	4c d1 ab	jmp $abd1			jmp 	Identifier 					; it's an identifier C0-FF
.a21c					EXPushConstant:
.a21c	88		dey				dey
.a21d	20 67 a2	jsr $a267			jsr 	ExtractIntegerToTOS 		; extract integer
.a220	80 da		bra $a1fc			bra 	Execute
.a222					EXTokenExecute:
.a222	0a		asl a				asl 	a 							; double token, also clears carry
.a223	da		phx				phx 								; save X, put token x 2 in X
.a224	aa		tax				tax
.a225	bd 13 a1	lda $a113,x			lda 	KeywordVectorTable-$20,x 	; copy vector. The -$20 is because the tokens
.a228	85 04		sta $04				sta 	zTemp0 						; start at $10.
.a22a	bd 14 a1	lda $a114,x			lda 	KeywordVectorTable-$20+1,x
.a22d	85 05		sta $05				sta 	zTemp0+1
.a22f	fa		plx				plx 								; restore X
.a230	20 35 a2	jsr $a235			jsr 	_EXTCall 					; call the routine
.a233	80 c7		bra $a1fc			bra 	Execute
.a235					_EXTCall:
.a235	6c 04 00	jmp ($0004)			jmp 	(zTemp0)
.a238					EXStringComment:
.a238	c9 02		cmp #$02			cmp 	#$02 						; 02 is the token for single quoted string
.a23a	f0 15		beq $a251			beq 	EXStringSkip 				; (comment), so just skip it.
.a23c	e8		inx				inx 								; push Y + 1 + codePtr on the stack
.a23d	98		tya				tya
.a23e	38		sec				sec
.a23f	65 00		adc $00				adc 	codePtr
.a241	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a244	a5 01		lda $01				lda 	codePtr+1
.a246	69 00		adc #$00			adc 	#0
.a248	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a24b	9e 00 0e	stz $0e00,x			stz 	stack2,x 					; clear the upper 2 bytes.
.a24e	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a251					EXStringSkip:
.a251	98		tya				tya 								; the current position in A
.a252	18		clc				clc
.a253	71 00		adc ($00),y			adc 	(codePtr),y					; add the total length
.a255	a8		tay				tay 			 					; and make that the current position.
.a256	88		dey				dey 								; back one because of the initial skip
.a257	80 a3		bra $a1fc			bra 	Execute
.a259					EXShiftTOSRight:
.a259	4a		lsr a				lsr 	a
.a25a	7e 00 0f	ror $0f00,x			ror 	stack3,x
.a25d	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a260	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a263	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a266	60		rts				rts
.a267					ExtractIntegerToTOS:
.a267	b1 00		lda ($00),y			lda 	(codePtr),y
.a269	c8		iny				iny
.a26a	e8		inx				inx 								; make stack space
.a26b	29 3f		and #$3f			and 	#$3F 						; to start with, it's just that value
.a26d	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a270	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a273	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a276	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a279					_EXConstantLoop:
.a279	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next ?
.a27b	29 c0		and #$c0			and 	#$C0 						; in range 80-FF e.g. 10xx xxxx
.a27d	c9 80		cmp #$80			cmp 	#$80
.a27f	d0 2d		bne $a2ae			bne		_EXDone 					; no then exit
.a281	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; put the MSB in A
.a284	48		pha				pha
.a285	bd 00 0e	lda $0e00,x			lda 	stack2,x 					; shift every byte up one, e.g. x 256
.a288	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a28b	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a28e	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a291	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a294	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a297	9e 00 0c	stz $0c00,x			stz 	stack0,x
.a29a	68		pla				pla
.a29b	20 59 a2	jsr $a259			jsr 	EXShiftTOSRight 				; shift the whole A:Top of Stack right twice
.a29e	20 59 a2	jsr $a259			jsr 	EXShiftTOSRight				; which will be x64
.a2a1	b1 00		lda ($00),y			lda 	(codePtr),y 				; get and skip constant shift
.a2a3	c8		iny				iny
.a2a4	29 3f		and #$3f			and 	#$3F
.a2a6	1d 00 0c	ora $0c00,x			ora 	stack0,x 					; or into low byte
.a2a9	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a2ac	80 cb		bra $a279			bra 	_EXConstantLoop
.a2ae					_EXDone:
.a2ae	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/identifier.asm

.a2af					IdentifierSearch:
.a2af	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.a2b1	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a fast var ?
.a2b3	90 12		bcc $a2c7			bcc 	_ISSlow
.a2b5	c9 fa		cmp #$fa			cmp 	#$F9+1
.a2b7	b0 0e		bcs $a2c7			bcs 	_ISSlow
.a2b9	29 1f		and #$1f			and 	#$1F 						; index, then x 4
.a2bb	0a		asl a				asl 	a
.a2bc	0a		asl a				asl		a
.a2bd	85 0e		sta $0e				sta 	idDataAddr					; set up addres
.a2bf	a9 10		lda #$10			lda 	#AZVariables >> 8
.a2c1	85 0f		sta $0f				sta 	idDataAddr+1
.a2c3	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; type
.a2c5	38		sec				sec 								; return with CS.
.a2c6	60		rts				rts
.a2c7					_ISSlow:
.a2c7	20 7b a3	jsr $a37b			jsr 	IdentifierSetupHashPtr 		; set up hash table.
.a2ca	98		tya				tya 								; set (zTemp1) to point to the
.a2cb	18		clc				clc 	 							; identifier to be searched.
.a2cc	65 00		adc $00				adc 	codePtr
.a2ce	85 06		sta $06				sta 	zTemp1
.a2d0	a5 01		lda $01				lda 	codePtr+1
.a2d2	69 00		adc #$00			adc 	#0
.a2d4	85 07		sta $07				sta 	zTemp1+1
.a2d6	5a		phy				phy 								; save Y
.a2d7	b2 04		lda ($04)	_ISLoop:lda 	(zTemp0)					; follow link
.a2d9	48		pha				pha
.a2da	a0 01		ldy #$01			ldy 	#1
.a2dc	b1 04		lda ($04),y			lda 	(zTemp0),y
.a2de	85 05		sta $05				sta 	zTemp0+1
.a2e0	68		pla				pla
.a2e1	85 04		sta $04				sta 	zTemp0
.a2e3	05 05		ora $05				ora 	zTemp0+1 					; if zero, then fail.
.a2e5	f0 2c		beq $a313			beq 	_ISFail
.a2e7	a0 06		ldy #$06			ldy 	#6 							; copy name into zTemp2
.a2e9	b1 04		lda ($04),y			lda 	(zTemp0),y
.a2eb	85 08		sta $08				sta 	zTemp2
.a2ed	c8		iny				iny
.a2ee	b1 04		lda ($04),y			lda 	(zTemp0),y
.a2f0	85 09		sta $09				sta 	zTemp2+1
.a2f2	a0 00		ldy #$00			ldy 	#0 							; compare names at zTemp1/zTemp2
.a2f4					_ISCompare:
.a2f4	b1 06		lda ($06),y			lda 	(zTemp1),y
.a2f6	d1 08		cmp ($08),y			cmp 	(zTemp2),y
.a2f8	d0 dd		bne $a2d7			bne		_ISLoop 					; different ?
.a2fa	c8		iny				iny
.a2fb	c9 e0		cmp #$e0			cmp 	#$E0 						; until end identifiers matched.
.a2fd	90 f5		bcc $a2f4			bcc 	_ISCompare
.a2ff	18		clc				clc 								; set up the data pointer
.a300	a5 04		lda $04				lda 	zTemp0
.a302	69 02		adc #$02			adc 	#2
.a304	85 0e		sta $0e				sta 	idDataAddr
.a306	a5 05		lda $05				lda 	zTemp0+1
.a308	69 00		adc #$00			adc		#0
.a30a	85 0f		sta $0f				sta 	idDataAddr+1
.a30c	a0 09		ldy #$09			ldy 	#9 							; get the type
.a30e	b1 04		lda ($04),y			lda 	(zTemp0),y
.a310	7a		ply				ply
.a311	38		sec				sec
.a312	60		rts				rts
.a313					_ISFail:
.a313	7a		ply				ply
.a314	18		clc				clc
.a315	60		rts				rts
.a316					IdentifierCreate:
.a316	5a		phy				phy 								; save Y
.a317	48		pha				pha 								; save type on stack
.a318	20 7b a3	jsr $a37b			jsr 	IdentifierSetUpHashPtr 		; zTemp0 = address of table.
.a31b	ad 88 10	lda $1088			lda 	VarMemory 					; copy VarMemory to zTemp1
.a31e	85 06		sta $06				sta 	zTemp1
.a320	ad 89 10	lda $1089			lda 	VarMemory+1
.a323	85 07		sta $07				sta 	zTemp1+1
.a325	5a		phy				phy 								; save Y (code offset)
.a326	a0 00		ldy #$00			ldy 	#0 							; copy next link in.
.a328	b1 04		lda ($04),y			lda 	(zTemp0),y 					; +0,+1 is the link.
.a32a	91 06		sta ($06),y			sta 	(zTemp1),y
.a32c	c8		iny				iny
.a32d	b1 04		lda ($04),y			lda 	(zTemp0),y
.a32f	91 06		sta ($06),y			sta 	(zTemp1),y
.a331	c8		iny				iny
.a332					_IDCErase:
.a332	a9 00		lda #$00			lda 	#0
.a334	91 06		sta ($06),y			sta 	(zTemp1),y
.a336	c8		iny				iny
.a337	c0 06		cpy #$06			cpy 	#6
.a339	d0 f7		bne $a332			bne 	_IDCErase
.a33b	68		pla				pla 								; original Y
.a33c	18		clc				clc
.a33d	65 00		adc $00				adc		codePtr 					; address of identifier +6,+7
.a33f	91 06		sta ($06),y			sta 	(zTemp1),y
.a341	c8		iny				iny
.a342	a5 01		lda $01				lda 	codePtr+1
.a344	69 00		adc #$00			adc 	#0
.a346	91 06		sta ($06),y			sta 	(zTemp1),y
.a348	c8		iny				iny
.a349	a9 00		lda #$00			lda 	#0 							; +8 bank (0)
.a34b	91 06		sta ($06),y			sta 	(zTemp1),y
.a34d	68		pla				pla 								; restore type
.a34e	c8		iny				iny
.a34f	91 06		sta ($06),y			sta 	(zTemp1),y 					; store at +9
.a351	c8		iny				iny
.a352	98		tya				tya									; add offset to VarMemory
.a353	18		clc				clc
.a354	6d 88 10	adc $1088			adc 	VarMemory
.a357	8d 88 10	sta $1088			sta 	VarMemory
.a35a	ad 89 10	lda $1089			lda 	VarMemory+1
.a35d	69 00		adc #$00			adc 	#0
.a35f	8d 89 10	sta $1089			sta 	VarMemory+1
.a362	a5 06		lda $06				lda 	zTemp1 						; overwrite hash table entry
.a364	92 04		sta ($04)			sta 	(zTemp0)
.a366	a0 01		ldy #$01			ldy 	#1
.a368	a5 07		lda $07				lda 	zTemp1+1
.a36a	91 04		sta ($04),y			sta 	(zTemp0),y
.a36c	a5 06		lda $06				lda 	zTemp1 						; set up idDataAddr
.a36e	18		clc				clc
.a36f	69 02		adc #$02			adc 	#2
.a371	85 0e		sta $0e				sta 	idDataAddr
.a373	a5 07		lda $07				lda 	zTemp1+1
.a375	69 00		adc #$00			adc 	#0
.a377	85 0f		sta $0f				sta 	idDataAddr+1
.a379	7a		ply				ply 								; restore Y and exit
.a37a	60		rts				rts
.a37b					IdentifierSetUpHashPtr:
.a37b	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first operator
.a37d	29 0f		and #$0f			and 	#(HashTableSize-1)			; convert to a hash index
.a37f	0a		asl a				asl 	a 							; convert to an offset, clc
.a380	69 68		adc #$68			adc 	#(HashTable & $FF)			; set zTemp0 to point to hashTable entry
.a382	85 04		sta $04				sta 	zTemp0
.a384	a9 10		lda #$10			lda 	#(HashTable >> 8) 			; assumes table in one page
.a386	85 05		sta $05				sta 	zTemp0+1
.a388	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/reset.asm

.a389					ResetCodePointer:
.a389	48		pha				pha
.a38a	a9 11		lda #$11			lda 	#ProgramStart >> 8 			; set up line pointer
.a38c	85 01		sta $01				sta 	codePtr+1
.a38e	64 00		stz $00				stz 	codePtr
.a390	a0 03		ldy #$03			ldy 	#3 							; point to first piece of code
.a392	68		pla				pla
.a393	60		rts				rts
.a394					ResetForRun:
.a394	48		pha				pha
.a395	5a		phy				phy
.a396	a2 00		ldx #$00			ldx 	#0 							; erase the hash table
.a398					_RRErase:
.a398	9e 68 10	stz $1068,x			stz		HashTable,x
.a39b	e8		inx				inx
.a39c	e0 20		cpx #$20			cpx 	#HashTableSize * 2
.a39e	d0 f8		bne $a398			bne 	_RRErase
.a3a0	20 89 a3	jsr $a389			jsr 	ResetCodePointer 			; code Pointer to start of program
.a3a3					_RRFindEnd:
.a3a3	b2 00		lda ($00)			lda 	(codePtr)					; at end ?
.a3a5	f0 0b		beq $a3b2			beq 	_RRFoundEnd
.a3a7	18		clc				clc 								; no, add offset to pointer.
.a3a8	65 00		adc $00				adc 	codePtr
.a3aa	85 00		sta $00				sta 	codePtr
.a3ac	90 f5		bcc $a3a3			bcc 	_RRFindEnd
.a3ae	e6 01		inc $01				inc 	codePtr+1
.a3b0	80 f1		bra $a3a3			bra 	_RRFindEnd
.a3b2					_RRFoundEnd:
.a3b2	18		clc				clc 								; add 1 to this, as it points to the last
.a3b3	a5 00		lda $00				lda 	codePtr 					; offset, and store in Variable Memory pointer
.a3b5	69 01		adc #$01			adc 	#1
.a3b7	8d 88 10	sta $1088			sta 	VarMemory
.a3ba	a5 01		lda $01				lda 	codePtr+1
.a3bc	69 00		adc #$00			adc 	#0
.a3be	8d 89 10	sta $1089			sta 	VarMemory+1
.a3c1	a9 60		lda #$60			lda 	#MemoryEnd >> 8
.a3c3	8d 8b 10	sta $108b			sta 	AllocMemory+1
.a3c6	9c 8a 10	stz $108a			stz 	AllocMemory
.a3c9	a9 ff		lda #$ff			lda 	#StructureStack & $FF
.a3cb	85 02		sta $02				sta 	StructSP
.a3cd	a9 0b		lda #$0b			lda 	#StructureStack >> 8
.a3cf	85 03		sta $03				sta 	StructSP+1
.a3d1	a9 ff		lda #$ff			lda 	#$FF 						; put a value that will fail structure tests
.a3d3	92 02		sta ($02)			sta 	(StructSP)
.a3d5	20 dd a3	jsr $a3dd			jsr 	ProcedureScan
.a3d8	a2 00		ldx #$00			ldx 	#0 							; empty the stack
.a3da	7a		ply				ply
.a3db	68		pla				pla
.a3dc	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/scan.asm

.a3dd					ProcedureScan:
.a3dd	20 89 a3	jsr $a389			jsr 	ResetCodePointer 			; reset the code pointer.
.a3e0	b2 00		lda ($00)	_PSMain:lda 	(codePtr)					; check if end
.a3e2	f0 3c		beq $a420			beq 	_PSExit
.a3e4	a0 03		ldy #$03			ldy 	#3 							; start of line
.a3e6					_PSSkipSpace:
.a3e6	b1 00		lda ($00),y			lda 	(codePtr),y 				; skip over spaces
.a3e8	c8		iny				iny
.a3e9	c9 10		cmp #$10			cmp 	#KWD_SPACE
.a3eb	f0 f9		beq $a3e6			beq 	_PSSkipSpace
.a3ed	c9 29		cmp #$29			cmp 	#KWD_DEF 					; first thing is DEF ?
.a3ef	d0 22		bne $a413			bne 	_PSNext
.a3f1					_PSSkipSpace2:
.a3f1	c8		iny				iny 								; skip over def first, any following spaces
.a3f2	b1 00		lda ($00),y			lda 	(codePtr),y
.a3f4	c9 10		cmp #$10			cmp 	#KWD_SPACE
.a3f6	f0 f9		beq $a3f1			beq 	_PSSkipSpace2
.a3f8	a9 50		lda #$50			lda 	#IDT_PROCEDURE 				; create a procedure
.a3fa	20 16 a3	jsr $a316			jsr 	IdentifierCreate
.a3fd					_PSSkipIdentifier:
.a3fd	b1 00		lda ($00),y			lda 	(codePtr),y
.a3ff	c8		iny				iny
.a400	c9 c0		cmp #$c0			cmp 	#$C0
.a402	b0 f9		bcs $a3fd			bcs 	_PSSkipIdentifier
.a404	88		dey				dey 								; undo last, points at first non ID
.a405	98		tya				tya  								; save the address in the data slot.
.a406	18		clc				clc 								; changing Y doesn't matter.
.a407	65 00		adc $00				adc 	codePtr
.a409	92 0e		sta ($0e)			sta 	(idDataAddr)
.a40b	a5 01		lda $01				lda 	codePtr+1
.a40d	69 00		adc #$00			adc 	#0
.a40f	a0 01		ldy #$01			ldy 	#1
.a411	91 0e		sta ($0e),y			sta 	(idDataAddr),y
.a413					_PSNext:
.a413	18		clc				clc 								; go to next
.a414	b2 00		lda ($00)			lda 	(codePtr)
.a416	65 00		adc $00				adc 	codePtr
.a418	85 00		sta $00				sta 	codeptr
.a41a	90 c4		bcc $a3e0			bcc 	_PSMain
.a41c	e6 01		inc $01				inc 	codePtr+1
.a41e	80 c0		bra $a3e0			bra 	_PSMain
.a420					_PSExit:
.a420	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/indexing.asm

.a421					IndexCheck:
.a421	b1 00		lda ($00),y			lda 	(codePtr),y 				; check next character
.a423	c9 47		cmp #$47			cmp 	#KWD_LSQPARENRSQPAREN 		; left/right square bracket ?
.a425	f0 12		beq $a439			beq 	_ICArrayAccess
.a427	29 c0		and #$c0			and 	#$C0 						; constant (e.g. 10xx xxxx)
.a429	c9 80		cmp #$80			cmp 	#$80
.a42b	b0 01		bcs $a42e			bcs 	_ICSubscript
.a42d					_ICExit:
.a42d	60		rts				rts
.a42e					_ICSubscript:
.a42e	b1 00		lda ($00),y			lda 	(codePtr),y
.a430	c8		iny				iny 								; skip over subscript
.a431	29 3f		and #$3f			and 	#$3F 						; lower 6 bits only.
.a433	85 06		sta $06				sta 	zTemp1 						; save in zTemp1
.a435	64 07		stz $07				stz 	zTemp1+1
.a437	80 0c		bra $a445			bra 	_ICAddSubscript 			; double and add to value.
.a439					_ICArrayAccess:
.a439	c8		iny				iny 								; point to next
.a43a	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy TOS to zTemp1
.a43d	85 07		sta $07				sta 	zTemp1+1 					; no point in the rest !
.a43f	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a442	85 06		sta $06				sta 	zTemp1
.a444	ca		dex				dex
.a445					_ICAddSubscript:
.a445	06 06		asl $06				asl 	zTemp1 						; subscript x 4
.a447	26 07		rol $07				rol 	zTemp1+1
.a449	06 06		asl $06				asl 	zTemp1
.a44b	26 07		rol $07				rol 	zTemp1+1
.a44d	5a		phy				phy
.a44e	b2 0e		lda ($0e)			lda 	(idDataAddr)				; check indirecting through 0
.a450	a0 01		ldy #$01			ldy 	#1
.a452	11 0e		ora ($0e),y			ora 	(idDataAddr),y 				; probably means uninitialised
.a454	c8		iny				iny
.a455	11 0e		ora ($0e),y			ora 	(idDataAddr),y
.a457	c8		iny				iny
.a458	11 0e		ora ($0e),y			ora 	(idDataAddr),y
.a45a	f0 17		beq $a473			beq 	_ICZero
.a45c	18		clc				clc									; add zTemp1 to value at (idDataAddr)
.a45d	b2 0e		lda ($0e)			lda 	(idDataAddr)
.a45f	65 06		adc $06				adc 	zTemp1
.a461	48		pha				pha
.a462	a0 01		ldy #$01			ldy 	#1
.a464	b1 0e		lda ($0e),y			lda 	(idDataAddr),y
.a466	65 07		adc $07				adc 	zTemp1+1
.a468	85 0f		sta $0f				sta 	idDataAddr+1 				; write it out
.a46a	68		pla				pla
.a46b	85 0e		sta $0e				sta 	idDataAddr
.a46d	64 10		stz $10				stz 	idDataAddr+2 				; extend to 32 bits
.a46f	64 11		stz $11				stz 	idDataAddr+3
.a471	7a		ply				ply
.a472	60		rts				rts
.a473					_ICZero:
.a473	20 9a a4	jsr $a49a			jsr 	ErrorHandler
>a476	55 4e 49 4e 49 54 49 41				.text 	"UNINITIALISED ARRAY",0
>a47e	4c 49 53 45 44 20 41 52 52 41 59 00

;******  Return to file: main.asm


;******  Processing file: system/error.asm

.a48a					SyntaxError:
.a48a	20 9a a4	jsr $a49a			jsr 	ErrorHandler
>a48d	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>a495	52 52 4f 52 00
.a49a					ErrorHandler:
.a49a	68		pla				pla 								; pop message address
.a49b	85 04		sta $04				sta 	zTemp0
.a49d	68		pla				pla
.a49e	85 05		sta $05				sta 	zTemp0+1
.a4a0	a9 05		lda #$05			lda 	#CTH_ERROR
.a4a2	20 d2 a1	jsr $a1d2			jsr 	ExternColour
.a4a5	a0 01		ldy #$01			ldy 	#1 							; print it
.a4a7					_ErrorPrint:
.a4a7	b1 04		lda ($04),y			lda 	(zTemp0),y
.a4a9	20 c8 a1	jsr $a1c8			jsr		ExternPrint
.a4ac	c8		iny				iny
.a4ad	b1 04		lda ($04),y			lda 	(zTemp0),y
.a4af	d0 f6		bne $a4a7			bne 	_ErrorPrint
.a4b1	a0 01		ldy #$01			ldy 	#1 							; check if line# 0
.a4b3	b1 00		lda ($00),y			lda		(codePtr),y
.a4b5	c8		iny				iny
.a4b6	12 00		ora ($00)			ora 	(codePtr)
.a4b8	f0 1c		beq $a4d6			beq 	_ErrorNoLine 				; if so, skip
.a4ba	a9 20		lda #$20			lda 	#32
.a4bc	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a4bf	a9 40		lda #$40			lda 	#'@'
.a4c1	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a4c4	a9 20		lda #$20			lda 	#32
.a4c6	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a4c9	a0 01		ldy #$01			ldy 	#1 							; load current line into YA
.a4cb	b1 00		lda ($00),y			lda 	(codePtr),y
.a4cd	48		pha				pha
.a4ce	c8		iny				iny
.a4cf	b1 00		lda ($00),y			lda 	(codePtr),y
.a4d1	a8		tay				tay
.a4d2	68		pla				pla
.a4d3	20 e7 a4	jsr $a4e7			jsr 	ErrorPrint16 				; print YA as unsigned 16 bit integer.
.a4d6					_ErrorNoLine:
.a4d6	a9 0d		lda #$0d			lda 	#13							; new line
.a4d8	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a4db	4c de a4	jmp $a4de			jmp 	WarmStart
.a4de					WarmStart:
.a4de	a9 07		lda #$07			lda 	#COL_WHITE
.a4e0	20 d2 a1	jsr $a1d2			jsr 	ExternColour
.a4e3	4c de a4	jmp $a4de			jmp		WarmStart
>a4e6	ff						.byte 	$FF
.a4e7					ErrorPrint16:
.a4e7	da		phx				phx
.a4e8	e8		inx				inx 								; space on stack
.a4e9	9d 00 0c	sta $0c00,x			sta 	stack0,x					; save on TOS
.a4ec	98		tya				tya
.a4ed	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a4f0	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a4f3	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a4f6	20 0c a5	jsr $a50c			jsr 	IntegerToString 			; convert to string.
.a4f9	fa		plx				plx
.a4fa					ErrorPrintIntegerBuffer:
.a4fa	da		phx				phx
.a4fb	a2 00		ldx #$00			ldx 	#0
.a4fd					_EP16Loop:
.a4fd	bd 00 0a	lda $0a00,x			lda 	SBuffer,x
.a500	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a503	e8		inx				inx
.a504	bd 00 0a	lda $0a00,x			lda 	SBuffer,x
.a507	d0 f4		bne $a4fd			bne 	_EP16Loop
.a509	8a		txa				txa
.a50a	fa		plx				plx
.a50b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/inttostr.asm

.a50c					IntegerToString:
.a50c	48		pha				pha
.a50d	5a		phy				phy
.a50e	bd 00 0f	lda $0f00,x			lda 		stack3,x 				; check -ve
.a511	10 08		bpl $a51b			bpl 		_ITSNotMinus
.a513	a9 2d		lda #$2d			lda 		#"-"
.a515	20 ad a5	jsr $a5ad			jsr 		ITSOutputCharacter
.a518	20 95 a7	jsr $a795			jsr 		Unary_Negate
.a51b					_ITSNotMinus:
.a51b	9c 20 0a	stz $0a20			stz 		SBPosition 				; reset string buffer position
.a51e	9c 24 0a	stz $0a24			stz 		NumSuppress 			; clear zero suppression flag
.a521	8a		txa				txa 								; use Y for the integer index.
.a522	a8		tay				tay
.a523	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.a525					_ITSNextSubtractor:
.a525	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.a527	8d 21 0a	sta $0a21			sta 		NumConvCount
.a52a					_ITSSubtract:
.a52a	38		sec				sec
.a52b	b9 00 0c	lda $0c00,y			lda 		stack0,y 			; subtract number and push on stack
.a52e	fd 89 a5	sbc $a589,x			sbc 		_ITSSubtractors+0,x 	; only update if actually can subtract it.
.a531	48		pha				pha
.a532	b9 00 0d	lda $0d00,y			lda 		stack1,y
.a535	fd 8a a5	sbc $a58a,x			sbc 		_ITSSubtractors+1,x
.a538	48		pha				pha
.a539	b9 00 0e	lda $0e00,y			lda 		stack2,y
.a53c	fd 8b a5	sbc $a58b,x			sbc 		_ITSSubtractors+2,x
.a53f	48		pha				pha
.a540	b9 00 0f	lda $0f00,y			lda 		stack3,y
.a543	fd 8c a5	sbc $a58c,x			sbc 		_ITSSubtractors+3,x
.a546	90 14		bcc $a55c			bcc 		_ITSCantSubtract 		; if CC, then gone too far, can't subtract
.a548	99 00 0f	sta $0f00,y			sta 		stack3,y 		; save subtract off stack as it's okay
.a54b	68		pla				pla
.a54c	99 00 0e	sta $0e00,y			sta 		stack2,y
.a54f	68		pla				pla
.a550	99 00 0d	sta $0d00,y			sta 		stack1,y
.a553	68		pla				pla
.a554	99 00 0c	sta $0c00,y			sta 		stack0,y
.a557	ee 21 0a	inc $0a21			inc 		NumConvCount 			; bump count.
.a55a	80 ce		bra $a52a			bra 		_ITSSubtract 			; go round again.
.a55c					_ITSCantSubtract:
.a55c	68		pla				pla 								; throw away interim answers
.a55d	68		pla				pla 								; (the subtraction that failed)
.a55e	68		pla				pla
.a55f	ad 21 0a	lda $0a21			lda 		NumConvCount 			; if not zero then no suppression check
.a562	c9 30		cmp #$30			cmp 		#"0"
.a564	d0 05		bne $a56b			bne 		_ITSOutputDigit
.a566	ad 24 0a	lda $0a24			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.a569	f0 09		beq $a574			beq	 		_ITSGoNextSubtractor
.a56b					_ITSOutputDigit:
.a56b	ce 24 0a	dec $0a24			dec 		NumSuppress 			; suppression check will be non-zero from now on.
.a56e	ad 21 0a	lda $0a21			lda 		NumConvCount 			; count of subtractions
.a571	20 ad a5	jsr $a5ad			jsr 		ITSOutputCharacter 		; output it.
.a574					_ITSGoNextSubtractor:
.a574	e8		inx				inx 								; next dword in subtractor table.
.a575	e8		inx				inx
.a576	e8		inx				inx
.a577	e8		inx				inx
.a578	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.a57a	d0 a9		bne $a525			bne 		_ITSNextSubtractor 		; do all the subtractors.
.a57c	98		tya				tya 								; X is back as the mantissa index
.a57d	aa		tax				tax
.a57e	bd 00 0c	lda $0c00,x			lda 		stack0,x 		; and the last digit is left.
.a581	09 30		ora #$30			ora 		#"0"
.a583	20 ad a5	jsr $a5ad			jsr 		ITSOutputCharacter
.a586	7a		ply				ply 								; and exit
.a587	68		pla				pla
.a588	60		rts				rts
.a589					_ITSSubtractors:
>a589	00 ca 9a 3b					.dword 		1000000000
>a58d	00 e1 f5 05					.dword 		100000000
>a591	80 96 98 00					.dword 		10000000
>a595	40 42 0f 00					.dword 		1000000
>a599	a0 86 01 00					.dword 		100000
>a59d	10 27 00 00					.dword 		10000
>a5a1	e8 03 00 00					.dword 		1000
>a5a5	64 00 00 00					.dword 		100
>a5a9	0a 00 00 00					.dword 		10
.a5ad					_ITSSubtractorsEnd:
.a5ad					ITSOutputCharacter:
.a5ad	48		pha				pha
.a5ae	da		phx				phx
.a5af	ae 20 0a	ldx $0a20			ldx 	SBPosition 					; save digit
.a5b2	9d 00 0a	sta $0a00,x			sta 	SBuffer,x
.a5b5	9e 01 0a	stz $0a01,x			stz 	SBuffer+1,x
.a5b8	ee 20 0a	inc $0a20			inc 	SBPosition					; bump pointer.
.a5bb	fa		plx				plx
.a5bc	68		pla				pla
.a5bd	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/intfromstr.asm

.a5be					IntFromString:
.a5be	a0 00		ldy #$00			ldy 	#0 							; from (zTemp0)
.a5c0	e8		inx				inx 								; space on stack
.a5c1	20 f4 a5	jsr $a5f4			jsr 	IFSClearTOS
.a5c4					_IFSLoop:
.a5c4	b1 04		lda ($04),y			lda 	(zTemp0),y 					; get next
.a5c6	c9 30		cmp #$30			cmp 	#"0"						; validate it as range 0-9
.a5c8	90 24		bcc $a5ee			bcc 	_IFSExit
.a5ca	c9 3a		cmp #$3a			cmp 	#"9"+1
.a5cc	b0 20		bcs $a5ee			bcs 	_IFSExit
.a5ce	20 06 a7	jsr $a706			jsr 	Stack_Dup 					; duplicate tos
.a5d1	20 0d a8	jsr $a80d			jsr 	Unary_Shl	 				; x 2
.a5d4	20 0d a8	jsr $a80d			jsr 	Unary_Shl 					; x 4
.a5d7	20 d8 a8	jsr $a8d8			jsr 	Stack_Add 					; x 5
.a5da	20 0d a8	jsr $a80d			jsr 	Unary_Shl 					; x 10
.a5dd	e8		inx				inx  								; create space next up
.a5de	20 f4 a5	jsr $a5f4			jsr 	IFSClearTOS
.a5e1	b1 04		lda ($04),y			lda 	(zTemp0),y 					; add digit
.a5e3	29 0f		and #$0f			and 	#15
.a5e5	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; tos is new add
.a5e8	20 d8 a8	jsr $a8d8			jsr 	Stack_Add 					; add to tos
.a5eb	c8		iny				iny
.a5ec	80 d6		bra $a5c4			bra 	_IFSLoop
.a5ee					_IFSExit:
.a5ee	98		tya				tya
.a5ef	38		sec				sec
.a5f0	f0 01		beq $a5f3			beq 	_IFSSkipFail
.a5f2	18		clc				clc
.a5f3					_IFSSkipFail:
.a5f3	60		rts				rts
.a5f4					IFSClearTOS:
.a5f4	9e 00 0c	stz $0c00,x			stz		stack0,x
.a5f7	9e 00 0d	stz $0d00,x			stz		stack1,x
.a5fa	9e 00 0e	stz $0e00,x			stz		stack2,x
.a5fd	9e 00 0f	stz $0f00,x			stz		stack3,x
.a600	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/list.asm

.a601					Cmd_List:
.a601	20 89 a3	jsr $a389			jsr 	ResetCodePointer 			; back to the beginning
.a604	64 08		stz $08				stz 	zTemp2						; clear the lowest-number
.a606	64 09		stz $09				stz 	zTemp2+1
.a608	e0 00		cpx #$00			cpx 	#0 							; stack empty ?
.a60a	f0 0b		beq $a617			beq 	_CLINone
.a60c	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; use tos as start line
.a60f	85 08		sta $08				sta 	zTemp2
.a611	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a614	95 09		sta $09,x			sta 	zTemp2+1,x
.a616	ca		dex				dex 								; and pop the tos
.a617					_CLINone:
.a617	a9 10		lda #$10			lda 	#16 						; list this many lines
.a619	85 06		sta $06				sta 	zTemp1
.a61b					_CLILoop
.a61b	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.a61d	f0 24		beq $a643			beq 	_CLIEnd
.a61f	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.a621	38		sec				sec
.a622	b1 00		lda ($00),y			lda 	(codePtr),y
.a624	e5 08		sbc $08				sbc 	zTemp2
.a626	c8		iny				iny
.a627	b1 00		lda ($00),y			lda 	(codePtr),y
.a629	e5 09		sbc $09				sbc 	zTemp2+1
.a62b	90 09		bcc $a636			bcc 	_CLISkip
.a62d	da		phx				phx
.a62e	20 46 a6	jsr $a646			jsr 	ListCurrent 				; list the line.
.a631	fa		plx				plx
.a632	c6 06		dec $06				dec 	zTemp1 						; done all lines
.a634	f0 0d		beq $a643			beq 	_CLIEnd
.a636					_CLISkip:
.a636	18		clc				clc
.a637	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.a639	65 00		adc $00				adc 	codePtr
.a63b	85 00		sta $00				sta 	codePtr
.a63d	90 dc		bcc $a61b			bcc 	_CLILoop
.a63f	e6 01		inc $01				inc 	codePtr+1
.a641	80 d8		bra $a61b			bra 	_CLILoop
.a643					_CLIEnd:
.a643	4c de a4	jmp $a4de			jmp 	WarmStart
.a646					ListCurrent:
.a646	a9 06		lda #$06			lda 	#CTH_NUMBER
.a648	20 d2 a1	jsr $a1d2			jsr 	ExternColour 				; set colour
.a64b	a0 01		ldy #$01			ldy 	#1							; print line#
.a64d	b1 00		lda ($00),y			lda 	(codePtr),y
.a64f	48		pha				pha
.a650	c8		iny				iny
.a651	b1 00		lda ($00),y			lda 	(codePtr),y
.a653	a8		tay				tay
.a654	68		pla				pla
.a655	20 e7 a4	jsr $a4e7			jsr 	ErrorPrint16
.a658	a8		tay				tay
.a659					_LCPadOut:
.a659	a9 20		lda #$20			lda 	#' '
.a65b	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a65e	c8		iny				iny
.a65f	c0 06		cpy #$06			cpy 	#6
.a661	d0 f6		bne $a659			bne 	_LCPadOut
.a663	a0 03		ldy #$03			ldy 	#3 							; start here
.a665	b1 00		lda ($00),y	_LCLoop:lda 	(codePtr),y 				; get first
.a667	30 38		bmi $a6a1			bmi 	_LCIdentConst 				; identifier or constant
.a669	d0 05		bne $a670			bne 	_LCStringToken
.a66b	a9 0d		lda #$0d			lda 	#13
.a66d	4c c8 a1	jmp $a1c8			jmp 	ExternPrint
.a670					_LCStringToken:
.a670	c9 10		cmp #$10			cmp 	#$10 						; if < 10 it's a string.
.a672	90 06		bcc $a67a			bcc		_LCString
.a674	20 cf a6	jsr $a6cf			jsr 	ListPrintToken
.a677	c8		iny				iny 								; advance pointer
.a678	80 eb		bra $a665			bra 	_LCLoop 					; go round again.
.a67a					_LCString:
.a67a	4a		lsr a				lsr 	a 							; CS if 1 (string) CC if 2 (comment)
.a67b	a9 05		lda #$05			lda 	#CTH_STRING 				; decide on colour.
.a67d	a2 22		ldx #$22			ldx 	#'"'
.a67f	b0 04		bcs $a685			bcs 	_LCSSkip
.a681	a9 07		lda #$07			lda 	#CTH_COMMENT
.a683	a2 27		ldx #$27			ldx 	#"'"
.a685					_LCSSkip:
.a685	20 d2 a1	jsr $a1d2			jsr 	ExternColour 				; set colour
.a688	8a		txa				txa
.a689	48		pha				pha 								; save end quote on stack.
.a68a	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a68d	c8		iny				iny 								; skip type size
.a68e	c8		iny				iny
.a68f					_LCSPrint:
.a68f	b1 00		lda ($00),y			lda 	(codePtr),y
.a691	c8		iny				iny
.a692	c9 00		cmp #$00			cmp 	#0 							; 0 is end
.a694	f0 05		beq $a69b			beq 	_LCSExit
.a696	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a699	80 f4		bra $a68f			bra 	_LCSPrint
.a69b					_LCSExit:
.a69b	68		pla				pla
.a69c	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a69f	80 c4		bra $a665			bra 	_LCLoop
.a6a1					_LCIdentConst:
.a6a1	c9 c0		cmp #$c0			cmp 	#$C0						; check if constant
.a6a3	90 18		bcc $a6bd			bcc 	_LCConstant
.a6a5	a9 03		lda #$03			lda 	#CTH_IDENT 					; set colour
.a6a7	20 d2 a1	jsr $a1d2			jsr 	ExternColour
.a6aa	b1 00		lda ($00),y			lda 	(codePtr),y 				; read
.a6ac	c8		iny				iny
.a6ad	29 1f		and #$1f			and 	#$1F 						; convert
.a6af	18		clc				clc
.a6b0	69 41		adc #$41			adc 	#'A'
.a6b2	c9 60		cmp #$60			cmp 	#'A'+31 					; handle '.'
.a6b4	d0 02		bne $a6b8			bne 	_LCCNotDot
.a6b6	a9 2e		lda #$2e			lda 	#'.'
.a6b8					_LCCNotDot:
.a6b8	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a6bb	80 a8		bra $a665			bra 	_LCLoop
.a6bd					_LCConstant:
.a6bd	a9 06		lda #$06			lda 	#CTH_NUMBER 				; number colour
.a6bf	20 d2 a1	jsr $a1d2			jsr 	ExternColour
.a6c2	a2 fe		ldx #$fe			ldx 	#254 						; use the topmost stack element
.a6c4	20 67 a2	jsr $a267			jsr 	ExtractIntegerToTOS 		; so there is a very rare case
.a6c7	20 0c a5	jsr $a50c			jsr 	IntegerToString 			; this could corrupt stack if full :)
.a6ca	20 fa a4	jsr $a4fa			jsr 	ErrorPrintIntegerBuffer
.a6cd	80 96		bra $a665			bra 	_LCLoop
.a6cf					ListPrintToken:
.a6cf	5a		phy				phy
.a6d0	48		pha				pha 								; token colour
.a6d1	a9 02		lda #$02			lda 	#CTH_TOKEN
.a6d3	20 d2 a1	jsr $a1d2			jsr 	ExternColour
.a6d6	fa		plx				plx
.a6d7	a9 58		lda #$58			lda 	#KeywordText & $FF
.a6d9	85 04		sta $04				sta 	zTemp0
.a6db	a9 a0		lda #$a0			lda 	#KeywordText >> 8
.a6dd	85 05		sta $05				sta 	zTemp0+1
.a6df					_LPTLoop:
.a6df	e0 10		cpx #$10			cpx 	#$10 						; first token is $10
.a6e1	f0 0e		beq $a6f1			beq 	_LPTFound
.a6e3	ca		dex				dex
.a6e4	b2 04		lda ($04)			lda 	(zTemp0)
.a6e6	38		sec				sec									; add 1, it's length+name
.a6e7	65 04		adc $04				adc 	zTemp0
.a6e9	85 04		sta $04				sta 	zTemp0
.a6eb	90 f2		bcc $a6df			bcc 	_LPTLoop
.a6ed	e6 05		inc $05				inc 	zTemp0+1
.a6ef	80 ee		bra $a6df			bra 	_LPTLoop
.a6f1					_LPTFound:
.a6f1	a0 01		ldy #$01			ldy 	#1 							; start here.
.a6f3					_LPTShow:
.a6f3	b1 04		lda ($04),y			lda 	(zTemp0),y 					; get character
.a6f5	c9 20		cmp #$20			cmp 	#32 						; < 32, length, so exit
.a6f7	90 06		bcc $a6ff			bcc 	_LPTExit
.a6f9	c8		iny				iny
.a6fa	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.a6fd	80 f4		bra $a6f3			bra 	_LPTShow
.a6ff					_LPTExit:
.a6ff	7a		ply				ply
.a700	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/stack.asm

.a701					Stack_Empty:
.a701	a2 00		ldx #$00			ldx 	#0
.a703	60		rts				rts
.a704					Stack_Drop:
.a704	ca		dex				dex
.a705	60		rts				rts
.a706					Stack_Dup:
.a706	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy to next up
.a709	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.a70c	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a70f	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.a712	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a715	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.a718	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a71b	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.a71e	e8		inx				inx 								; bump stack pointer
.a71f	60		rts				rts
.a720					Stack_Nip:
.a720	bd 00 0c	lda $0c00,x			lda 	stack0,x	 				; copy top to 2nd
.a723	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.a726	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a729	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.a72c	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a72f	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.a732	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a735	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.a738	ca		dex				dex 								; drop tos
.a739	60		rts				rts
.a73a					Stack_Over:
.a73a	bd ff 0b	lda $0bff,x			lda 	stack0-1,x				; copy to next up
.a73d	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.a740	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a743	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.a746	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a749	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.a74c	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a74f	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.a752	e8		inx				inx 							; bump stack pointer
.a753	60		rts				rts
.a754					Stack_Swap:
.a754	5a		phy				phy
.a755	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a758	a8		tay				tay
.a759	bd ff 0b	lda $0bff,x			lda 	stack0-1,x
.a75c	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a75f	98		tya				tya
.a760	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.a763	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a766	a8		tay				tay
.a767	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a76a	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a76d	98		tya				tya
.a76e	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.a771	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a774	a8		tay				tay
.a775	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a778	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a77b	98		tya				tya
.a77c	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.a77f	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a782	a8		tay				tay
.a783	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a786	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a789	98		tya				tya
.a78a	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.a78d	7a		ply				ply
.a78e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/unary.asm

.a78f					Unary_Absolute:
.a78f	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a792	30 01		bmi $a795			bmi 	Unary_Negate
.a794	60		rts				rts
.a795					Unary_Negate:
.a795					Unary_Const_Minus:
.a795	38		sec				sec
.a796	a9 00		lda #$00			lda		#0
.a798	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.a79b	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a79e	a9 00		lda #$00			lda		#0
.a7a0	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.a7a3	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a7a6	a9 00		lda #$00			lda		#0
.a7a8	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.a7ab	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a7ae	a9 00		lda #$00			lda		#0
.a7b0	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.a7b3	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a7b6	60		rts				rts
.a7b7					Unary_Not:
.a7b7	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a7ba	49 ff		eor #$ff			eor 	#$FF
.a7bc	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a7bf	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a7c2	49 ff		eor #$ff			eor 	#$FF
.a7c4	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a7c7	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a7ca	49 ff		eor #$ff			eor 	#$FF
.a7cc	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a7cf	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a7d2	49 ff		eor #$ff			eor 	#$FF
.a7d4	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a7d7	60		rts				rts
.a7d8					Unary_Increment:
.a7d8	fe 00 0c	inc $0c00,x			inc 	stack0,x
.a7db	d0 0d		bne $a7ea			bne 	_UIExit
.a7dd	fe 00 0d	inc $0d00,x			inc 	stack1,x
.a7e0	d0 08		bne $a7ea			bne 	_UIExit
.a7e2	fe 00 0e	inc $0e00,x			inc 	stack2,x
.a7e5	d0 03		bne $a7ea			bne 	_UIExit
.a7e7	fe 00 0f	inc $0f00,x			inc 	stack3,x
.a7ea					_UIExit:
.a7ea	60		rts				rts
.a7eb					Unary_Decrement:
.a7eb	38		sec				sec
.a7ec	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a7ef	e9 01		sbc #$01			sbc 	#1
.a7f1	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a7f4	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a7f7	e9 00		sbc #$00			sbc 	#0
.a7f9	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a7fc	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a7ff	e9 00		sbc #$00			sbc 	#0
.a801	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a804	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a807	e9 00		sbc #$00			sbc 	#0
.a809	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a80c	60		rts				rts
.a80d					Unary_Shl:
.a80d	1e 00 0c	asl $0c00,x			asl 	stack0,x
.a810	3e 00 0d	rol $0d00,x			rol 	stack1,x
.a813	3e 00 0e	rol $0e00,x			rol 	stack2,x
.a816	3e 00 0f	rol $0f00,x			rol 	stack3,x
.a819	60		rts				rts
.a81a					Unary_Shr:
.a81a	5e 00 0f	lsr $0f00,x			lsr 	stack3,x
.a81d	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a820	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a823	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a826	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/memory.asm

.a827					Mem_Peek:
.a827	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a82a	85 04		sta $04				sta 	zTemp0
.a82c	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a82f	85 05		sta $05				sta 	zTemp0+1
.a831	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a833	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a836	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a839	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a83c	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a83f	60		rts				rts
.a840					Mem_WPeek:
.a840	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a843	85 04		sta $04				sta 	zTemp0
.a845	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a848	85 05		sta $05				sta 	zTemp0+1
.a84a	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a84c	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a84f	5a		phy				phy 								; read msb
.a850	a0 01		ldy #$01			ldy 	#1
.a852	b1 04		lda ($04),y			lda 	(zTemp0),y
.a854	7a		ply				ply
.a855	9d 00 0d	sta $0d00,x			sta 	stack1,x 				; write to stack
.a858	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a85b	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a85e	60		rts				rts
.a85f					Mem_DPeek:
.a85f	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a862	85 04		sta $04				sta 	zTemp0
.a864	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a867	85 05		sta $05				sta 	zTemp0+1
.a869	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a86b	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a86e	5a		phy				phy 								; read msb
.a86f	a0 01		ldy #$01			ldy 	#1
.a871	b1 04		lda ($04),y			lda 	(zTemp0),y
.a873	9d 00 0d	sta $0d00,x			sta 	stack1,x 					; write to stack
.a876	c8		iny				iny
.a877	b1 04		lda ($04),y			lda 	(zTemp0),y
.a879	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a87c	c8		iny				iny
.a87d	b1 04		lda ($04),y			lda 	(zTemp0),y
.a87f	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a882	7a		ply				ply
.a883	60		rts				rts
.a884					Mem_Poke:
.a884	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a887	85 04		sta $04				sta 	zTemp0
.a889	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a88c	85 05		sta $05				sta 	zTemp0+1
.a88e	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.a891	92 04		sta ($04)			sta 	(zTemp0)
.a893	ca		dex				dex
.a894	ca		dex				dex
.a895	60		rts				rts
.a896					Mem_WPoke:
.a896	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a899	85 04		sta $04				sta 	zTemp0
.a89b	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a89e	85 05		sta $05				sta 	zTemp0+1
.a8a0	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.a8a3	92 04		sta ($04)			sta 	(zTemp0)
.a8a5	5a		phy				phy
.a8a6	a0 01		ldy #$01			ldy 	#1
.a8a8	bd ff 0e	lda $0eff,x			lda 	stack3-1,x 				; byte to write
.a8ab	91 04		sta ($04),y			sta 	(zTemp0),y
.a8ad	7a		ply				ply
.a8ae	ca		dex				dex
.a8af	ca		dex				dex
.a8b0	60		rts				rts
.a8b1					Mem_DPoke:
.a8b1	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a8b4	85 04		sta $04				sta 	zTemp0
.a8b6	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a8b9	85 05		sta $05				sta 	zTemp0+1
.a8bb	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 					; byte to write
.a8be	92 04		sta ($04)			sta 	(zTemp0)
.a8c0	5a		phy				phy
.a8c1	a0 01		ldy #$01			ldy 	#1
.a8c3	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a8c6	91 04		sta ($04),y			sta 	(zTemp0),y
.a8c8	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a8cb	c8		iny				iny
.a8cc	91 04		sta ($04),y			sta 	(zTemp0),y
.a8ce	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a8d1	c8		iny				iny
.a8d2	91 04		sta ($04),y			sta 	(zTemp0),y
.a8d4	7a		ply				ply
.a8d5	ca		dex				dex
.a8d6	ca		dex				dex
.a8d7	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/binary.asm

.a8d8					Stack_Add:
.a8d8	ca		dex				dex
.a8d9					Stack_Add_No_Dex:
.a8d9	18		clc				clc
.a8da	bd 00 0c	lda $0c00,x			lda		stack0,x
.a8dd	7d 01 0c	adc $0c01,x			adc 	stack0+1,x
.a8e0	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a8e3	bd 00 0d	lda $0d00,x			lda		stack1,x
.a8e6	7d 01 0d	adc $0d01,x			adc 	stack1+1,x
.a8e9	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a8ec	bd 00 0e	lda $0e00,x			lda		stack2,x
.a8ef	7d 01 0e	adc $0e01,x			adc 	stack2+1,x
.a8f2	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a8f5	bd 00 0f	lda $0f00,x			lda		stack3,x
.a8f8	7d 01 0f	adc $0f01,x			adc 	stack3+1,x
.a8fb	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a8fe	60		rts				rts
.a8ff					Stack_Sub:
.a8ff	ca		dex				dex
.a900	38		sec				sec
.a901	bd 00 0c	lda $0c00,x			lda		stack0,x
.a904	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.a907	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a90a	bd 00 0d	lda $0d00,x			lda		stack1,x
.a90d	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.a910	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a913	bd 00 0e	lda $0e00,x			lda		stack2,x
.a916	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.a919	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a91c	bd 00 0f	lda $0f00,x			lda		stack3,x
.a91f	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.a922	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a925	60		rts				rts
.a926					Stack_And:
.a926	ca		dex				dex
.a927	bd 00 0c	lda $0c00,x			lda		stack0,x
.a92a	3d 01 0c	and $0c01,x			and		stack0+1,x
.a92d	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a930	bd 00 0d	lda $0d00,x			lda		stack1,x
.a933	3d 01 0d	and $0d01,x			and 	stack1+1,x
.a936	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a939	bd 00 0e	lda $0e00,x			lda		stack2,x
.a93c	3d 01 0e	and $0e01,x			and 	stack2+1,x
.a93f	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a942	bd 00 0f	lda $0f00,x			lda		stack3,x
.a945	3d 01 0f	and $0f01,x			and 	stack3+1,x
.a948	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a94b	60		rts				rts
.a94c					Stack_Xor:
.a94c	ca		dex				dex
.a94d	bd 00 0c	lda $0c00,x			lda		stack0,x
.a950	5d 01 0c	eor $0c01,x			eor		stack0+1,x
.a953	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a956	bd 00 0d	lda $0d00,x			lda		stack1,x
.a959	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.a95c	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a95f	bd 00 0e	lda $0e00,x			lda		stack2,x
.a962	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.a965	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a968	bd 00 0f	lda $0f00,x			lda		stack3,x
.a96b	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.a96e	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a971	60		rts				rts
.a972					Stack_Or:
.a972	ca		dex				dex
.a973	bd 00 0c	lda $0c00,x			lda		stack0,x
.a976	1d 01 0c	ora $0c01,x			ora		stack0+1,x
.a979	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a97c	bd 00 0d	lda $0d00,x			lda		stack1,x
.a97f	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.a982	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a985	bd 00 0e	lda $0e00,x			lda		stack2,x
.a988	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.a98b	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a98e	bd 00 0f	lda $0f00,x			lda		stack3,x
.a991	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.a994	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a997	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/multiply.asm

.a998					MulInteger32:
.a998	ca		dex				dex
.a999	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy +0 to workspace
.a99c	85 0a		sta $0a				sta 	zLTemp1
.a99e	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a9a1	85 0b		sta $0b				sta 	zLTemp1+1
.a9a3	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a9a6	85 0c		sta $0c				sta 	zLTemp1+2
.a9a8	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a9ab	85 0d		sta $0d				sta 	zLTemp1+3
.a9ad	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; zero +0, where the result goes.
.a9b0	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a9b3	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a9b6	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a9b9					_BFMMultiply:
.a9b9	a5 0a		lda $0a				lda 	zLTemp1 					; get LSBit of 8-11
.a9bb	29 01		and #$01			and 	#1
.a9bd	f0 03		beq $a9c2			beq 	_BFMNoAdd
.a9bf	20 d9 a8	jsr $a8d9			jsr 	Stack_Add_No_Dex 			; co-opt this code
.a9c2					_BFMNoAdd:
.a9c2	1e 01 0c	asl $0c01,x			asl 	stack0+1,x 					; shift +4 left
.a9c5	3e 01 0d	rol $0d01,x			rol 	stack1+1,x
.a9c8	3e 01 0e	rol $0e01,x			rol 	stack2+1,x
.a9cb	3e 01 0f	rol $0f01,x			rol 	stack3+1,x
.a9ce	46 0d		lsr $0d				lsr 	zLTemp1+3 					; shift +8 right
.a9d0	66 0c		ror $0c				ror 	zLTemp1+2
.a9d2	66 0b		ror $0b				ror 	zLTemp1+1
.a9d4	66 0a		ror $0a				ror 	zLTemp1
.a9d6	a5 0a		lda $0a				lda 	zLTemp1 					; continue if +8 is nonzero
.a9d8	05 0b		ora $0b				ora 	zLTemp1+1
.a9da	05 0c		ora $0c				ora 	zLTemp1+2
.a9dc	05 0d		ora $0d				ora 	zLTemp1+3
.a9de	d0 d9		bne $a9b9			bne 	_BFMMultiply
.a9e0	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/divide.asm

.a9e1					DivInteger32:
.a9e1	ca		dex				dex
.a9e2	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check for division by zero.
.a9e5	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.a9e8	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.a9eb	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.a9ee	d0 14		bne $aa04			bne 	_BFDOkay
.a9f0	20 9a a4	jsr $a49a			jsr 	ErrorHandler
>a9f3	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>a9fb	20 42 59 20 5a 45 52 4f 00
.aa04					_BFDOkay:
.aa04	64 0a		stz $0a				stz 	zLTemp1 					; Q/Dividend/Left in +0
.aa06	64 0b		stz $0b				stz 	zLTemp1+1 					; M/Divisor/Right in +4
.aa08	64 0c		stz $0c				stz 	zLTemp1+2
.aa0a	64 0d		stz $0d				stz 	zLTemp1+3
.aa0c	9c 23 0a	stz $0a23			stz 	SignCount 					; Count of signs.
.aa0f	20 6a aa	jsr $aa6a			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.aa12	e8		inx				inx
.aa13	20 6a aa	jsr $aa6a			jsr 	CheckIntegerNegate
.aa16	ca		dex				dex
.aa17	5a		phy				phy 								; Y is the counter
.aa18	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.aa1a					_BFDLoop:
.aa1a	1e 00 0c	asl $0c00,x			asl 	stack0,x 					; shift AQ left.
.aa1d	3e 00 0d	rol $0d00,x			rol 	stack1,x
.aa20	3e 00 0e	rol $0e00,x			rol 	stack2,x
.aa23	3e 00 0f	rol $0f00,x			rol 	stack3,x
.aa26	26 0a		rol $0a				rol 	zLTemp1
.aa28	26 0b		rol $0b				rol 	zLTemp1+1
.aa2a	26 0c		rol $0c				rol 	zLTemp1+2
.aa2c	26 0d		rol $0d				rol 	zLTemp1+3
.aa2e	38		sec				sec
.aa2f	a5 0a		lda $0a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.aa31	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.aa34	48		pha				pha
.aa35	a5 0b		lda $0b				lda 	zLTemp1+1
.aa37	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.aa3a	48		pha				pha
.aa3b	a5 0c		lda $0c				lda 	zLTemp1+2
.aa3d	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.aa40	48		pha				pha
.aa41	a5 0d		lda $0d				lda 	zLTemp1+3
.aa43	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.aa46	90 15		bcc $aa5d			bcc 	_BFDNoAdd
.aa48	85 0d		sta $0d				sta 	zLTemp1+3 					; update A
.aa4a	68		pla				pla
.aa4b	85 0c		sta $0c				sta 	zLTemp1+2
.aa4d	68		pla				pla
.aa4e	85 0b		sta $0b				sta 	zLTemp1+1
.aa50	68		pla				pla
.aa51	85 0a		sta $0a				sta 	zLTemp1+0
.aa53	bd 00 0c	lda $0c00,x			lda 	stack0,x 			; set Q bit 1.
.aa56	09 01		ora #$01			ora 	#1
.aa58	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aa5b	80 03		bra $aa60			bra 	_BFDNext
.aa5d					_BFDNoAdd:
.aa5d	68		pla				pla 								; Throw away the intermediate calculations
.aa5e	68		pla				pla
.aa5f	68		pla				pla
.aa60					_BFDNext:
.aa60	88		dey				dey
.aa61	d0 b7		bne $aa1a			bne 	_BFDLoop
.aa63	7a		ply				ply 								; restore Y
.aa64	4e 23 0a	lsr $0a23			lsr 	SignCount 					; if sign count odd,
.aa67	b0 07		bcs $aa70			bcs		IntegerNegateAlways 		; negate the result
.aa69	60		rts				rts
.aa6a					CheckIntegerNegate:
.aa6a	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; is it -ve = MSB set ?
.aa6d	30 01		bmi $aa70			bmi 	IntegerNegateAlways 		; if so negate it
.aa6f	60		rts				rts
.aa70					IntegerNegateAlways:
.aa70	ee 23 0a	inc $0a23			inc 	SignCount 					; bump the count of signs
.aa73	4c 95 a7	jmp $a795			jmp 	Unary_Negate
.aa76					ModInteger32:
.aa76	20 e1 a9	jsr $a9e1			jsr 	DivInteger32
.aa79	a5 0a		lda $0a				lda 	zLTemp1
.aa7b	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aa7e	a5 0b		lda $0b				lda 	zLTemp1+1
.aa80	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aa83	a5 0c		lda $0c				lda 	zLTemp1+2
.aa85	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aa88	a5 0d		lda $0d				lda 	zLTemp1+3
.aa8a	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aa8d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/compare.asm

.aa8e					Comp_Equal:
.aa8e	38		sec				sec
.aa8f	80 01		bra $aa92			bra 	Comp_CheckEqual
.aa91					Comp_NotEqual:
.aa91	18		clc				clc
.aa92					Comp_CheckEqual:
.aa92	08		php				php
.aa93	ca		dex				dex
.aa94	bd 00 0c	lda $0c00,x			lda		stack0,x
.aa97	5d 01 0c	eor $0c01,x			eor 	stack0+1,x
.aa9a	d0 16		bne $aab2			bne 	_CCENonZero
.aa9c	bd 00 0d	lda $0d00,x			lda		stack1,x
.aa9f	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.aaa2	d0 0e		bne $aab2			bne 	_CCENonZero
.aaa4	bd 00 0e	lda $0e00,x			lda		stack2,x
.aaa7	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.aaaa	d0 06		bne $aab2			bne 	_CCENonZero
.aaac	bd 00 0f	lda $0f00,x			lda		stack3,x
.aaaf	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.aab2					_CCENonZero:
.aab2	f0 02		beq $aab6			beq 	_CCENotSet
.aab4	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.aab6					_CCENotSet:
.aab6					CompCheckFlip:
.aab6	28		plp				plp 								; if carry set, we want $FF if equal
.aab7	90 02		bcc $aabb			bcc 	CompReturn
.aab9	49 ff		eor #$ff			eor 	#$FF
.aabb					CompReturn:
.aabb	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; save result on stack.
.aabe	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aac1	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aac4	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aac7	60		rts				rts
.aac8					Comp_Less:
.aac8	18		clc				clc
.aac9	80 01		bra $aacc			bra 	Comp_LessCont
.aacb					Comp_GreaterEqual:
.aacb	38		sec				sec
.aacc					Comp_LessCont:
.aacc	08		php				php
.aacd	ca		dex				dex
.aace	38		sec				sec
.aacf	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; do a subtraction w/o storing the result
.aad2	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.aad5	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aad8	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.aadb	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aade	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.aae1	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aae4	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.aae7	50 02		bvc $aaeb			bvc 	_CLNoFlip 					; unsigned -> signed
.aae9	49 80		eor #$80			eor 	#$80
.aaeb					_CLNoFlip:
.aaeb	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.aaed	f0 c7		beq $aab6			beq 	CompCheckFlip
.aaef	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.aaf1	80 c3		bra $aab6			bra 	CompCheckFlip
.aaf3					Comp_LessEqual:
.aaf3	38		sec				sec
.aaf4	80 01		bra $aaf7			bra 	Comp_LessEqualCont
.aaf6					Comp_Greater:
.aaf6	18		clc				clc
.aaf7					Comp_LessEqualCont:
.aaf7	08		php				php
.aaf8	ca		dex				dex
.aaf9	38		sec				sec
.aafa	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; do a subtraction w/o storing the result, backwards
.aafd	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.ab00	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.ab03	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.ab06	bd 01 0e	lda $0e01,x			lda 	stack2+1,x
.ab09	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.ab0c	bd 01 0f	lda $0f01,x			lda 	stack3+1,x
.ab0f	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.ab12	50 02		bvc $ab16			bvc 	_CLENoFlip 					; unsigned -> signed
.ab14	49 80		eor #$80			eor 	#$80
.ab16					_CLENoFlip:
.ab16	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.ab18	f0 9c		beq $aab6			beq 	CompCheckFlip
.ab1a	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.ab1c	80 98		bra $aab6			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: miscellany/system.asm

.ab1e					System_RUN:
.ab1e	20 94 a3	jsr $a394			jsr		ResetForRun 				; clear vars, stacks etc.
.ab21	20 89 a3	jsr $a389			jsr 	ResetCodePointer 			; point to first thing to do.
.ab24	4c fc a1	jmp $a1fc			jmp 	Execute						; and run
.ab27					System_END:
>ab27	ff						.byte 	$FF
.ab28	4c de a4	jmp $a4de			jmp 	WarmStart
.ab2b					System_STOP:
.ab2b	4c ff ff	jmp $ffff			jmp 	$FFFF
.ab2e	20 9a a4	jsr $a49a			jsr 	ErrorHandler
>ab31	53 54 4f 50 00					.text 	"STOP",0
.ab36					System_Assert:
.ab36	ca		dex				dex
.ab37	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.ab3a	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.ab3d	1d 02 0d	ora $0d02,x			ora 	stack1+2,x
.ab40	1d 03 0d	ora $0d03,x			ora 	stack1+3,x
.ab43	d0 0a		bne $ab4f			bne 	_SAOkay
.ab45	20 9a a4	jsr $a49a			jsr 	ErrorHandler
>ab48	41 53 53 45 52 54 00				.text 	"ASSERT",0
.ab4f	60		rts		_SAOkay:rts
.ab50					System_New:
.ab50	9c 00 11	stz $1100			stz 	ProgramStart 				; zero the first offset, erases.
.ab53	20 94 a3	jsr $a394			jsr		ResetForRun 				; clear vars, stacks etc.
.ab56	60		rts				rts
.ab57					System_Old:
.ab57	20 89 a3	jsr $a389			jsr 	ResetCodePointer 			; start of first line.
.ab5a					_SOFindZero:
.ab5a	b1 00		lda ($00),y			lda 	(codePtr),y 				; look for trailing $00
.ab5c	f0 15		beq $ab73			beq 	_SOFoundEnd
.ab5e	c8		iny				iny
.ab5f	d0 f9		bne $ab5a			bne 	_SOFindZero
.ab61	20 9a a4	jsr $a49a			jsr 	ErrorHandler
>ab64	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER",0
>ab6c	45 43 4f 56 45 52 00
.ab73					_SOFoundEnd:
.ab73	c8		iny				iny 								; update the offset
.ab74	8c 00 11	sty $1100			sty 	ProgramStart
.ab77	20 94 a3	jsr $a394			jsr 	ResetForRun 				; redo all stacks etc.
.ab7a	60		rts				rts
.ab7b					System_Sys:
.ab7b	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy and drop call address
.ab7e	85 04		sta $04				sta 	zTemp0
.ab80	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab83	85 05		sta $05				sta 	zTemp0+1
.ab85	ca		dex				dex
.ab86	da		phx				phx
.ab87	5a		phy				phy
.ab88	ad 00 10	lda $1000			lda 	AZVariables+('A'-'A')*4		; load AXY
.ab8b	ae 5c 10	ldx $105c			ldx 	AZVariables+('X'-'A')*4
.ab8e	ac 60 10	ldy $1060			ldy 	AZVariables+('Y'-'A')*4
.ab91	20 a0 ab	jsr $aba0			jsr 	_SSCall 					; effectively jsr (zTemp)
.ab94	8d 00 10	sta $1000			sta 	AZVariables+('A'-'A')*4 	; store AXY
.ab97	8e 5c 10	stx $105c			stx 	AZVariables+('X'-'A')*4
.ab9a	8c 60 10	sty $1060			sty 	AZVariables+('Y'-'A')*4
.ab9d	7a		ply				ply
.ab9e	fa		plx				plx
.ab9f	60		rts				rts
.aba0	6c 04 00	jmp ($0004)	_SSCall:jmp 	(zTemp0)
.aba3					System_Stack:
.aba3	da		phx				phx 								; save stack
.aba4	5a		phy				phy
.aba5	86 08		stx $08				stx 	zTemp2 						; save old TOS
.aba7	a9 5b		lda #$5b			lda 	#"["
.aba9	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.abac	e0 00		cpx #$00			cpx 	#0 							; empty
.abae	f0 14		beq $abc4			beq 	_SSEnd
.abb0	a2 01		ldx #$01			ldx 	#1 							; start here
.abb2					_SSLoop:
.abb2	20 0c a5	jsr $a50c			jsr 	IntegerToString 			; print TOS
.abb5	20 fa a4	jsr $a4fa			jsr 	ErrorPrintIntegerBuffer
.abb8	e4 08		cpx $08				cpx 	zTemp2 						; done TOS exit
.abba	f0 08		beq $abc4			beq 	_SSEnd
.abbc	e8		inx				inx	 								; advance pointer print ,
.abbd	a9 2c		lda #$2c			lda 	#','
.abbf	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.abc2	80 ee		bra $abb2			bra 	_SSLoop
.abc4					_SSEnd:
.abc4	a9 5d		lda #$5d			lda 	#"]"						; finish off.
.abc6	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.abc9	a9 0d		lda #$0d			lda 	#13
.abcb	20 c8 a1	jsr $a1c8			jsr 	ExternPrint
.abce	7a		ply				ply
.abcf	fa		plx				plx
.abd0	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/variables.asm

.abd1					Identifier:
.abd1	88		dey				dey 								; wind back to identifier start
.abd2	20 af a2	jsr $a2af			jsr 	IdentifierSearch 			; try to find it.
.abd5	90 2d		bcc $ac04			bcc 	_IDUnknown 					; not known, give up.
.abd7	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.abd9	d0 3d		bne $ac18			bne 	IDTypeError
.abdb	c8		iny		_IDSkip:iny
.abdc	b1 00		lda ($00),y			lda 	(codePtr),y
.abde	c9 c0		cmp #$c0			cmp 	#$C0
.abe0	b0 f9		bcs $abdb			bcs 	_IDSkip
.abe2	20 21 a4	jsr $a421			jsr 	IndexCheck 					; check index/subscript
.abe5	5a		phy				phy
.abe6	e8		inx				inx 								; make space on stack
.abe7	a0 00		ldy #$00			ldy 	#0 							; copy it back
.abe9	b1 0e		lda ($0e),y			lda 	(idDataAddr),y
.abeb	9d 00 0c	sta $0c00,x			sta 	stack0,x
.abee	c8		iny				iny
.abef	b1 0e		lda ($0e),y			lda 	(idDataAddr),y
.abf1	9d 00 0d	sta $0d00,x			sta 	stack1,x
.abf4	c8		iny				iny
.abf5	b1 0e		lda ($0e),y			lda 	(idDataAddr),y
.abf7	9d 00 0e	sta $0e00,x			sta 	stack2,x
.abfa	c8		iny				iny
.abfb	b1 0e		lda ($0e),y			lda 	(idDataAddr),y
.abfd	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac00	7a		ply				ply
.ac01	4c fc a1	jmp $a1fc			jmp 	Execute
.ac04					_IDUnknown:
.ac04	20 9a a4	jsr $a49a			jsr 	ErrorHandler
>ac07	55 4e 4b 4e 4f 57 4e 20				.text 	"UNKNOWN VARIABLE",0
>ac0f	56 41 52 49 41 42 4c 45 00
.ac18					IDTypeError:
.ac18	20 9a a4	jsr $a49a			jsr 	ErrorHandler
>ac1b	4d 49 53 53 49 4e 47 20				.text 	"MISSING VARIABLE",0
>ac23	56 41 52 49 41 42 4c 45 00
.ac2c					WriteVariable:
.ac2c	b1 00		lda ($00),y			lda 	(codePtr),y 				; check variable
.ac2e	c9 c0		cmp #$c0			cmp 	#$C0
.ac30	90 e6		bcc $ac18			bcc 	IDTypeError
.ac32	20 af a2	jsr $a2af			jsr 	IdentifierSearch 			; does it exist
.ac35	90 06		bcc $ac3d			bcc 	_WVNoIdentifier
.ac37	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.ac39	f0 12		beq $ac4d			beq 	_WVWriteTOS 				; if so write TOS to it.
.ac3b	80 db		bra $ac18			bra 	IDTypeError 				; not, then can't do anything.
.ac3d					_WVNoIdentifier:
.ac3d	5a		phy				phy 								; get current line number
.ac3e	a0 01		ldy #$01			ldy 	#1
.ac40	b1 00		lda ($00),y			lda 	(codePtr),y
.ac42	c8		iny				iny
.ac43	11 00		ora ($00),y			ora 	(codePtr),y
.ac45	7a		ply				ply
.ac46	f0 2d		beq $ac75			beq 	_WVCantCreate 				; if zero (command line) no new vars
.ac48	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; create identifier
.ac4a	20 16 a3	jsr $a316			jsr 	IdentifierCreate 			; try to find it
.ac4d					_WVWriteTOS:
.ac4d	88		dey				dey 								; skip over identifier.
.ac4e					_WVSkipIdentifier:
.ac4e	c8		iny				iny
.ac4f	b1 00		lda ($00),y			lda 	(codePtr),y
.ac51	c9 c0		cmp #$c0			cmp 	#$C0
.ac53	b0 f9		bcs $ac4e			bcs 	_WVSkipIdentifier
.ac55	20 21 a4	jsr $a421			jsr 	IndexCheck 					; check index/subscript
.ac58	5a		phy				phy									; copy TOS in
.ac59	a0 00		ldy #$00			ldy 	#0
.ac5b	bd 00 0c	lda $0c00,x			lda 	stack0,x
.ac5e	91 0e		sta ($0e),y			sta 	(idDataAddr),y
.ac60	c8		iny				iny
.ac61	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ac64	91 0e		sta ($0e),y			sta 	(idDataAddr),y
.ac66	c8		iny				iny
.ac67	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ac6a	91 0e		sta ($0e),y			sta 	(idDataAddr),y
.ac6c	c8		iny				iny
.ac6d	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ac70	91 0e		sta ($0e),y			sta 	(idDataAddr),y
.ac72	7a		ply				ply
.ac73	ca		dex				dex 								; drop
.ac74	60		rts				rts									; go back and execute again.
.ac75					_WVCantCreate:
.ac75	20 9a a4	jsr $a49a			jsr 	ErrorHandler
>ac78	43 41 4e 4e 4f 54 20 43				.text 	"CANNOT CREATE VARIABLE",0
>ac80	52 45 41 54 45 20 56 41 52 49 41 42 4c 45 00

;******  Return to file: main.asm


;******  Processing file: structures/fornext.asm

.ac8f					Command_For:
.ac8f	20 57 ad	jsr $ad57			jsr 	StructPushCurrent 			; push current on the stack.
.ac92	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check zero
.ac95	1d 00 0d	ora $0d00,x			ora 	stack1,x
.ac98	1d 00 0e	ora $0e00,x			ora 	stack2,x
.ac9b	1d 00 0f	ora $0f00,x			ora 	stack3,x
.ac9e	f0 34		beq $acd4			beq 	_CFZero
.aca0	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; push 1's complement of index on
.aca3	49 ff		eor #$ff			eor 	#$FF 						; structure stack.
.aca5	c6 02		dec $02				dec 	StructSP
.aca7	92 02		sta ($02)			sta 	(StructSP)
.aca9	bd 00 0e	lda $0e00,x			lda 	stack2,x
.acac	49 ff		eor #$ff			eor 	#$FF
.acae	c6 02		dec $02				dec 	StructSP
.acb0	92 02		sta ($02)			sta 	(StructSP)
.acb2	bd 00 0d	lda $0d00,x			lda 	stack1,x
.acb5	49 ff		eor #$ff			eor 	#$FF
.acb7	c6 02		dec $02				dec 	StructSP
.acb9	92 02		sta ($02)			sta 	(StructSP)
.acbb	bd 00 0c	lda $0c00,x			lda 	stack0,x
.acbe	49 ff		eor #$ff			eor 	#$FF
.acc0	c6 02		dec $02				dec 	StructSP
.acc2	92 02		sta ($02)			sta 	(StructSP)
.acc4	ca		dex				dex 								; pop stack value
.acc5	a9 46		lda #$46			lda 	#STM_FOR 					; push FOR marker
.acc7	c6 02		dec $02				dec 	StructSP
.acc9	92 02		sta ($02)			sta 	(StructSP)
.accb	a5 02		lda $02				lda 	StructSP 					; copy current so it can access it.
.accd	85 10		sta $10				sta 	ForAddr
.accf	a5 03		lda $03				lda 	StructSP+1
.acd1	85 11		sta $11				sta 	ForAddr+1
.acd3	60		rts				rts
.acd4					_CFZero:
.acd4	20 9a a4	jsr $a49a			jsr 	ErrorHandler
>acd7	46 4f 52 20 43 4f 55 4e				.text 	"FOR COUNT ZERO",0
>acdf	54 20 5a 45 52 4f 00
.ace6					Command_Next:
.ace6	b2 02		lda ($02)			lda 	(StructSP)					; check it's FOR.
.ace8	c9 46		cmp #$46			cmp 	#STM_FOR
.acea	d0 30		bne $ad1c			bne 	_CNNoFor
.acec	5a		phy				phy
.aced	a0 00		ldy #$00			ldy 	#0
.acef					_CNIncrement:
.acef	c8		iny				iny
.acf0	b1 02		lda ($02),y			lda 	(StructSP),y 				; increment the index
.acf2	1a		inc a				inc 	a
.acf3	91 02		sta ($02),y			sta 	(StructSP),y
.acf5	f0 f8		beq $acef			beq		_CNIncrement 				; carry out.
.acf7	a0 01		ldy #$01			ldy 	#1 							; now and all the counts together
.acf9	b1 02		lda ($02),y			lda 	(StructSP),y 				; on the last time round they
.acfb	c8		iny				iny 								; will all be $FF
.acfc	31 02		and ($02),y			and 	(StructSP),y
.acfe	c8		iny				iny
.acff	31 02		and ($02),y			and 	(StructSP),y
.ad01	c8		iny				iny
.ad02	31 02		and ($02),y			and 	(StructSP),y
.ad04	7a		ply				ply 								; restore Y
.ad05	1a		inc a				inc 	a 							; so this will be zero last time round
.ad06	d0 06		bne $ad0e			bne 	_CNLoop 					; loop back if non-zero
.ad08	a9 09		lda #$09			lda 	#9 							; pop 9 elements off structure stack.
.ad0a	20 51 ad	jsr $ad51			jsr 	StructPopCount
.ad0d	60		rts				rts
.ad0e					_CNLoop:
.ad0e	a5 02		lda $02				lda 	StructSP 					; copy current so it can access it.
.ad10	85 10		sta $10				sta 	ForAddr
.ad12	a5 03		lda $03				lda 	StructSP+1
.ad14	85 11		sta $11				sta 	ForAddr+1
.ad16	a0 05		ldy #$05			ldy 	#5 							; restore the position
.ad18	20 6f ad	jsr $ad6f			jsr 	StructPopCurrent
.ad1b	60		rts				rts
.ad1c					_CNNoFor:
.ad1c	20 9a a4	jsr $a49a			jsr 	ErrorHandler
>ad1f	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>ad27	46 4f 52 00
.ad2b					Command_Index:
.ad2b	5a		phy				phy
.ad2c	a0 01		ldy #$01			ldy 	#1 							; get the stack position of
.ad2e	e8		inx				inx
.ad2f	38		sec				sec
.ad30	a9 fe		lda #$fe			lda 	#$FE
.ad32	f1 10		sbc ($10),y			sbc 	(ForAddr),y
.ad34	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ad37	c8		iny				iny
.ad38	a9 ff		lda #$ff			lda 	#$FF
.ad3a	f1 10		sbc ($10),y			sbc 	(ForAddr),y
.ad3c	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ad3f	c8		iny				iny
.ad40	a9 ff		lda #$ff			lda 	#$FF
.ad42	f1 10		sbc ($10),y			sbc 	(ForAddr),y
.ad44	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ad47	c8		iny				iny
.ad48	a9 ff		lda #$ff			lda 	#$FF
.ad4a	f1 10		sbc ($10),y			sbc 	(ForAddr),y
.ad4c	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ad4f	7a		ply				ply
.ad50	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: structures/structures.asm

.ad51					StructPopCount:
.ad51	18		clc				clc
.ad52	65 02		adc $02				adc 	StructSP
.ad54	85 02		sta $02				sta 	StructSP
.ad56	60		rts				rts
.ad57					StructPushCurrent:
.ad57	a9 00		lda #$00			lda 	#0							; push bank
.ad59	c6 02		dec $02				dec 	StructSP
.ad5b	92 02		sta ($02)			sta 	(StructSP)
.ad5d	98		tya				tya									; y Offset
.ad5e	c6 02		dec $02				dec 	StructSP
.ad60	92 02		sta ($02)			sta 	(StructSP)
.ad62	a5 01		lda $01				lda 	codePtr+1 					; codeptr high
.ad64	c6 02		dec $02				dec 	StructSP
.ad66	92 02		sta ($02)			sta 	(StructSP)
.ad68	a5 00		lda $00				lda 	codePtr 					; codeptr low
.ad6a	c6 02		dec $02				dec 	StructSP
.ad6c	92 02		sta ($02)			sta 	(StructSP)
.ad6e	60		rts				rts
.ad6f					StructPopCurrent:
.ad6f	b1 02		lda ($02),y			lda 	(StructSP),y 				; codeptr low
.ad71	85 00		sta $00				sta 	codePtr
.ad73	c8		iny				iny
.ad74	b1 02		lda ($02),y			lda 	(StructSP),y 				; codeptr high
.ad76	85 01		sta $01				sta 	codePtr+1
.ad78	c8		iny				iny
.ad79	b1 02		lda ($02),y			lda 	(StructSP),y				; y offset
.ad7b	a8		tay				tay
.ad7c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/testcode.inc

>1100	26 64 00 02 07 6c 69 73			.byte $26,$64,$00,$02,$07,$6c,$69,$73,$74,$00,$10,$01,$09,$53,$54,$52,$49,$4e,$47,$00,$10,$02,$0e,$34,$32,$43,$4f,$4d,$4d,$45,$4e,$54,$2a,$2a,$00,$10,$8c,$00,$08,$6e,$00,$84,$ad,$9a,$87,$00,$05,$78,$00,$aa,$00,$0d,$82,$00,$8c,$10,$93,$10,$14,$10,$3f,$10,$33,$00,$05,$8c,$00,$40,$00
>1108	74 00 10 01 09 53 54 52 49 4e 47 00 10 02 0e 34
>1118	32 43 4f 4d 4d 45 4e 54 2a 2a 00 10 8c 00 08 6e
>1128	00 84 ad 9a 87 00 05 78 00 aa 00 0d 82 00 8c 10
>1138	93 10 14 10 3f 10 33 00 05 8c 00 40 00

;******  Return to file: main.asm

>1145	00						.byte 	0

;******  End of listing
