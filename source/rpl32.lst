
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -D debug=2 -q -c -o rpl32.prg -L rpl32.lst main.asm
; Fri Oct 11 16:08:51 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					debug=2

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; build the interpreter here
=$0c00					StackAddress = $0C00 						; 1k of stack space (256 x 32 bits)
=$1000					MemoryStart = $1000 						; system memory starts here
=$9f00					MemoryEnd = $9F00 							; and ends here.
=$0bff					StructureStack = $0BFF 						; structure stack (works down to $xx00)
=$0800					ExtDataArea = $0800 						; space where non zp data goes
=$0900					InputBuffer = $0900 						; Input Buffer
=$0a00					TokeniseBuffer = $0A00						; Tokenising buffer
=16					HashTableSize = 16 							; hash tables to search.
>0010					CodePtr: 		.word ? 					; code pointer
>0012					StructSP: 		.word ?						; structure stack pointer
>0014					zTemp0:			.word ?						; temporary words
>0016					zTemp1: 		.word ?
>0018					zTemp2: 		.word ?
>001a					zTemp3: 		.word ?
>001c					zTemp4:			.word ?
>001e					zLTemp1:		.dword ?					; temporary longs
>0022					idDataAddr:		.word ? 					; data address.
>0800					SBuffer:		.fill 32 					; string buffer
>0820					SBPosition:		.byte ? 					; position in String Buffer
>0821					NumConvCount:	.byte ? 					; used in int to string
>0822					breakCount:		.byte ? 					; used to stop break firing every execution.
>0823					SignCount:		.byte ?						; sign count for divide
>0824					NumSuppress:	.byte ? 					; zero suppression flag
>0825					IFSHexFlag:		.byte ? 					; $FF if hex, $00 if dec
>0826					ReturnDefZero: 	.byte ? 					; non-zero if undefined idents -> 0
>1000					AZVariables:	.fill	26*4 				; 26 x 4 byte variables, which are A-Z
>1068					HashTable: 		.fill 	HashTableSize * 2 	; n x 2 links for the hash tables.
>1088	00 00				VarMemory:		.word 	0 					; next free byte available for VARIABLES (going up)
>108a	00 00				AllocMemory: 	.word 	0 					; last free byte availabel for ALLOC (going down)
=4352					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0c00					stack0 = StackAddress
=3328					stack1 = StackAddress+256
=3584					stack2 = StackAddress+512
=3840					stack3 = StackAddress+768
="V"					IDT_VARIABLE = 'V'							; type markers for the information store.
="P"					IDT_PROCEDURE = 'P'							; standard procedure (e.g. in code)
="C"					IDT_CODEPROC = 'C'							; machine language procedure.
="F"					STM_FOR = 'F'								; structure markers (for/next)
="C"					STM_CALL = 'C'								; call & return  (& ;)
="R"					STM_REPEAT = 'R'							; repeat & until
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=8					COL_RVS = 8
=5					CTH_ERROR = COL_MAGENTA
=7					CTH_TOKEN = COL_WHITE
=3					CTH_IDENT = COL_YELLOW
=10					CTH_COMMENT = COL_GREEN|COL_RVS
=9					CTH_LCOMMENT = COL_RED|COL_RVS
=5					CTH_STRING = COL_MAGENTA
=6					CTH_NUMBER = COL_CYAN
=5					CTH_LINENO = COL_MAGENTA
=147					SCM_CLS = 147 								; clear screen

;******  Return to file: main.asm


;******  Processing file: macro.asm


;******  Return to file: main.asm

.0f00	4c 00 a0	jmp $a000			jmp 	Start
.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 82 a2	jsr $a282			jsr 	ExternInitialise 			; interface setup
.a006	a2 00		ldx #$00			ldx 	#0 							; display boot message
.a008					_Display:
.a008	bd a4 a0	lda $a0a4,x			lda 	BootMessage,x
.a00b	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a00e	e8		inx				inx
.a00f	bd a4 a0	lda $a0a4,x			lda 	BootMessage,x
.a012	d0 f4		bne $a008			bne 	_Display
.a014	a9 00		lda #$00			lda 	#(MemoryEnd-ProgramStart) & $FF
.a016	a0 8e		ldy #$8e			ldy 	#(MemoryEnd-ProgramStart) >>8
.a018	a2 00		ldx #$00			ldx 	#0
.a01a	20 40 a6	jsr $a640			jsr 	ErrorPrint16
.a01d	a2 00		ldx #$00			ldx 	#0 							; clear extended data area
.a01f	9e 00 08	stz $0800,x	_ClearX:stz 	ExtDataArea,x 				; this is so any library data
.a022	e8		inx				inx 								; is zeroed on start up.
.a023	d0 fa		bne $a01f			bne 	_ClearX
.a025	ee 26 08	inc $0826			inc 	ReturnDefZero
.a028	a9 0d		lda #$0d			lda 	#13
.a02a	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a02d	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a030	a9 9f		lda #$9f			lda 	#MemoryEnd >> 8 			; set top of memory address.
.a032	8d 8b 10	sta $108b			sta 	AllocMemory+1
.a035	9c 8a 10	stz $108a			stz 	AllocMemory
.a038	20 4d a5	jsr $a54d			jsr 	ResetForRun
.a03b	20 42 a5	jsr $a542			jsr 	ResetCodePointer
.a03e					WarmStart:
.a03e	a9 06		lda #$06			lda 	#COL_CYAN
.a040	20 af a2	jsr $a2af			jsr 	ExternColour
.a043	a9 4f		lda #$4f			lda 	#"O"
.a045	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a048	a9 4b		lda #$4b			lda 	#"K"
.a04a	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a04d	a9 0d		lda #$0d			lda 	#13
.a04f	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a052					NewCommand:
.a052	8a		txa				txa
.a053	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack colour
.a055	9a		txs				txs
.a056	aa		tax				tax
.a057	a9 07		lda #$07			lda 	#COL_WHITE
.a059	20 af a2	jsr $a2af			jsr 	ExternColour
.a05c	20 d7 a2	jsr $a2d7			jsr 	ExternInput 				; input text
.a05f	a9 00		lda #$00			lda 	#InputBuffer & $FF 			; codePtr = input buffer
.a061	85 10		sta $10				sta 	codePtr
.a063	a9 09		lda #$09			lda 	#InputBuffer >> 8
.a065	85 11		sta $11				sta 	codePtr+1
.a067	a9 03		lda #$03			lda 	#(TokeniseBuffer+3) & $FF 	; zTemp1 is set up as a fake line
.a069	85 16		sta $16				sta 	zTemp1 						; with line number 0 by being
.a06b	a9 0a		lda #$0a			lda 	#(TokeniseBuffer+3) >> 8 	; prefixed with three zeros
.a06d	85 17		sta $17				sta 	zTemp1+1
.a06f	9c 00 0a	stz $0a00			stz 	TokeniseBuffer+0			; put in those three zeroes
.a072	9c 01 0a	stz $0a01			stz		TokeniseBuffer+1
.a075	9c 02 0a	stz $0a02			stz 	TokeniseBuffer+2
.a078	20 b0 a7	jsr $a7b0			jsr 	Tokenise
.a07b	a0 00		ldy #$00			ldy 	#0 							; see what's at the start re numbers
.a07d					SkipSpaces:
.a07d	b9 00 09	lda $0900,y			lda 	InputBuffer,y
.a080	c8		iny				iny
.a081	c9 20		cmp #$20			cmp 	#' '
.a083	f0 f8		beq $a07d			beq 	SkipSpaces
.a085	c9 30		cmp #$30			cmp 	#'0'
.a087	90 0e		bcc $a097			bcc 	ExecuteCLI
.a089	c9 3a		cmp #$3a			cmp 	#'9'+1
.a08b	b0 0a		bcs $a097			bcs 	ExecuteCLI
.a08d	ad 00 09	lda $0900			lda 	InputBuffer
.a090	c9 20		cmp #$20			cmp 	#' '
.a092	f0 03		beq $a097			beq 	ExecuteCLI
.a094	4c 21 a9	jmp $a921			jmp		EditProgram
.a097					ExecuteCLI:
.a097	a9 00		lda #$00			lda 	#TokeniseBuffer & 255 		; set tokenise buffer as faux line
.a099	85 10		sta $10				sta 	codePtr
.a09b	a9 0a		lda #$0a			lda 	#TokeniseBuffer >> 8
.a09d	85 11		sta $11				sta 	codePtr+1
.a09f	a0 03		ldy #$03			ldy 	#3
.a0a1	4c 88 a3	jmp $a388			jmp 	Execute 					; and run it
.a0a4					BootMessage:

;******  Processing file: generated/bootmessage.inc

>a0a4	2a 2a 2a 2a 20 52 50 4c			.byte $2a,$2a,$2a,$2a,$20,$52,$50,$4c,$2f,$33,$32,$20,$49,$4e,$54,$45,$52,$50,$52,$45,$54,$45,$52,$20,$2a,$2a,$2a,$2a,$0d,$0d,$57,$52,$49,$54,$54,$45,$4e,$20,$42,$59,$20,$50,$41,$55,$4c,$20,$52,$4f,$42,$53,$4f,$4e,$20,$32,$30,$31,$39,$0d,$0d,$42,$55,$49,$4c,$44,$3a,$31,$30,$20,$44,$41,$54,$45,$3a,$31,$31,$2d,$4f,$43,$54,$2d,$32,$30,$31,$39,$0d,$0d,$4d,$45,$4d,$4f,$52,$59,$20,$41,$56,$41,$49,$4c,$41,$42,$4c,$45,$20,$00
>a0ac	2f 33 32 20 49 4e 54 45 52 50 52 45 54 45 52 20
>a0bc	2a 2a 2a 2a 0d 0d 57 52 49 54 54 45 4e 20 42 59
>a0cc	20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32 30 31
>a0dc	39 0d 0d 42 55 49 4c 44 3a 31 30 20 44 41 54 45
>a0ec	3a 31 31 2d 4f 43 54 2d 32 30 31 39 0d 0d 4d 45
>a0fc	4d 4f 52 59 20 41 56 41 49 4c 41 42 4c 45 20 00

;******  Return to file: main.asm


;******  Processing file: generated/tables.inc

.a10c					KeywordText:
>a10c	01 21					.byte $01,$21                          ; $10 !
>a10e	01 2a					.byte $01,$2a                          ; $11 *
>a110	01 2b					.byte $01,$2b                          ; $12 +
>a112	02 2b 2b				.byte $02,$2b,$2b                      ; $13 ++
>a115	01 2d					.byte $01,$2d                          ; $14 -
>a117	02 2d 2d				.byte $02,$2d,$2d                      ; $15 --
>a11a	01 2e					.byte $01,$2e                          ; $16 .
>a11c	01 2f					.byte $01,$2f                          ; $17 /
>a11e	01 3b					.byte $01,$3b                          ; $18 ;
>a120	01 3c					.byte $01,$3c                          ; $19 <
>a122	02 3c 3c				.byte $02,$3c,$3c                      ; $1a <<
>a125	02 3c 3d				.byte $02,$3c,$3d                      ; $1b <=
>a128	02 3c 3e				.byte $02,$3c,$3e                      ; $1c <>
>a12b	01 3d					.byte $01,$3d                          ; $1d =
>a12d	01 3e					.byte $01,$3e                          ; $1e >
>a12f	02 3e 3d				.byte $02,$3e,$3d                      ; $1f >=
>a132	02 3e 3e				.byte $02,$3e,$3e                      ; $20 >>
>a135	01 40					.byte $01,$40                          ; $21 @
>a137	03 41 42 53				.byte $03,$41,$42,$53                  ; $22 ABS
>a13b	05 41 4c 4c 4f 43			.byte $05,$41,$4c,$4c,$4f,$43          ; $23 ALLOC
>a141	03 41 4e 44				.byte $03,$41,$4e,$44                  ; $24 AND
>a145	06 41 53 53 45 52 54			.byte $06,$41,$53,$53,$45,$52,$54      ; $25 ASSERT
>a14c	02 43 21				.byte $02,$43,$21                      ; $26 C!
>a14f	02 43 40				.byte $02,$43,$40                      ; $27 C@
>a152	03 43 4c 52				.byte $03,$43,$4c,$52                  ; $28 CLR
>a156	03 44 45 46				.byte $03,$44,$45,$46                  ; $29 DEF
>a15a	04 44 52 4f 50				.byte $04,$44,$52,$4f,$50              ; $2a DROP
>a15f	03 44 55 50				.byte $03,$44,$55,$50                  ; $2b DUP
>a163	04 45 4c 53 45				.byte $04,$45,$4c,$53,$45              ; $2c ELSE
>a168	03 45 4e 44				.byte $03,$45,$4e,$44                  ; $2d END
>a16c	05 45 4e 44 49 46			.byte $05,$45,$4e,$44,$49,$46          ; $2e ENDIF
>a172	03 46 4f 52				.byte $03,$46,$4f,$52                  ; $2f FOR
>a176	02 49 46				.byte $02,$49,$46                      ; $30 IF
>a179	05 49 4e 44 45 58			.byte $05,$49,$4e,$44,$45,$58          ; $31 INDEX
>a17f	04 4c 49 53 54				.byte $04,$4c,$49,$53,$54              ; $32 LIST
>a184	04 4c 4f 41 44				.byte $04,$4c,$4f,$41,$44              ; $33 LOAD
>a189	03 4d 4f 44				.byte $03,$4d,$4f,$44                  ; $34 MOD
>a18d	06 4e 45 47 41 54 45			.byte $06,$4e,$45,$47,$41,$54,$45      ; $35 NEGATE
>a194	03 4e 45 57				.byte $03,$4e,$45,$57                  ; $36 NEW
>a198	04 4e 45 58 54				.byte $04,$4e,$45,$58,$54              ; $37 NEXT
>a19d	03 4e 49 50				.byte $03,$4e,$49,$50                  ; $38 NIP
>a1a1	03 4e 4f 54				.byte $03,$4e,$4f,$54                  ; $39 NOT
>a1a5	03 4f 4c 44				.byte $03,$4f,$4c,$44                  ; $3a OLD
>a1a9	02 4f 52				.byte $02,$4f,$52                      ; $3b OR
>a1ac	04 4f 56 45 52				.byte $04,$4f,$56,$45,$52              ; $3c OVER
>a1b1	08 52 45 4e 55 4d 42 45			.byte $08,$52,$45,$4e,$55,$4d,$42,$45,$52 ; $3d RENUMBER
>a1b9	52
>a1ba	06 52 45 50 45 41 54			.byte $06,$52,$45,$50,$45,$41,$54      ; $3e REPEAT
>a1c1	06 52 45 54 55 52 4e			.byte $06,$52,$45,$54,$55,$52,$4e      ; $3f RETURN
>a1c8	03 52 55 4e				.byte $03,$52,$55,$4e                  ; $40 RUN
>a1cc	04 53 41 56 45				.byte $04,$53,$41,$56,$45              ; $41 SAVE
>a1d1	03 53 48 4c				.byte $03,$53,$48,$4c                  ; $42 SHL
>a1d5	03 53 48 52				.byte $03,$53,$48,$52                  ; $43 SHR
>a1d9	04 53 54 4f 50				.byte $04,$53,$54,$4f,$50              ; $44 STOP
>a1de	04 53 57 41 50				.byte $04,$53,$57,$41,$50              ; $45 SWAP
>a1e3	03 53 59 53				.byte $03,$53,$59,$53                  ; $46 SYS
>a1e7	05 55 4e 54 49 4c			.byte $05,$55,$4e,$54,$49,$4c          ; $47 UNTIL
>a1ed	02 57 21				.byte $02,$57,$21                      ; $48 W!
>a1f0	02 57 40				.byte $02,$57,$40                      ; $49 W@
>a1f3	03 58 4f 52				.byte $03,$58,$4f,$52                  ; $4a XOR
>a1f7	01 5b					.byte $01,$5b                          ; $4b [
>a1f9	01 5d					.byte $01,$5d                          ; $4c ]
>a1fb	01 5e					.byte $01,$5e                          ; $4d ^
>a1fd	01 2b					.byte $01,$2b                          ; $4e {+}
>a1ff	01 2d					.byte $01,$2d                          ; $4f {-}
>a201	00					.byte $00
.a202					KeywordVectorTable:
>a202	dd ab					.word Mem_DPoke                        ; $10 !
>a204	fb ac					.word MulInteger32                     ; $11 *
>a206	04 ac					.word Stack_Add                        ; $12 +
>a208	04 ab					.word Unary_Increment                  ; $13 ++
>a20a	2b ac					.word Stack_Sub                        ; $14 -
>a20c	17 ab					.word Unary_Decrement                  ; $15 --
>a20e	b6 b0					.word System_ShowStack                 ; $16 .
>a210	44 ad					.word DivInteger32                     ; $17 /
>a212	13 b2					.word ProcReturn                       ; $18 ;
>a214	2b ae					.word Comp_Less                        ; $19 <
>a216	39 ab					.word Unary_Shl                        ; $1a <<
>a218	56 ae					.word Comp_LessEqual                   ; $1b <=
>a21a	f4 ad					.word Comp_NotEqual                    ; $1c <>
>a21c	f1 ad					.word Comp_Equal                       ; $1d =
>a21e	59 ae					.word Comp_Greater                     ; $1e >
>a220	2e ae					.word Comp_GreaterEqual                ; $1f >=
>a222	46 ab					.word Unary_Shr                        ; $20 >>
>a224	8b ab					.word Mem_DPeek                        ; $21 @
>a226	bb aa					.word Unary_Absolute                   ; $22 ABS
>a228	81 ae					.word Allocate                         ; $23 ALLOC
>a22a	52 ac					.word Stack_And                        ; $24 AND
>a22c	47 b0					.word System_Assert                    ; $25 ASSERT
>a22e	b0 ab					.word Mem_Poke                         ; $26 C!
>a230	53 ab					.word Mem_Peek                         ; $27 C@
>a232	2d aa					.word Stack_Empty                      ; $28 CLR
>a234	db a5					.word SyntaxError                      ; $29 DEF
>a236	30 aa					.word Stack_Drop                       ; $2a DROP
>a238	32 aa					.word Stack_Dup                        ; $2b DUP
>a23a	29 b3					.word Struct_ELSE                      ; $2c ELSE
>a23c	3c b0					.word System_END                       ; $2d END
>a23e	2e b3					.word Struct_ENDIF                     ; $2e ENDIF
>a240	4a b3					.word Command_For                      ; $2f FOR
>a242	14 b3					.word Struct_IF                        ; $30 IF
>a244	d6 b3					.word Command_Index                    ; $31 INDEX
>a246	c1 ae					.word Cmd_List                         ; $32 LIST
>a248	02 b1					.word System_Load                      ; $33 LOAD
>a24a	d9 ad					.word ModInteger32                     ; $34 MOD
>a24c	c1 aa					.word Unary_Negate                     ; $35 NEGATE
>a24e	61 b0					.word System_New                       ; $36 NEW
>a250	99 b3					.word Command_Next                     ; $37 NEXT
>a252	4c aa					.word Stack_Nip                        ; $38 NIP
>a254	e3 aa					.word Unary_Not                        ; $39 NOT
>a256	6a b0					.word System_Old                       ; $3a OLD
>a258	9e ac					.word Stack_Or                         ; $3b OR
>a25a	66 aa					.word Stack_Over                       ; $3c OVER
>a25c	fb af					.word Cmd_Renumber                     ; $3d RENUMBER
>a25e	02 b4					.word Command_Repeat                   ; $3e REPEAT
>a260	13 b2					.word ProcReturn2                      ; $3f RETURN
>a262	33 b0					.word System_RUN                       ; $40 RUN
>a264	e4 b0					.word System_Save                      ; $41 SAVE
>a266	c4 ac					.word Stack_Shl                        ; $42 SHL
>a268	c7 ac					.word Stack_Shr                        ; $43 SHR
>a26a	3f b0					.word System_STOP                      ; $44 STOP
>a26c	80 aa					.word Stack_Swap                       ; $45 SWAP
>a26e	8e b0					.word System_Sys                       ; $46 SYS
>a270	0c b4					.word Command_Until                    ; $47 UNTIL
>a272	c2 ab					.word Mem_WPoke                        ; $48 W!
>a274	6c ab					.word Mem_WPeek                        ; $49 W@
>a276	78 ac					.word Stack_Xor                        ; $4a XOR
>a278	db a5					.word SyntaxError                      ; $4b [
>a27a	db a5					.word SyntaxError                      ; $4c ]
>a27c	22 b2					.word WriteVariable                    ; $4d ^
>a27e	db a5					.word SyntaxError                      ; $4e {+}
>a280	db a5					.word SyntaxError                      ; $4f {-}
=$10					KWD_PLING = $10                  ; $10 !
=$11					KWD_ASTERISK = $11               ; $11 *
=$12					KWD_PLUS = $12                   ; $12 +
=$13					KWD_PLUSPLUS = $13               ; $13 ++
=$14					KWD_MINUS = $14                  ; $14 -
=$15					KWD_MINUSMINUS = $15             ; $15 --
=$16					KWD_DOT = $16                    ; $16 .
=$17					KWD_SLASH = $17                  ; $17 /
=$18					KWD_SEMICOLON = $18              ; $18 ;
=$19					KWD_LESS = $19                   ; $19 <
=$1a					KWD_LESSLESS = $1a               ; $1a <<
=$1b					KWD_LESSEQUAL = $1b              ; $1b <=
=$1c					KWD_LESSGREATER = $1c            ; $1c <>
=$1d					KWD_EQUAL = $1d                  ; $1d =
=$1e					KWD_GREATER = $1e                ; $1e >
=$1f					KWD_GREATEREQUAL = $1f           ; $1f >=
=$20					KWD_GREATERGREATER = $20         ; $20 >>
=$21					KWD_AT = $21                     ; $21 @
=$22					KWD_ABS = $22                    ; $22 ABS
=$23					KWD_ALLOC = $23                  ; $23 ALLOC
=$24					KWD_AND = $24                    ; $24 AND
=$25					KWD_ASSERT = $25                 ; $25 ASSERT
=$26					KWD_CPLING = $26                 ; $26 C!
=$27					KWD_CAT = $27                    ; $27 C@
=$28					KWD_CLR = $28                    ; $28 CLR
=$29					KWD_DEF = $29                    ; $29 DEF
=$2a					KWD_DROP = $2a                   ; $2a DROP
=$2b					KWD_DUP = $2b                    ; $2b DUP
=$2c					KWD_ELSE = $2c                   ; $2c ELSE
=$2d					KWD_END = $2d                    ; $2d END
=$2e					KWD_ENDIF = $2e                  ; $2e ENDIF
=$2f					KWD_FOR = $2f                    ; $2f FOR
=$30					KWD_IF = $30                     ; $30 IF
=$31					KWD_INDEX = $31                  ; $31 INDEX
=$32					KWD_LIST = $32                   ; $32 LIST
=$33					KWD_LOAD = $33                   ; $33 LOAD
=$34					KWD_MOD = $34                    ; $34 MOD
=$35					KWD_NEGATE = $35                 ; $35 NEGATE
=$36					KWD_NEW = $36                    ; $36 NEW
=$37					KWD_NEXT = $37                   ; $37 NEXT
=$38					KWD_NIP = $38                    ; $38 NIP
=$39					KWD_NOT = $39                    ; $39 NOT
=$3a					KWD_OLD = $3a                    ; $3a OLD
=$3b					KWD_OR = $3b                     ; $3b OR
=$3c					KWD_OVER = $3c                   ; $3c OVER
=$3d					KWD_RENUMBER = $3d               ; $3d RENUMBER
=$3e					KWD_REPEAT = $3e                 ; $3e REPEAT
=$3f					KWD_RETURN = $3f                 ; $3f RETURN
=$40					KWD_RUN = $40                    ; $40 RUN
=$41					KWD_SAVE = $41                   ; $41 SAVE
=$42					KWD_SHL = $42                    ; $42 SHL
=$43					KWD_SHR = $43                    ; $43 SHR
=$44					KWD_STOP = $44                   ; $44 STOP
=$45					KWD_SWAP = $45                   ; $45 SWAP
=$46					KWD_SYS = $46                    ; $46 SYS
=$47					KWD_UNTIL = $47                  ; $47 UNTIL
=$48					KWD_WPLING = $48                 ; $48 W!
=$49					KWD_WAT = $49                    ; $49 W@
=$4a					KWD_XOR = $4a                    ; $4a XOR
=$4b					KWD_LSQPAREN = $4b               ; $4b [
=$4c					KWD_RSQPAREN = $4c               ; $4c ]
=$4d					KWD_HAT = $4d                    ; $4d ^
=$4e					KWD_CONSTANT_PLUS = $4e          ; $4e {+}
=$4f					KWD_CONSTANT_MINUS = $4f         ; $4f {-}

;******  Return to file: main.asm


;******  Processing file: system/extern.asm

.a282					ExternInitialise:
.a282	a9 07		lda #$07			lda 	#$07 						; set colour
.a284	8d 86 02	sta $0286			sta 	646
.a287	a9 93		lda #$93			lda 	#147 						; clear screen
.a289	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a28c	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a28e	4c af a2	jmp $a2af			jmp 	ExternColour
.a291					ExternCheckBreak:
.a291	da		phx				phx 								; make sure we keep XY
.a292	5a		phy				phy
.a293	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a296	f0 03		beq $a29b			beq		_ECBExit 					; stopped
.a298	7a		ply				ply 								; restore and exit.
.a299	fa		plx				plx
.a29a	60		rts				rts
.a29b					_ECBExit:
.a29b	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>a29e	45 53 43 41 50 45 00				.text 	"ESCAPE",0
.a2a5					ExternPrint:
.a2a5	48		pha				pha
.a2a6	da		phx				phx
.a2a7	5a		phy				phy
.a2a8	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a2ab	7a		ply				ply
.a2ac	fa		plx				plx
.a2ad	68		pla				pla
.a2ae	60		rts				rts
.a2af					ExternColour:
.a2af	48		pha				pha
.a2b0	da		phx				phx
.a2b1	48		pha				pha
.a2b2	29 08		and #$08			and 	#8
.a2b4	0a		asl a				asl 	a
.a2b5	0a		asl a				asl 	a
.a2b6	0a		asl a				asl 	a
.a2b7	0a		asl a				asl 	a
.a2b8	49 92		eor #$92			eor 	#$92
.a2ba	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a2bd	a9 0e		lda #$0e			lda 	#14							; lower case
.a2bf	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a2c2	68		pla				pla
.a2c3	29 07		and #$07			and 	#7
.a2c5	aa		tax				tax
.a2c6	bd cf a2	lda $a2cf,x			lda 	_ECTable,x
.a2c9	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a2cc	fa		plx				plx
.a2cd	68		pla				pla
.a2ce	60		rts				rts
.a2cf					_ECTable:
>a2cf	90						.byte 	144
>a2d0	1c						.byte 	28
>a2d1	1e						.byte 	30
>a2d2	9e						.byte 	158
>a2d3	1f						.byte 	31
>a2d4	9c						.byte 	156
>a2d5	9f						.byte 	159
>a2d6	05						.byte 	5
.a2d7					ExternInput:
.a2d7	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a2d9	85 14		sta $14				sta 	zTemp0
.a2db	a9 09		lda #$09			lda 	#(InputBuffer >> 8)
.a2dd	85 15		sta $15				sta 	zTemp0+1
.a2df	a9 07		lda #$07			lda 	#COL_WHITE
.a2e1	20 af a2	jsr $a2af			jsr 	ExternColour
.a2e4	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a2e7	29 7f		and #$7f			and 	#$7F
.a2e9	c9 0d		cmp #$0d			cmp 	#13
.a2eb	f0 0a		beq $a2f7			beq 	_EIExit
.a2ed	92 14		sta ($14)			sta 	(zTemp0)
.a2ef	e6 14		inc $14				inc 	zTemp0
.a2f1	d0 f1		bne $a2e4			bne 	_EIRead
.a2f3	e6 15		inc $15				inc 	zTemp0+1
.a2f5	80 ed		bra $a2e4			bra 	_EIRead
.a2f7	a9 00		lda #$00	_EIExit:lda 	#0
.a2f9	92 14		sta ($14)			sta 	(zTemp0)
.a2fb	a9 0d		lda #$0d			lda 	#13
.a2fd	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a300	60		rts				rts
.a301					ExternSave:
.a301	da		phx				phx
.a302	5a		phy				phy
.a303	85 18		sta $18				sta 	zTemp2 						; save start
.a305	84 19		sty $19				sty 	zTemp2+1
.a307	20 69 a3	jsr $a369			jsr 	EXGetLength 				; get length of file into A
.a30a	a6 14		ldx $14				ldx 	zTemp0
.a30c	a4 15		ldy $15				ldy 	zTemp0+1
.a30e	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a311	a9 01		lda #$01			lda 	#1
.a313	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a315	a0 00		ldy #$00			ldy 	#0
.a317	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a31a	a6 16		ldx $16				ldx 	zTemp1 						; end address
.a31c	a4 17		ldy $17				ldy 	zTemp1+1
.a31e	a9 18		lda #$18			lda 	#zTemp2
.a320	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.a323	b0 03		bcs $a328			bcs 	_ESSave
.a325	7a		ply				ply
.a326	fa		plx				plx
.a327	60		rts				rts
.a328					_ESSave:
.a328	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>a32b	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>a333	4c 45 44 00
.a337					ExternLoad:
.a337	da		phx				phx 								; save XY
.a338	5a		phy				phy
.a339	48		pha				pha 								; save target
.a33a	5a		phy				phy
.a33b	20 69 a3	jsr $a369			jsr 	EXGetLength 				; get length of file into A
.a33e	a6 14		ldx $14				ldx 	zTemp0
.a340	a4 15		ldy $15				ldy 	zTemp0+1
.a342	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a345	a9 01		lda #$01			lda 	#1
.a347	a2 01		ldx #$01			ldx 	#1	 						; device #1
.a349	a0 00		ldy #$00			ldy 	#0
.a34b	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a34e	7a		ply				ply 								; restore target to YX and call load
.a34f	fa		plx				plx
.a350	a9 00		lda #$00			lda 	#0 							; load command
.a352	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.a355	b0 03		bcs $a35a			bcs 	_ESLoad
.a357	7a		ply				ply
.a358	fa		plx				plx
.a359	60		rts				rts
.a35a					_ESLoad:
.a35a	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>a35d	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>a365	4c 45 44 00
.a369					EXGetLength:
.a369	a0 ff		ldy #$ff			ldy 	#255
.a36b	c8		iny		_EXGL:	iny
.a36c	b1 14		lda ($14),y			lda 	(zTemp0),y
.a36e	d0 fb		bne $a36b			bne 	_EXGL
.a370	98		tya				tya
.a371	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/execute.asm

.a372					EXNextLine:
.a372	b2 10		lda ($10)			lda 	(codePtr) 					; is it run from the buffer (offset 0)
.a374	f0 0f		beq $a385			beq 	_EXNLWarmStart
.a376	18		clc				clc 								; advance code pointer to next line
.a377	65 10		adc $10				adc 	codePtr
.a379	85 10		sta $10				sta 	codePtr
.a37b	90 02		bcc $a37f			bcc 	_EXNLNoBump
.a37d	e6 11		inc $11				inc 	codePtr+1
.a37f					_EXNLNoBump:
.a37f	a0 03		ldy #$03			ldy 	#3 							; position in that line
.a381	b2 10		lda ($10)			lda 	(codePtr) 					; read offset
.a383	d0 03		bne $a388			bne 	Execute 					; not end of program
.a385					_EXNLWarmStart:
.a385	4c 3c b0	jmp $b03c			jmp 	System_END
.a388	e0 fc		cpx #$fc	Execute:cpx 	#$FC  						; stack overflow
.a38a	b0 1c		bcs $a3a8			bcs 	EXStackOverflow
.a38c	ee 22 08	inc $0822			inc 	BreakCount 					; break occasionally. too slow otherwise.
.a38f	d0 03		bne $a394			bne 	_EXNoBreak
.a391	20 91 a2	jsr $a291			jsr 	ExternCheckBreak
.a394					_EXNoBreak:
.a394	b1 10		lda ($10),y			lda 	(codePtr),y 				; load the character
.a396	f0 da		beq $a372			beq 	EXNextLine 					; reached end of the line.
.a398	c8		iny				iny 								; advance pointer.
.a399	c9 10		cmp #$10			cmp 	#$10 						; is it 01-0F, which means a string/comment ?
.a39b	90 3b		bcc $a3d8			bcc 	EXStringComment
.a39d	c9 80		cmp #$80			cmp 	#$80 						; if it 10-7F, token
.a39f	90 21		bcc $a3c2			bcc 	EXTokenExecute
.a3a1	c9 c0		cmp #$c0			cmp 	#$C0 						; is it a numeric constant 80-BF
.a3a3	90 17		bcc $a3bc			bcc 	EXPushConstant
.a3a5	4c 7a b1	jmp $b17a			jmp 	Identifier 					; it's an identifier C0-FF
.a3a8					EXStackOverflow:
.a3a8	a2 00		ldx #$00			ldx 	#0 							; stack error clears stack otherwise doesn't work.
.a3aa	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>a3ad	53 54 41 43 4b 20 4f 56				.text 	"STACK OVERFLOW",0
>a3b5	45 52 46 4c 4f 57 00
.a3bc					EXPushConstant:
.a3bc	88		dey				dey
.a3bd	20 07 a4	jsr $a407			jsr 	ExtractIntegerToTOS 		; extract integer
.a3c0	80 c6		bra $a388			bra 	Execute
.a3c2					EXTokenExecute:
.a3c2	0a		asl a				asl 	a 							; double token, also clears carry
.a3c3	da		phx				phx 								; save X, put token x 2 in X
.a3c4	aa		tax				tax
.a3c5	bd e2 a1	lda $a1e2,x			lda 	KeywordVectorTable-$20,x 	; copy vector. The -$20 is because the tokens
.a3c8	85 14		sta $14				sta 	zTemp0 						; start at $10.
.a3ca	bd e3 a1	lda $a1e3,x			lda 	KeywordVectorTable-$20+1,x
.a3cd	85 15		sta $15				sta 	zTemp0+1
.a3cf	fa		plx				plx 								; restore X
.a3d0	20 d5 a3	jsr $a3d5			jsr 	_EXTCall 					; call the routine
.a3d3	80 b3		bra $a388			bra 	Execute
.a3d5					_EXTCall:
.a3d5	6c 14 00	jmp ($0014)			jmp 	(zTemp0)
.a3d8					EXStringComment:
.a3d8	c9 02		cmp #$02			cmp 	#$02 						; 02 is the token for single quoted string
.a3da	f0 15		beq $a3f1			beq 	EXStringSkip 				; (comment), so just skip it.
.a3dc	e8		inx				inx 								; push Y + 1 + codePtr on the stack
.a3dd	98		tya				tya
.a3de	38		sec				sec
.a3df	65 10		adc $10				adc 	codePtr
.a3e1	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a3e4	a5 11		lda $11				lda 	codePtr+1
.a3e6	69 00		adc #$00			adc 	#0
.a3e8	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a3eb	9e 00 0e	stz $0e00,x			stz 	stack2,x 					; clear the upper 2 bytes.
.a3ee	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a3f1					EXStringSkip:
.a3f1	98		tya				tya 								; the current position in A
.a3f2	18		clc				clc
.a3f3	71 10		adc ($10),y			adc 	(codePtr),y					; add the total length
.a3f5	a8		tay				tay 			 					; and make that the current position.
.a3f6	88		dey				dey 								; back one because of the initial skip
.a3f7	80 8f		bra $a388			bra 	Execute
.a3f9					EXShiftTOSRight:
.a3f9	4a		lsr a				lsr 	a
.a3fa	7e 00 0f	ror $0f00,x			ror 	stack3,x
.a3fd	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a400	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a403	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a406	60		rts				rts
.a407					ExtractIntegerToTOS:
.a407	b1 10		lda ($10),y			lda 	(codePtr),y
.a409	c8		iny				iny
.a40a	e8		inx				inx 								; make stack space
.a40b	29 3f		and #$3f			and 	#$3F 						; to start with, it's just that value
.a40d	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a410	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a413	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a416	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a419					_EXConstantLoop:
.a419	b1 10		lda ($10),y			lda 	(codePtr),y 				; look at next ?
.a41b	29 c0		and #$c0			and 	#$C0 						; in range 80-FF e.g. 10xx xxxx
.a41d	c9 80		cmp #$80			cmp 	#$80
.a41f	d0 2d		bne $a44e			bne		_EXDone 					; no then exit
.a421	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; put the MSB in A
.a424	48		pha				pha
.a425	bd 00 0e	lda $0e00,x			lda 	stack2,x 					; shift every byte up one, e.g. x 256
.a428	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a42b	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a42e	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a431	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a434	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a437	9e 00 0c	stz $0c00,x			stz 	stack0,x
.a43a	68		pla				pla
.a43b	20 f9 a3	jsr $a3f9			jsr 	EXShiftTOSRight 				; shift the whole A:Top of Stack right twice
.a43e	20 f9 a3	jsr $a3f9			jsr 	EXShiftTOSRight				; which will be x64
.a441	b1 10		lda ($10),y			lda 	(codePtr),y 				; get and skip constant shift
.a443	c8		iny				iny
.a444	29 3f		and #$3f			and 	#$3F
.a446	1d 00 0c	ora $0c00,x			ora 	stack0,x 					; or into low byte
.a449	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a44c	80 cb		bra $a419			bra 	_EXConstantLoop
.a44e	b1 10		lda ($10),y	_EXDone:lda 	(codePtr),y
.a450	c8		iny				iny 								; skip over unary constant + -
.a451	c9 4f		cmp #$4f			cmp 	#KWD_CONSTANT_MINUS
.a453	d0 03		bne $a458			bne 	_EXPositive
.a455	4c c1 aa	jmp $aac1			jmp 	Unary_Negate
.a458					_EXPositive:
.a458	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/identifier.asm

.a459					IdentifierSearch:
.a459	b1 10		lda ($10),y			lda 	(codePtr),y 				; get first character
.a45b	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a fast var ?
.a45d	90 12		bcc $a471			bcc 	_ISSlow
.a45f	c9 fa		cmp #$fa			cmp 	#$F9+1
.a461	b0 0e		bcs $a471			bcs 	_ISSlow
.a463	29 1f		and #$1f			and 	#$1F 						; index, then x 4
.a465	0a		asl a				asl 	a
.a466	0a		asl a				asl		a
.a467	85 22		sta $22				sta 	idDataAddr					; set up addres
.a469	a9 10		lda #$10			lda 	#AZVariables >> 8
.a46b	85 23		sta $23				sta 	idDataAddr+1
.a46d	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; type
.a46f	38		sec				sec 								; return with CS.
.a470	60		rts				rts
.a471					_ISSlow:
.a471	20 2d a5	jsr $a52d			jsr 	IdentifierSetupHashPtr 		; set up hash table.
.a474	98		tya				tya 								; set (zTemp1) to point to the
.a475	18		clc				clc 	 							; identifier to be searched.
.a476	65 10		adc $10				adc 	codePtr
.a478	85 16		sta $16				sta 	zTemp1
.a47a	a5 11		lda $11				lda 	codePtr+1
.a47c	69 00		adc #$00			adc 	#0
.a47e	85 17		sta $17				sta 	zTemp1+1
.a480	5a		phy				phy 								; save Y
.a481	b2 14		lda ($14)	_ISLoop:lda 	(zTemp0)					; follow link
.a483	48		pha				pha
.a484	a0 01		ldy #$01			ldy 	#1
.a486	b1 14		lda ($14),y			lda 	(zTemp0),y
.a488	85 15		sta $15				sta 	zTemp0+1
.a48a	68		pla				pla
.a48b	85 14		sta $14				sta 	zTemp0
.a48d	05 15		ora $15				ora 	zTemp0+1 					; if zero, then fail.
.a48f	f0 2c		beq $a4bd			beq 	_ISFail
.a491	a0 06		ldy #$06			ldy 	#6 							; copy name into zTemp2
.a493	b1 14		lda ($14),y			lda 	(zTemp0),y
.a495	85 18		sta $18				sta 	zTemp2
.a497	c8		iny				iny
.a498	b1 14		lda ($14),y			lda 	(zTemp0),y
.a49a	85 19		sta $19				sta 	zTemp2+1
.a49c	a0 00		ldy #$00			ldy 	#0 							; compare names at zTemp1/zTemp2
.a49e					_ISCompare:
.a49e	b1 16		lda ($16),y			lda 	(zTemp1),y
.a4a0	d1 18		cmp ($18),y			cmp 	(zTemp2),y
.a4a2	d0 dd		bne $a481			bne		_ISLoop 					; different ?
.a4a4	c8		iny				iny
.a4a5	c9 e0		cmp #$e0			cmp 	#$E0 						; until end identifiers matched.
.a4a7	90 f5		bcc $a49e			bcc 	_ISCompare
.a4a9	18		clc				clc 								; set up the data pointer
.a4aa	a5 14		lda $14				lda 	zTemp0
.a4ac	69 02		adc #$02			adc 	#2
.a4ae	85 22		sta $22				sta 	idDataAddr
.a4b0	a5 15		lda $15				lda 	zTemp0+1
.a4b2	69 00		adc #$00			adc		#0
.a4b4	85 23		sta $23				sta 	idDataAddr+1
.a4b6	a0 09		ldy #$09			ldy 	#9 							; get the type
.a4b8	b1 14		lda ($14),y			lda 	(zTemp0),y
.a4ba	7a		ply				ply
.a4bb	38		sec				sec
.a4bc	60		rts				rts
.a4bd					_ISFail:
.a4bd	7a		ply				ply
.a4be	18		clc				clc
.a4bf	60		rts				rts
.a4c0					IdentifierCreate:
.a4c0	5a		phy				phy 								; save Y
.a4c1	48		pha				pha 								; save type on stack
.a4c2	20 2d a5	jsr $a52d			jsr 	IdentifierSetUpHashPtr 		; zTemp0 = address of table.
.a4c5	ad 88 10	lda $1088			lda 	VarMemory 					; copy VarMemory to zTemp1
.a4c8	85 16		sta $16				sta 	zTemp1
.a4ca	ad 89 10	lda $1089			lda 	VarMemory+1
.a4cd	85 17		sta $17				sta 	zTemp1+1
.a4cf	5a		phy				phy 								; save Y (code offset)
.a4d0	a0 00		ldy #$00			ldy 	#0 							; copy next link in.
.a4d2	b1 14		lda ($14),y			lda 	(zTemp0),y 					; +0,+1 is the link.
.a4d4	91 16		sta ($16),y			sta 	(zTemp1),y
.a4d6	c8		iny				iny
.a4d7	b1 14		lda ($14),y			lda 	(zTemp0),y
.a4d9	91 16		sta ($16),y			sta 	(zTemp1),y
.a4db	c8		iny				iny
.a4dc					_IDCErase:
.a4dc	a9 00		lda #$00			lda 	#0
.a4de	91 16		sta ($16),y			sta 	(zTemp1),y
.a4e0	c8		iny				iny
.a4e1	c0 06		cpy #$06			cpy 	#6
.a4e3	d0 f7		bne $a4dc			bne 	_IDCErase
.a4e5	68		pla				pla 								; original Y
.a4e6	18		clc				clc
.a4e7	65 10		adc $10				adc		codePtr 					; address of identifier +6,+7
.a4e9	91 16		sta ($16),y			sta 	(zTemp1),y
.a4eb	c8		iny				iny
.a4ec	a5 11		lda $11				lda 	codePtr+1
.a4ee	69 00		adc #$00			adc 	#0
.a4f0	91 16		sta ($16),y			sta 	(zTemp1),y
.a4f2	c8		iny				iny
.a4f3	a9 00		lda #$00			lda 	#0 							; +8 bank (0)
.a4f5	91 16		sta ($16),y			sta 	(zTemp1),y
.a4f7	68		pla				pla 								; restore type
.a4f8	c8		iny				iny
.a4f9	91 16		sta ($16),y			sta 	(zTemp1),y 					; store at +9
.a4fb	c8		iny				iny
.a4fc	98		tya				tya									; add offset to VarMemory
.a4fd	18		clc				clc
.a4fe	6d 88 10	adc $1088			adc 	VarMemory
.a501	8d 88 10	sta $1088			sta 	VarMemory
.a504	ad 89 10	lda $1089			lda 	VarMemory+1
.a507	69 00		adc #$00			adc 	#0
.a509	8d 89 10	sta $1089			sta 	VarMemory+1
.a50c	cd 8b 10	cmp $108b			cmp 	AllocMemory+1 				; in the same page as allocated ?
.a50f	f0 19		beq $a52a			beq 	_IDCMemory
.a511	a5 16		lda $16				lda 	zTemp1 						; overwrite hash table entry
.a513	92 14		sta ($14)			sta 	(zTemp0)
.a515	a0 01		ldy #$01			ldy 	#1
.a517	a5 17		lda $17				lda 	zTemp1+1
.a519	91 14		sta ($14),y			sta 	(zTemp0),y
.a51b	a5 16		lda $16				lda 	zTemp1 						; set up idDataAddr
.a51d	18		clc				clc
.a51e	69 02		adc #$02			adc 	#2
.a520	85 22		sta $22				sta 	idDataAddr
.a522	a5 17		lda $17				lda 	zTemp1+1
.a524	69 00		adc #$00			adc 	#0
.a526	85 23		sta $23				sta 	idDataAddr+1
.a528	7a		ply				ply 								; restore Y and exit
.a529	60		rts				rts
.a52a					_IDCMemory:
.a52a	4c eb a5	jmp $a5eb			jmp 	OutOfMemoryError
.a52d					IdentifierSetUpHashPtr:
.a52d	5a		phy				phy
.a52e					_ISPLoop:
.a52e	b1 10		lda ($10),y			lda 	(codePtr),y 				; get the last identifier character
.a530	c8		iny				iny
.a531	c9 e0		cmp #$e0			cmp 	#$E0
.a533	90 f9		bcc $a52e			bcc 	_ISPLoop
.a535	29 0f		and #$0f			and 	#(HashTableSize-1)			; convert to a hash index
.a537	0a		asl a				asl 	a 							; convert to an offset, clc
.a538	69 68		adc #$68			adc 	#(HashTable & $FF)			; set zTemp0 to point to hashTable entry
.a53a	85 14		sta $14				sta 	zTemp0
.a53c	a9 10		lda #$10			lda 	#(HashTable >> 8) 			; assumes table in one page
.a53e	85 15		sta $15				sta 	zTemp0+1
.a540	7a		ply				ply
.a541	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/reset.asm

.a542					ResetCodePointer:
.a542	48		pha				pha
.a543	a9 11		lda #$11			lda 	#ProgramStart >> 8 			; set up line pointer
.a545	85 11		sta $11				sta 	codePtr+1
.a547	64 10		stz $10				stz 	codePtr
.a549	a0 03		ldy #$03			ldy 	#3 							; point to first piece of code
.a54b	68		pla				pla
.a54c	60		rts				rts
.a54d					ResetForRun:
.a54d	48		pha				pha
.a54e	5a		phy				phy
.a54f	a2 00		ldx #$00			ldx 	#0 							; erase the hash table
.a551					_RRErase:
.a551	bd c5 b8	lda $b8c5,x			lda 	DefaultHashTable,x
.a554	9d 68 10	sta $1068,x			sta		HashTable,x
.a557	e8		inx				inx
.a558	e0 20		cpx #$20			cpx 	#HashTableSize * 2
.a55a	d0 f5		bne $a551			bne 	_RRErase
.a55c	20 73 a5	jsr $a573			jsr 	ResetVarMemory
.a55f	a9 ff		lda #$ff			lda 	#StructureStack & $FF
.a561	85 12		sta $12				sta 	StructSP
.a563	a9 0b		lda #$0b			lda 	#StructureStack >> 8
.a565	85 13		sta $13				sta 	StructSP+1
.a567	a9 ff		lda #$ff			lda 	#$FF 						; put a value that will fail structure tests
.a569	92 12		sta ($12)			sta 	(StructSP)
.a56b	20 9a a5	jsr $a59a			jsr 	ProcedureScan
.a56e	a2 00		ldx #$00			ldx 	#0 							; empty the stack
.a570	7a		ply				ply
.a571	68		pla				pla
.a572	60		rts				rts
.a573					ResetVarMemory:
.a573	a9 00		lda #$00			lda 	#ProgramStart & $FF
.a575	85 14		sta $14				sta 	zTemp0
.a577	a9 11		lda #$11			lda 	#ProgramStart >> 8
.a579	85 15		sta $15				sta 	zTemp0+1
.a57b					_RRFindEnd:
.a57b	b2 14		lda ($14)			lda 	(zTemp0)					; at end ?
.a57d	f0 0b		beq $a58a			beq 	_RRFoundEnd
.a57f	18		clc				clc 								; no, add offset to pointer.
.a580	65 14		adc $14				adc 	zTemp0
.a582	85 14		sta $14				sta 	zTemp0
.a584	90 f5		bcc $a57b			bcc 	_RRFindEnd
.a586	e6 15		inc $15				inc 	zTemp0+1
.a588	80 f1		bra $a57b			bra 	_RRFindEnd
.a58a					_RRFoundEnd:
.a58a	18		clc				clc 								; add 1 to this, as it points to the last
.a58b	a5 14		lda $14				lda 	zTemp0 					; offset, and store in Variable Memory pointer
.a58d	69 01		adc #$01			adc 	#1
.a58f	8d 88 10	sta $1088			sta 	VarMemory
.a592	a5 15		lda $15				lda 	zTemp0+1
.a594	69 00		adc #$00			adc 	#0
.a596	8d 89 10	sta $1089			sta 	VarMemory+1
.a599	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/scan.asm

.a59a					ProcedureScan:
.a59a	20 42 a5	jsr $a542			jsr 	ResetCodePointer 			; reset the code pointer.
.a59d	b2 10		lda ($10)	_PSMain:lda 	(codePtr)					; check if end
.a59f	f0 39		beq $a5da			beq 	_PSExit
.a5a1	a0 03		ldy #$03			ldy 	#3 							; start of line
.a5a3	b1 10		lda ($10),y			lda 	(codePtr),y 				; skip over spaces
.a5a5	c9 29		cmp #$29			cmp 	#KWD_DEF 					; first thing is DEF ?
.a5a7	d0 24		bne $a5cd			bne 	_PSNext
.a5a9	c8		iny				iny 								; skip over def first
.a5aa	b1 10		lda ($10),y			lda 	(codePtr),y 				; next, must be C0-DF - a multi char ID
.a5ac	29 e0		and #$e0			and 	#$E0
.a5ae	c9 c0		cmp #$c0			cmp 	#$C0
.a5b0	d0 1b		bne $a5cd			bne 	_PSNext 					; otherwise ignore it.
.a5b2	a9 50		lda #$50			lda 	#IDT_PROCEDURE 				; create a procedure
.a5b4	20 c0 a4	jsr $a4c0			jsr 	IdentifierCreate
.a5b7					_PSSkipIdentifier:
.a5b7	b1 10		lda ($10),y			lda 	(codePtr),y
.a5b9	c9 e0		cmp #$e0			cmp 	#$E0
.a5bb	c8		iny				iny
.a5bc	90 f9		bcc $a5b7			bcc 	_PSSkipIdentifier
.a5be	98		tya				tya  								; save the address in the data slot.
.a5bf	a0 03		ldy #$03			ldy 	#3
.a5c1	91 22		sta ($22),y			sta 	(idDataAddr),y 				; offset
.a5c3	a5 10		lda $10				lda 	codePtr
.a5c5	92 22		sta ($22)			sta 	(idDataAddr) 				; position.low
.a5c7	a5 11		lda $11				lda 	codePtr+1
.a5c9	a0 01		ldy #$01			ldy 	#1
.a5cb	91 22		sta ($22),y			sta 	(idDataAddr),y 				; position.high
.a5cd					_PSNext:
.a5cd	18		clc				clc 								; go to next
.a5ce	b2 10		lda ($10)			lda 	(codePtr)
.a5d0	65 10		adc $10				adc 	codePtr
.a5d2	85 10		sta $10				sta 	codeptr
.a5d4	90 c7		bcc $a59d			bcc 	_PSMain
.a5d6	e6 11		inc $11				inc 	codePtr+1
.a5d8	80 c3		bra $a59d			bra 	_PSMain
.a5da					_PSExit:
.a5da	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/error.asm

.a5db					SyntaxError:
.a5db	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>a5de	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>a5e6	52 52 4f 52 00
.a5eb					OutOfMemoryError:
.a5eb	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>a5ee	4f 55 54 20 4f 46 20 4d				.text 	"OUT OF MEMORY",0
>a5f6	45 4d 4f 52 59 00
.a5fc					ErrorHandler:
.a5fc	68		pla				pla 								; pop message address
.a5fd	85 14		sta $14				sta 	zTemp0
.a5ff	68		pla				pla
.a600	85 15		sta $15				sta 	zTemp0+1
.a602	a9 05		lda #$05			lda 	#CTH_ERROR
.a604	20 af a2	jsr $a2af			jsr 	ExternColour
.a607	a0 01		ldy #$01			ldy 	#1 							; print it
.a609					_ErrorPrint:
.a609	b1 14		lda ($14),y			lda 	(zTemp0),y
.a60b	20 a5 a2	jsr $a2a5			jsr		ExternPrint
.a60e	c8		iny				iny
.a60f	b1 14		lda ($14),y			lda 	(zTemp0),y
.a611	d0 f6		bne $a609			bne 	_ErrorPrint
.a613	a0 01		ldy #$01			ldy 	#1 							; check if line# 0
.a615	b1 10		lda ($10),y			lda		(codePtr),y
.a617	c8		iny				iny
.a618	12 10		ora ($10)			ora 	(codePtr)
.a61a	f0 1c		beq $a638			beq 	_ErrorNoLine 				; if so, skip
.a61c	a9 20		lda #$20			lda 	#32
.a61e	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a621	a9 40		lda #$40			lda 	#'@'
.a623	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a626	a9 20		lda #$20			lda 	#32
.a628	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a62b	a0 01		ldy #$01			ldy 	#1 							; load current line into YA
.a62d	b1 10		lda ($10),y			lda 	(codePtr),y
.a62f	48		pha				pha
.a630	c8		iny				iny
.a631	b1 10		lda ($10),y			lda 	(codePtr),y
.a633	a8		tay				tay
.a634	68		pla				pla
.a635	20 40 a6	jsr $a640			jsr 	ErrorPrint16 				; print YA as unsigned 16 bit integer.
.a638					_ErrorNoLine:
.a638	a9 0d		lda #$0d			lda 	#13							; new line
.a63a	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a63d	4c 3e a0	jmp $a03e			jmp 	WarmStart
.a640					ErrorPrint16:
.a640	da		phx				phx
.a641	e8		inx				inx 								; space on stack
.a642	9d 00 0c	sta $0c00,x			sta 	stack0,x					; save on TOS
.a645	98		tya				tya
.a646	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a649	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a64c	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a64f	20 65 a6	jsr $a665			jsr 	IntegerToString 			; convert to string.
.a652	fa		plx				plx
.a653					ErrorPrintIntegerBuffer:
.a653	da		phx				phx
.a654	a2 00		ldx #$00			ldx 	#0
.a656					_EP16Loop:
.a656	bd 00 08	lda $0800,x			lda 	SBuffer,x
.a659	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.a65c	e8		inx				inx
.a65d	bd 00 08	lda $0800,x			lda 	SBuffer,x
.a660	d0 f4		bne $a656			bne 	_EP16Loop
.a662	8a		txa				txa
.a663	fa		plx				plx
.a664	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/inttostr.asm

.a665					IntegerToString:
.a665	48		pha				pha
.a666	5a		phy				phy
.a667	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a66a	48		pha				pha
.a66b	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a66e	48		pha				pha
.a66f	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a672	48		pha				pha
.a673	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a676	48		pha				pha
.a677	bd 00 0f	lda $0f00,x			lda 		stack3,x 				; check -ve
.a67a	10 08		bpl $a684			bpl 		_ITSNotMinus
.a67c	a9 2d		lda #$2d			lda 		#"-"
.a67e	20 26 a7	jsr $a726			jsr 		ITSOutputCharacter
.a681	20 c1 aa	jsr $aac1			jsr 		Unary_Negate
.a684					_ITSNotMinus:
.a684	9c 20 08	stz $0820			stz 		SBPosition 				; reset string buffer position
.a687	9c 24 08	stz $0824			stz 		NumSuppress 			; clear zero suppression flag
.a68a	8a		txa				txa 								; use Y for the integer index.
.a68b	a8		tay				tay
.a68c	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.a68e					_ITSNextSubtractor:
.a68e	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.a690	8d 21 08	sta $0821			sta 		NumConvCount
.a693					_ITSSubtract:
.a693	38		sec				sec
.a694	b9 00 0c	lda $0c00,y			lda 		stack0,y 			; subtract number and push on stack
.a697	fd 02 a7	sbc $a702,x			sbc 		_ITSSubtractors+0,x 	; only update if actually can subtract it.
.a69a	48		pha				pha
.a69b	b9 00 0d	lda $0d00,y			lda 		stack1,y
.a69e	fd 03 a7	sbc $a703,x			sbc 		_ITSSubtractors+1,x
.a6a1	48		pha				pha
.a6a2	b9 00 0e	lda $0e00,y			lda 		stack2,y
.a6a5	fd 04 a7	sbc $a704,x			sbc 		_ITSSubtractors+2,x
.a6a8	48		pha				pha
.a6a9	b9 00 0f	lda $0f00,y			lda 		stack3,y
.a6ac	fd 05 a7	sbc $a705,x			sbc 		_ITSSubtractors+3,x
.a6af	90 14		bcc $a6c5			bcc 		_ITSCantSubtract 		; if CC, then gone too far, can't subtract
.a6b1	99 00 0f	sta $0f00,y			sta 		stack3,y 		; save subtract off stack as it's okay
.a6b4	68		pla				pla
.a6b5	99 00 0e	sta $0e00,y			sta 		stack2,y
.a6b8	68		pla				pla
.a6b9	99 00 0d	sta $0d00,y			sta 		stack1,y
.a6bc	68		pla				pla
.a6bd	99 00 0c	sta $0c00,y			sta 		stack0,y
.a6c0	ee 21 08	inc $0821			inc 		NumConvCount 			; bump count.
.a6c3	80 ce		bra $a693			bra 		_ITSSubtract 			; go round again.
.a6c5					_ITSCantSubtract:
.a6c5	68		pla				pla 								; throw away interim answers
.a6c6	68		pla				pla 								; (the subtraction that failed)
.a6c7	68		pla				pla
.a6c8	ad 21 08	lda $0821			lda 		NumConvCount 			; if not zero then no suppression check
.a6cb	c9 30		cmp #$30			cmp 		#"0"
.a6cd	d0 05		bne $a6d4			bne 		_ITSOutputDigit
.a6cf	ad 24 08	lda $0824			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.a6d2	f0 09		beq $a6dd			beq	 		_ITSGoNextSubtractor
.a6d4					_ITSOutputDigit:
.a6d4	ce 24 08	dec $0824			dec 		NumSuppress 			; suppression check will be non-zero from now on.
.a6d7	ad 21 08	lda $0821			lda 		NumConvCount 			; count of subtractions
.a6da	20 26 a7	jsr $a726			jsr 		ITSOutputCharacter 		; output it.
.a6dd					_ITSGoNextSubtractor:
.a6dd	e8		inx				inx 								; next dword in subtractor table.
.a6de	e8		inx				inx
.a6df	e8		inx				inx
.a6e0	e8		inx				inx
.a6e1	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.a6e3	d0 a9		bne $a68e			bne 		_ITSNextSubtractor 		; do all the subtractors.
.a6e5	98		tya				tya 								; X is back as the mantissa index
.a6e6	aa		tax				tax
.a6e7	bd 00 0c	lda $0c00,x			lda 		stack0,x 		; and the last digit is left.
.a6ea	09 30		ora #$30			ora 		#"0"
.a6ec	20 26 a7	jsr $a726			jsr 		ITSOutputCharacter
.a6ef	68		pla				pla
.a6f0	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a6f3	68		pla				pla
.a6f4	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a6f7	68		pla				pla
.a6f8	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a6fb	68		pla				pla
.a6fc	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a6ff	7a		ply				ply 								; and exit
.a700	68		pla				pla
.a701	60		rts				rts
.a702					_ITSSubtractors:
>a702	00 ca 9a 3b					.dword 		1000000000
>a706	00 e1 f5 05					.dword 		100000000
>a70a	80 96 98 00					.dword 		10000000
>a70e	40 42 0f 00					.dword 		1000000
>a712	a0 86 01 00					.dword 		100000
>a716	10 27 00 00					.dword 		10000
>a71a	e8 03 00 00					.dword 		1000
>a71e	64 00 00 00					.dword 		100
>a722	0a 00 00 00					.dword 		10
.a726					_ITSSubtractorsEnd:
.a726					ITSOutputCharacter:
.a726	48		pha				pha
.a727	da		phx				phx
.a728	ae 20 08	ldx $0820			ldx 	SBPosition 					; save digit
.a72b	9d 00 08	sta $0800,x			sta 	SBuffer,x
.a72e	9e 01 08	stz $0801,x			stz 	SBuffer+1,x
.a731	ee 20 08	inc $0820			inc 	SBPosition					; bump pointer.
.a734	fa		plx				plx
.a735	68		pla				pla
.a736	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/intfromstr.asm

.a737					IntFromString:
.a737	a0 00		ldy #$00			ldy 	#0 							; from (zTemp0)
.a739	8c 25 08	sty $0825			sty 	IFSHexFlag
.a73c	b2 14		lda ($14)			lda 	(zTemp0)					; check &
.a73e	c9 26		cmp #$26			cmp 	#"&"
.a740	d0 04		bne $a746			bne 	_IFSNotHex
.a742	ce 25 08	dec $0825			dec 	IFSHexFlag 					; hex flag = $FF
.a745	c8		iny				iny 								; skip
.a746					_IFSNotHex:
.a746	e8		inx				inx 								; space on stack
.a747	20 a3 a7	jsr $a7a3			jsr 	IFSClearTOS
.a74a					_IFSLoop:
.a74a	ad 25 08	lda $0825			lda 	IFSHexFlag 					; check in hex mode ?
.a74d	f0 0a		beq $a759			beq 	_IFSDecOnly
.a74f	b1 14		lda ($14),y			lda 	(zTemp0),y 					; get next
.a751	c9 41		cmp #$41			cmp 	#"A"
.a753	90 04		bcc $a759			bcc 	_IFSDecOnly
.a755	c9 47		cmp #$47			cmp 	#"F"+1
.a757	90 0a		bcc $a763			bcc 	_IFSOkDigit
.a759					_IFSDecOnly:
.a759	b1 14		lda ($14),y			lda 	(zTemp0),y 					; get next
.a75b	c9 30		cmp #$30			cmp 	#"0"						; validate it as range 0-9
.a75d	90 3e		bcc $a79d			bcc 	_IFSExit
.a75f	c9 3a		cmp #$3a			cmp 	#"9"+1
.a761	b0 3a		bcs $a79d			bcs 	_IFSExit
.a763					_IFSOkDigit:
.a763	ad 25 08	lda $0825			lda 	IFSHexFlag
.a766	d0 11		bne $a779			bne 	_IFSHexShift
.a768	20 32 aa	jsr $aa32			jsr 	Stack_Dup 					; duplicate tos
.a76b	20 39 ab	jsr $ab39			jsr 	Unary_Shl	 				; x 2
.a76e	20 39 ab	jsr $ab39			jsr 	Unary_Shl 					; x 4
.a771	20 04 ac	jsr $ac04			jsr 	Stack_Add 					; x 5
.a774	20 39 ab	jsr $ab39			jsr 	Unary_Shl 					; x 10
.a777	80 0c		bra $a785			bra 	_IFSAddIn
.a779					_IFSHexShift:
.a779	20 39 ab	jsr $ab39			jsr 	Unary_Shl	 				; x 2
.a77c	20 39 ab	jsr $ab39			jsr 	Unary_Shl	 				; x 4
.a77f	20 39 ab	jsr $ab39			jsr 	Unary_Shl	 				; x 8
.a782	20 39 ab	jsr $ab39			jsr 	Unary_Shl	 				; x 16
.a785					_IFSAddIn:
.a785	e8		inx				inx  								; create space next up
.a786	20 a3 a7	jsr $a7a3			jsr 	IFSClearTOS
.a789	b1 14		lda ($14),y			lda 	(zTemp0),y 					; add digit
.a78b	c9 41		cmp #$41			cmp 	#"A"
.a78d	90 03		bcc $a792			bcc 	_IFSDec
.a78f	38		sec				sec 								; hex fixup.
.a790	e9 07		sbc #$07			sbc 	#7
.a792					_IFSDec:
.a792	29 0f		and #$0f			and 	#15
.a794	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; tos is new add
.a797	20 04 ac	jsr $ac04			jsr 	Stack_Add 					; add to tos
.a79a	c8		iny				iny
.a79b	80 ad		bra $a74a			bra 	_IFSLoop
.a79d					_IFSExit:
.a79d	98		tya				tya
.a79e	38		sec				sec
.a79f	f0 01		beq $a7a2			beq 	_IFSSkipFail
.a7a1	18		clc				clc
.a7a2					_IFSSkipFail:
.a7a2	60		rts				rts
.a7a3					IFSClearTOS:
.a7a3	9e 00 0c	stz $0c00,x			stz		stack0,x
.a7a6	9e 00 0d	stz $0d00,x			stz		stack1,x
.a7a9	9e 00 0e	stz $0e00,x			stz		stack2,x
.a7ac	9e 00 0f	stz $0f00,x			stz		stack3,x
.a7af	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/tokeniser.asm

.a7b0					Tokenise:
.a7b0	da		phx				phx
.a7b1	a0 ff		ldy #$ff			ldy 	#255 						; predecrement
.a7b3					_TKSkip:
.a7b3	c8		iny				iny
.a7b4					_TKMainLoop:
.a7b4	b1 10		lda ($10),y			lda 	(codePtr),y 				; get and check end.
.a7b6	f0 06		beq $a7be			beq 	_TKExit
.a7b8	c9 20		cmp #$20			cmp 	#" "
.a7ba	f0 f7		beq $a7b3			beq 	_TKSkip
.a7bc	80 04		bra $a7c2			bra 	_TKNotEnd
.a7be	92 16		sta ($16)	_TKExit:sta 	(zTemp1) 					; and ending $00
.a7c0	fa		plx				plx
.a7c1	60		rts				rts
.a7c2					_TKNotEnd:
.a7c2	c9 22		cmp #$22			cmp 	#'"'
.a7c4	f0 04		beq $a7ca			beq 	_TKIsQuote
.a7c6	c9 27		cmp #$27			cmp 	#"'"
.a7c8	d0 05		bne $a7cf			bne 	_TKNotQuote
.a7ca					_TKIsQuote:
.a7ca	20 ee a8	jsr $a8ee			jsr		TOKQuotedString
.a7cd	80 e5		bra $a7b4			bra 	_TKMainLoop
.a7cf					_TKNotQuote:
.a7cf	98		tya				tya 								; current pos -> zTemp0
.a7d0	18		clc				clc
.a7d1	65 10		adc $10				adc 	codePtr
.a7d3	85 14		sta $14				sta 	zTemp0
.a7d5	85 10		sta $10				sta 	codePtr
.a7d7	a5 11		lda $11				lda 	codePtr+1
.a7d9	69 00		adc #$00			adc 	#0
.a7db	85 15		sta $15				sta 	zTemp0+1
.a7dd	85 11		sta $11				sta 	codePtr+1
.a7df	a0 00		ldy #$00			ldy 	#0 							; reset and get character
.a7e1	b1 10		lda ($10),y			lda 	(codePtr),y
.a7e3	c9 26		cmp #$26			cmp 	#"&"						; hex marker
.a7e5	f0 08		beq $a7ef			beq 	_TKIsNumber
.a7e7	c9 30		cmp #$30			cmp 	#"0"						; check for decimal.
.a7e9	90 23		bcc $a80e			bcc 	_TKNotNumber
.a7eb	c9 3a		cmp #$3a			cmp 	#"9"+1
.a7ed	b0 1f		bcs $a80e			bcs 	_TKNotNumber
.a7ef					_TKIsNumber:
.a7ef	e8		inx				inx
.a7f0	20 37 a7	jsr $a737			jsr 	IntFromString 				; convert to integer
.a7f3	48		pha				pha
.a7f4	20 c6 a8	jsr $a8c6			jsr 	TokWriteConstant 			; do constant recursively.
.a7f7	7a		ply				ply
.a7f8	ca		dex				dex
.a7f9	b1 10		lda ($10),y			lda 	(codePtr),y
.a7fb	c9 2d		cmp #$2d			cmp 	#"-"						; followed by minus
.a7fd	d0 08		bne $a807			bne 	_TKIsPositive
.a7ff	c8		iny				iny									; skip it
.a800	a9 4f		lda #$4f			lda 	#KWD_CONSTANT_MINUS
.a802	20 bd a8	jsr $a8bd			jsr 	TokWriteToken 				; write token out
.a805	80 ad		bra $a7b4			bra 	_TKMainLoop 				; loop back.
.a807					_TKIsPositive:
.a807	a9 4e		lda #$4e			lda 	#KWD_CONSTANT_PLUS
.a809	20 bd a8	jsr $a8bd			jsr 	TokWriteToken 				; write token out
.a80c	80 a6		bra $a7b4			bra 	_TKMainLoop 				; loop back.
.a80e					_TKNotNumber:
.a80e	a9 0c		lda #$0c			lda 	#KeywordText & $FF 			; zTemp2 -> token table
.a810	85 18		sta $18				sta 	zTemp2
.a812	a9 a1		lda #$a1			lda 	#KeywordText >> 8
.a814	85 19		sta $19				sta 	zTemp2+1
.a816	64 1a		stz $1a				stz 	zTemp3 						; clear 'best'
.a818	a9 10		lda #$10			lda 	#$10
.a81a	85 1b		sta $1b				sta 	zTemp3+1 					; set current token
.a81c					_TKSearch:
.a81c	a0 00		ldy #$00			ldy 	#0
.a81e					_TKCompare:
.a81e	b1 10		lda ($10),y			lda 	(codePtr),y 	 			; get char from buffer
.a820	c8		iny				iny
.a821	d1 18		cmp ($18),y			cmp 	(zTemp2),y 					; does it match.
.a823	d0 07		bne $a82c			bne 	_TKNext
.a825	98		tya				tya
.a826	d2 18		cmp ($18)			cmp 	(zTemp2) 					; Y = length
.a828	d0 f4		bne $a81e			bne 	_TKCompare 					; found a match.
.a82a	80 13		bra $a83f			bra 	_TKFound
.a82c	b2 18		lda ($18)	_TKNext:lda 	(zTemp2)					; get length
.a82e	38		sec				sec 								; add length+1 to current
.a82f	65 18		adc $18				adc 	zTemp2
.a831	85 18		sta $18				sta 	zTemp2
.a833	90 02		bcc $a837			bcc 	_TKNNC
.a835	e6 19		inc $19				inc 	zTemp2+1
.a837	e6 1b		inc $1b		_TKNNC:	inc 	zTemp3+1 					; increment current token
.a839	b2 18		lda ($18)			lda 	(zTemp2) 					; reached then end
.a83b	d0 df		bne $a81c			bne 	_TKSearch 					; go try again.
.a83d	80 0f		bra $a84e			bra 	_TKComplete
.a83f					_TKFound:
.a83f	98		tya				tya
.a840	c5 1a		cmp $1a				cmp 	zTemp3 						; check best
.a842	90 e8		bcc $a82c			bcc 	_TKNext 					; if < best try next
.a844	f0 e6		beq $a82c			beq 	_TKNext 					; if equal this is one of the special +- tokens
.a846	85 1a		sta $1a				sta 	zTemp3 						; update best
.a848	a5 1b		lda $1b				lda 	zTemp3+1 					; save current token.
.a84a	85 1c		sta $1c				sta 	zTemp4
.a84c	80 de		bra $a82c			bra 	_TKNext
.a84e					_TKComplete:
.a84e	a5 1a		lda $1a				lda 	zTemp3 						; get "best score"
.a850	f0 1a		beq $a86c			beq		_TKTokenFail 				; if zero no match occurred
.a852	a4 1a		ldy $1a				ldy 	zTemp3 						; length in Y
.a854	88		dey				dey
.a855	b1 10		lda ($10),y			lda 	(codePtr),y 				; look at last character
.a857	c8		iny				iny
.a858	20 ad a8	jsr $a8ad			jsr 	TOKIsIdentifier 			; identifier character
.a85b	90 07		bcc $a864			bcc 	_TKOutput 					; if not, then token is okay
.a85d	b1 10		lda ($10),y			lda 	(codePtr),y 				; look at character after
.a85f	20 ad a8	jsr $a8ad			jsr 	TOKIsIdentifier 			; is that an identifier
.a862	b0 08		bcs $a86c			bcs 	_TKTokenFail 				; if so it must be something like DEFAULT (DEF-AULT)
.a864					_TKOutput:
.a864	a5 1c		lda $1c				lda 	zTemp4 						; output actual token
.a866	20 bd a8	jsr $a8bd			jsr 	TOKWriteToken
.a869	4c b4 a7	jmp $a7b4			jmp 	_TKMainLoop					; go round again
.a86c					_TKTokenFail:
.a86c	a0 00		ldy #$00			ldy 	#0
.a86e	b2 10		lda ($10)			lda 	(codePtr) 					; is the first an identifier ?
.a870	20 ad a8	jsr $a8ad			jsr 	TOKIsIdentifier
.a873	b0 13		bcs $a888			bcs 	_TKCopyIdent 				; if yes copy it
.a875	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>a878	43 41 4e 4e 4f 54 20 54				.text 	"CANNOT TOKENISE",0
>a880	4f 4b 45 4e 49 53 45 00
.a888					_TKCopyIdent:
.a888	c8		iny				iny 								; get next
.a889	b1 10		lda ($10),y			lda 	(codePtr),y
.a88b	20 ad a8	jsr $a8ad			jsr 	TOKIsIdentifier 			; if identifier
.a88e	08		php				php 								; save CS on stack
.a88f	88		dey				dey 								; back to character
.a890	b1 10		lda ($10),y			lda 	(codePtr),y 				; get it
.a892	c8		iny				iny
.a893	c9 2e		cmp #$2e			cmp 	#"."
.a895	d0 02		bne $a899			bne 	_TKNotDot
.a897	a9 60		lda #$60			lda 	#'A'+31 					; to map . to 31
.a899					_TKNotDot:
.a899	38		sec				sec
.a89a	e9 41		sbc #$41			sbc		#'A'
.a89c	09 c0		ora #$c0			ora 	#$C0 						; in right range
.a89e	28		plp				plp 								; CS if next is identifier
.a89f	08		php				php
.a8a0	b0 02		bcs $a8a4			bcs 	_TKNotLast					; CC if next is not identifier
.a8a2	09 e0		ora #$e0			ora 	#$E0 						; range E0-FF
.a8a4					_TKNotLast:
.a8a4	20 bd a8	jsr $a8bd			jsr 	TOKWriteToken 				; write out
.a8a7	28		plp				plp 								; get test result
.a8a8	b0 de		bcs $a888			bcs 	_TKCopyIdent 				; get the next identifier.
.a8aa	4c b4 a7	jmp $a7b4			jmp 	_TKMainLoop
.a8ad					TOKIsIdentifier:
.a8ad	c9 2e		cmp #$2e			cmp 	#"."
.a8af	f0 08		beq $a8b9			beq 	_TIIYes
.a8b1	c9 41		cmp #$41			cmp 	#"A"
.a8b3	90 06		bcc $a8bb			bcc 	_TIINo
.a8b5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.a8b7	b0 02		bcs $a8bb			bcs 	_TIINo
.a8b9					_TIIYes:
.a8b9	38		sec				sec
.a8ba	60		rts				rts
.a8bb					_TIINo:
.a8bb	18		clc				clc
.a8bc	60		rts				rts
.a8bd					TokWriteToken:
.a8bd	92 16		sta ($16)			sta 	(zTemp1)
.a8bf	e6 16		inc $16				inc 	zTemp1
.a8c1	d0 02		bne $a8c5			bne 	_TWTExit
.a8c3	e6 17		inc $17				inc 	zTemp1+1
.a8c5					_TWTExit:
.a8c5	60		rts				rts
.a8c6					TokWriteConstant:
.a8c6	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; get current
.a8c9	29 3f		and #$3f			and		#63
.a8cb	48		pha				pha 								; save on stack
.a8cc	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check if < 64
.a8cf	29 c0		and #$c0			and 	#$C0
.a8d1	1d 00 0d	ora $0d00,x			ora 	stack1,x
.a8d4	1d 00 0e	ora $0e00,x			ora 	stack2,x
.a8d7	1d 00 0f	ora $0f00,x			ora 	stack3,x
.a8da	f0 0d		beq $a8e9			beq 	_TWCNoCall 					; no, don't call.
.a8dc	5a		phy				phy
.a8dd	a0 06		ldy #$06			ldy 	#6
.a8df					_TWCShift:
.a8df	20 46 ab	jsr $ab46			jsr 	Unary_Shr
.a8e2	88		dey				dey
.a8e3	d0 fa		bne $a8df			bne 	_TWCShift
.a8e5	7a		ply				ply
.a8e6	20 c6 a8	jsr $a8c6			jsr 	TokWriteConstant
.a8e9					_TWCNoCall:
.a8e9	68		pla				pla
.a8ea	09 80		ora #$80			ora 	#$80						; make digit token
.a8ec	80 cf		bra $a8bd			bra 	TokWriteToken 				; and write it out.
.a8ee					TokQuotedString:
.a8ee	85 18		sta $18				sta 	zTemp2 						; save quote
.a8f0	49 22		eor #$22			eor 	#'"'						; now zero if double quotes
.a8f2	f0 02		beq $a8f6			beq 	_TQDouble
.a8f4	a9 01		lda #$01			lda 	#1
.a8f6					_TQDouble:
.a8f6	1a		inc a				inc 	a 							; 1 for double, 2 for single
.a8f7	20 bd a8	jsr $a8bd			jsr 	TOKWriteToken 				; write out
.a8fa	a5 16		lda $16				lda 	zTemp1 						; copy zTemp1 to zTemp3 (byte count addr)
.a8fc	85 1a		sta $1a				sta 	zTemp3
.a8fe	a5 17		lda $17				lda 	zTemp1+1
.a900	85 1b		sta $1b				sta 	zTemp3+1
.a902	a9 03		lda #$03			lda 	#3 							; 3 is the size if it is empty - type,size,null
.a904	20 bd a8	jsr $a8bd			jsr 	TOKWriteToken
.a907					_TQLoop:
.a907	c8		iny				iny 								; next character
.a908	b1 10		lda ($10),y			lda 	(codePtr),y
.a90a	f0 0f		beq $a91b			beq 	_TQExit 					; if zero exit
.a90c	c5 18		cmp $18				cmp 	zTemp2 						; matching quote
.a90e	f0 0a		beq $a91a			beq 	_TQSkipExit 				; skip it and exit
.a910	20 bd a8	jsr $a8bd			jsr 	TOKWriteToken 				; write out
.a913	b2 1a		lda ($1a)			lda 	(zTemp3)					; inc char count
.a915	1a		inc a				inc 	a
.a916	92 1a		sta ($1a)			sta 	(zTemp3)
.a918	80 ed		bra $a907			bra 	_TQLoop						; go round
.a91a					_TQSkipExit:
.a91a	c8		iny				iny
.a91b					_TQExit:
.a91b	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.a91d	20 bd a8	jsr $a8bd			jsr 	TOKWriteToken
.a920	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/editor.asm

.a921					EditProgram:
.a921	ad 89 10	lda $1089			lda 	VarMemory+1
.a924	1a		inc a				inc 	a
.a925	c9 9f		cmp #$9f			cmp 	#MemoryEnd >> 8
.a927	b0 3c		bcs $a965			bcs 	_EPMemory
.a929	a2 00		ldx #$00			ldx 	#0
.a92b	a9 03		lda #$03			lda 	#(TokeniseBuffer+3) & $FF
.a92d	85 10		sta $10				sta 	codePtr
.a92f	a9 0a		lda #$0a			lda 	#(TokeniseBuffer+3) >> 8
.a931	85 11		sta $11				sta 	codePtr+1
.a933	a0 00		ldy #$00			ldy 	#0
.a935	a2 ff		ldx #$ff			ldx 	#255
.a937	20 07 a4	jsr $a407			jsr 	ExtractIntegerToTOS
.a93a	98		tya				tya
.a93b	18		clc				clc
.a93c	65 10		adc $10				adc 	codePtr
.a93e	85 10		sta $10				sta 	codePtr
.a940	90 02		bcc $a944			bcc 	_EPNoCarry
.a942	e6 11		inc $11				inc 	codePtr+1
.a944					_EPNoCarry:
.a944	20 68 a9	jsr $a968			jsr 	EDFindLine
.a947	90 0f		bcc $a958			bcc 	_EPNotFound
.a949	a5 16		lda $16				lda 	zTemp1
.a94b	48		pha				pha
.a94c	a5 17		lda $17				lda 	zTemp1+1
.a94e	48		pha				pha
.a94f	20 9f a9	jsr $a99f			jsr 	EDDeleteLine
.a952	68		pla				pla
.a953	85 17		sta $17				sta 	zTemp1+1
.a955	68		pla				pla
.a956	85 16		sta $16				sta 	zTemp1
.a958					_EPNotFound:
.a958	b2 10		lda ($10)			lda 	(codePtr)
.a95a	f0 03		beq $a95f			beq 	_EPNoInsert
.a95c	20 c4 a9	jsr $a9c4			jsr 	EDInsertLine
.a95f					_EPNoInsert:
.a95f	20 4d a5	jsr $a54d			jsr 	ResetForRun
.a962	4c 52 a0	jmp $a052			jmp 	NewCommand
.a965					_EPMemory:
.a965	4c eb a5	jmp $a5eb			jmp 	OutOfMemoryError
.a968					EDFindLine:
.a968	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; set zTemp1 to start of program
.a96a	85 16		sta $16				sta 	zTemp1
.a96c	a9 11		lda #$11			lda 	#ProgramStart >> 8
.a96e	85 17		sta $17				sta 	zTemp1+1
.a970					_EDFLLoop:
.a970	a0 00		ldy #$00			ldy 	#0 							; reached the end
.a972	b1 16		lda ($16),y			lda 	(zTemp1),y
.a974	f0 25		beq $a99b			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.a976	c8		iny				iny
.a977	38		sec				sec
.a978	ad 00 0c	lda $0c00			lda 	stack0						; subtract the current from the target
.a97b	f1 16		sbc ($16),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.a97d	aa		tax				tax	 								; this will return 10.
.a97e	ad 00 0d	lda $0d00			lda 	stack1
.a981	c8		iny				iny
.a982	f1 16		sbc ($16),y			sbc 	(zTemp1),y
.a984	90 15		bcc $a99b			bcc 	_EDFLFail					; if target < current then failed.
.a986	d0 04		bne $a98c			bne 	_EDFLNext 					; if non-zero then goto next
.a988	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.a98a	f0 11		beq $a99d			beq 	_EDFLFound
.a98c					_EDFLNext:
.a98c	a0 00		ldy #$00			ldy 	#0 							; get offset
.a98e	18		clc				clc
.a98f	b1 16		lda ($16),y			lda 	(zTemp1),y
.a991	65 16		adc $16				adc 	zTemp1 						; add to pointer
.a993	85 16		sta $16				sta 	zTemp1
.a995	90 d9		bcc $a970			bcc 	_EDFLLoop
.a997	e6 17		inc $17				inc 	zTemp1+1 					; carry out.
.a999	80 d5		bra $a970			bra 	_EDFLLoop
.a99b					_EDFLFail:
.a99b	18		clc				clc
.a99c	60		rts				rts
.a99d					_EDFLFound:
.a99d	38		sec				sec
.a99e	60		rts				rts
.a99f					EDDeleteLine:
.a99f	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.a9a1	a2 00		ldx #$00			ldx 	#0
.a9a3	b1 16		lda ($16),y			lda 	(zTemp1),y
.a9a5	a8		tay				tay 								; put in Y
.a9a6					_EDDelLoop:
.a9a6	b1 16		lda ($16),y			lda 	(zTemp1),y 					; get it
.a9a8	81 16		sta ($16,x)			sta 	(zTemp1,x) 					; write it.
.a9aa	a5 16		lda $16				lda 	zTemp1 						; check if pointer has reached the end of
.a9ac	cd 88 10	cmp $1088			cmp		VarMemory 					; low memory. We will have copied down an
.a9af	d0 07		bne $a9b8			bne 	_EDDelNext 					; extra pile of stuff - technically should
.a9b1	a5 17		lda $17				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.a9b3	cd 89 10	cmp $1089			cmp 	VarMemory+1					; doesn't really matter.
.a9b6	f0 08		beq $a9c0			beq		_EDDelExit
.a9b8					_EDDelNext:
.a9b8	e6 16		inc $16				inc 	zTemp1 						; go to next byte.
.a9ba	d0 ea		bne $a9a6			bne 	_EDDelLoop
.a9bc	e6 17		inc $17				inc 	zTemp1+1
.a9be	80 e6		bra $a9a6			bra 	_EDDelLoop
.a9c0					_EDDelExit:
.a9c0	20 73 a5	jsr $a573			jsr 	ResetVarMemory
.a9c3	60		rts				rts
.a9c4					EDInsertLine:
.a9c4	ad 88 10	lda $1088			lda 	VarMemory 					; copy high memory to zTemp3
.a9c7	85 1a		sta $1a				sta 	zTemp3
.a9c9	ad 89 10	lda $1089			lda 	VarMemory+1
.a9cc	85 1b		sta $1b				sta 	zTemp3+1
.a9ce	a0 00		ldy #$00			ldy 	#0 							; work out the line length.
.a9d0					_EDGetLength:
.a9d0	b1 10		lda ($10),y			lda 	(codePtr),y  				; get token
.a9d2	f0 0d		beq $a9e1			beq 	_EDGotLength 				; if 0, Y is the length
.a9d4	c8		iny				iny
.a9d5	c9 03		cmp #$03			cmp 	#3 							; 1 and 2 are ASCIIZ strings so skip them.
.a9d7	b0 f7		bcs $a9d0			bcs 	_EDGetLength
.a9d9	98		tya				tya 								; get original position
.a9da	3a		dec a				dec 	a
.a9db	18		clc				clc
.a9dc	71 10		adc ($10),y			adc 	(codePtr),y
.a9de	a8		tay				tay
.a9df	80 ef		bra $a9d0			bra 	_EDGetLength
.a9e1					_EDGotLength:
.a9e1	98		tya				tya
.a9e2	18		clc				clc
.a9e3	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.a9e5	48		pha				pha 								; save total size (e.g. offset)
.a9e6	85 1c		sta $1c				sta 	zTemp4 						; save for copying
.a9e8	a8		tay				tay 								; in Y
.a9e9	a2 00		ldx #$00			ldx 	#0
.a9eb					_EDInsLoop:
.a9eb	a1 1a		lda ($1a,x)			lda 	(zTemp3,x)					; copy it up
.a9ed	91 1a		sta ($1a),y			sta 	(zTemp3),y
.a9ef	a5 1a		lda $1a				lda 	zTemp3 						; reached the insert point (zTemp1)
.a9f1	c5 16		cmp $16				cmp 	zTemp1
.a9f3	d0 06		bne $a9fb			bne 	_EDINextShift
.a9f5	a5 1b		lda $1b				lda 	zTemp3+1
.a9f7	c5 17		cmp $17				cmp 	zTemp1+1
.a9f9	f0 0a		beq $aa05			beq 	_EDIShiftOver
.a9fb					_EDINextShift:
.a9fb	a5 1a		lda $1a				lda 	zTemp3 					; decrement the copy pointer.
.a9fd	d0 02		bne $aa01			bne 	_EDINoBorrow
.a9ff	c6 1b		dec $1b				dec 	zTemp3+1
.aa01					_EDINoBorrow:
.aa01	c6 1a		dec $1a				dec 	zTemp3
.aa03	80 e6		bra $a9eb			bra 	_EDInsLoop
.aa05					_EDIShiftOver:
.aa05	68		pla				pla 								; this is the size + others, e.g. offset
.aa06	a0 00		ldy #$00			ldy 	#0
.aa08	91 1a		sta ($1a),y			sta 	(zTemp3),y 					; write that out.
.aa0a	ad 00 0c	lda $0c00			lda 	stack0 						; write LIne# out
.aa0d	c8		iny				iny
.aa0e	91 1a		sta ($1a),y			sta 	(zTemp3),y
.aa10	ad 00 0d	lda $0d00			lda 	stack1
.aa13	c8		iny				iny
.aa14	91 1a		sta ($1a),y			sta 	(zTemp3),y
.aa16	c8		iny				iny 								; where the code goes.
.aa17	a2 00		ldx #$00			ldx 	#0 							; comes from
.aa19					_EDICopyCode:
.aa19	a1 10		lda ($10,x)			lda 	(codePtr,x)					; read from the current line
.aa1b	91 1a		sta ($1a),y			sta 	(zTemp3),y 					; write out
.aa1d	c8		iny				iny 								; bump pointers
.aa1e	e6 10		inc $10				inc 	codePtr
.aa20	d0 02		bne $aa24			bne 	_EDINoCarry
.aa22	e6 11		inc $11				inc 	codePtr+1
.aa24					_EDINoCarry:
.aa24	c6 1c		dec $1c				dec 	zTemp4 						; copy data in
.aa26	a5 1c		lda $1c				lda 	zTemp4 						; this is the total count - first 3 bytes seperate
.aa28	c9 03		cmp #$03			cmp 	#3 							; so exit on 3
.aa2a	d0 ed		bne $aa19			bne 	_EDICopyCode
.aa2c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/stack.asm

.aa2d					Stack_Empty:
.aa2d	a2 00		ldx #$00			ldx 	#0
.aa2f	60		rts				rts
.aa30					Stack_Drop:
.aa30	ca		dex				dex
.aa31	60		rts				rts
.aa32					Stack_Dup:
.aa32	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy to next up
.aa35	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.aa38	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa3b	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.aa3e	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aa41	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.aa44	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aa47	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.aa4a	e8		inx				inx 								; bump stack pointer
.aa4b	60		rts				rts
.aa4c					Stack_Nip:
.aa4c	bd 00 0c	lda $0c00,x			lda 	stack0,x	 				; copy top to 2nd
.aa4f	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.aa52	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa55	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.aa58	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aa5b	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.aa5e	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aa61	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.aa64	ca		dex				dex 								; drop tos
.aa65	60		rts				rts
.aa66					Stack_Over:
.aa66	bd ff 0b	lda $0bff,x			lda 	stack0-1,x				; copy to next up
.aa69	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.aa6c	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.aa6f	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.aa72	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.aa75	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.aa78	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.aa7b	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.aa7e	e8		inx				inx 							; bump stack pointer
.aa7f	60		rts				rts
.aa80					Stack_Swap:
.aa80	5a		phy				phy
.aa81	bd 00 0c	lda $0c00,x			lda 	stack0,x
.aa84	a8		tay				tay
.aa85	bd ff 0b	lda $0bff,x			lda 	stack0-1,x
.aa88	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aa8b	98		tya				tya
.aa8c	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.aa8f	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa92	a8		tay				tay
.aa93	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.aa96	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aa99	98		tya				tya
.aa9a	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.aa9d	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aaa0	a8		tay				tay
.aaa1	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.aaa4	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aaa7	98		tya				tya
.aaa8	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.aaab	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aaae	a8		tay				tay
.aaaf	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.aab2	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aab5	98		tya				tya
.aab6	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.aab9	7a		ply				ply
.aaba	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/unary.asm

.aabb					Unary_Absolute:
.aabb	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aabe	30 01		bmi $aac1			bmi 	Unary_Negate
.aac0	60		rts				rts
.aac1					Unary_Negate:
.aac1	38		sec				sec
.aac2	a9 00		lda #$00			lda		#0
.aac4	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.aac7	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aaca	a9 00		lda #$00			lda		#0
.aacc	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.aacf	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aad2	a9 00		lda #$00			lda		#0
.aad4	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.aad7	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aada	a9 00		lda #$00			lda		#0
.aadc	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.aadf	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aae2	60		rts				rts
.aae3					Unary_Not:
.aae3	bd 00 0c	lda $0c00,x			lda 	stack0,x
.aae6	49 ff		eor #$ff			eor 	#$FF
.aae8	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aaeb	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aaee	49 ff		eor #$ff			eor 	#$FF
.aaf0	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aaf3	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aaf6	49 ff		eor #$ff			eor 	#$FF
.aaf8	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aafb	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aafe	49 ff		eor #$ff			eor 	#$FF
.ab00	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ab03	60		rts				rts
.ab04					Unary_Increment:
.ab04	fe 00 0c	inc $0c00,x			inc 	stack0,x
.ab07	d0 0d		bne $ab16			bne 	_UIExit
.ab09	fe 00 0d	inc $0d00,x			inc 	stack1,x
.ab0c	d0 08		bne $ab16			bne 	_UIExit
.ab0e	fe 00 0e	inc $0e00,x			inc 	stack2,x
.ab11	d0 03		bne $ab16			bne 	_UIExit
.ab13	fe 00 0f	inc $0f00,x			inc 	stack3,x
.ab16					_UIExit:
.ab16	60		rts				rts
.ab17					Unary_Decrement:
.ab17	38		sec				sec
.ab18	bd 00 0c	lda $0c00,x			lda 	stack0,x
.ab1b	e9 01		sbc #$01			sbc 	#1
.ab1d	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ab20	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab23	e9 00		sbc #$00			sbc 	#0
.ab25	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ab28	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ab2b	e9 00		sbc #$00			sbc 	#0
.ab2d	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ab30	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ab33	e9 00		sbc #$00			sbc 	#0
.ab35	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ab38	60		rts				rts
.ab39					Unary_Shl:
.ab39	1e 00 0c	asl $0c00,x			asl 	stack0,x
.ab3c	3e 00 0d	rol $0d00,x			rol 	stack1,x
.ab3f	3e 00 0e	rol $0e00,x			rol 	stack2,x
.ab42	3e 00 0f	rol $0f00,x			rol 	stack3,x
.ab45	60		rts				rts
.ab46					Unary_Shr:
.ab46	5e 00 0f	lsr $0f00,x			lsr 	stack3,x
.ab49	7e 00 0e	ror $0e00,x			ror 	stack2,x
.ab4c	7e 00 0d	ror $0d00,x			ror 	stack1,x
.ab4f	7e 00 0c	ror $0c00,x			ror 	stack0,x
.ab52	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/memory.asm

.ab53					Mem_Peek:
.ab53	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.ab56	85 14		sta $14				sta 	zTemp0
.ab58	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab5b	85 15		sta $15				sta 	zTemp0+1
.ab5d	b2 14		lda ($14)			lda 	(zTemp0)					; read byte
.ab5f	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.ab62	9e 00 0d	stz $0d00,x			stz 	stack1,x
.ab65	9e 00 0e	stz $0e00,x			stz 	stack2,x
.ab68	9e 00 0f	stz $0f00,x			stz 	stack3,x
.ab6b	60		rts				rts
.ab6c					Mem_WPeek:
.ab6c	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.ab6f	85 14		sta $14				sta 	zTemp0
.ab71	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab74	85 15		sta $15				sta 	zTemp0+1
.ab76	b2 14		lda ($14)			lda 	(zTemp0)					; read byte
.ab78	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.ab7b	5a		phy				phy 								; read msb
.ab7c	a0 01		ldy #$01			ldy 	#1
.ab7e	b1 14		lda ($14),y			lda 	(zTemp0),y
.ab80	7a		ply				ply
.ab81	9d 00 0d	sta $0d00,x			sta 	stack1,x 				; write to stack
.ab84	9e 00 0e	stz $0e00,x			stz 	stack2,x
.ab87	9e 00 0f	stz $0f00,x			stz 	stack3,x
.ab8a	60		rts				rts
.ab8b					Mem_DPeek:
.ab8b	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.ab8e	85 14		sta $14				sta 	zTemp0
.ab90	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab93	85 15		sta $15				sta 	zTemp0+1
.ab95	b2 14		lda ($14)			lda 	(zTemp0)					; read byte
.ab97	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.ab9a	5a		phy				phy 								; read msb
.ab9b	a0 01		ldy #$01			ldy 	#1
.ab9d	b1 14		lda ($14),y			lda 	(zTemp0),y
.ab9f	9d 00 0d	sta $0d00,x			sta 	stack1,x 					; write to stack
.aba2	c8		iny				iny
.aba3	b1 14		lda ($14),y			lda 	(zTemp0),y
.aba5	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aba8	c8		iny				iny
.aba9	b1 14		lda ($14),y			lda 	(zTemp0),y
.abab	9d 00 0f	sta $0f00,x			sta 	stack3,x
.abae	7a		ply				ply
.abaf	60		rts				rts
.abb0					Mem_Poke:
.abb0	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.abb3	85 14		sta $14				sta 	zTemp0
.abb5	bd 00 0d	lda $0d00,x			lda 	stack1,x
.abb8	85 15		sta $15				sta 	zTemp0+1
.abba	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.abbd	92 14		sta ($14)			sta 	(zTemp0)
.abbf	ca		dex				dex
.abc0	ca		dex				dex
.abc1	60		rts				rts
.abc2					Mem_WPoke:
.abc2	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.abc5	85 14		sta $14				sta 	zTemp0
.abc7	bd 00 0d	lda $0d00,x			lda 	stack1,x
.abca	85 15		sta $15				sta 	zTemp0+1
.abcc	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.abcf	92 14		sta ($14)			sta 	(zTemp0)
.abd1	5a		phy				phy
.abd2	a0 01		ldy #$01			ldy 	#1
.abd4	bd ff 0e	lda $0eff,x			lda 	stack3-1,x 				; byte to write
.abd7	91 14		sta ($14),y			sta 	(zTemp0),y
.abd9	7a		ply				ply
.abda	ca		dex				dex
.abdb	ca		dex				dex
.abdc	60		rts				rts
.abdd					Mem_DPoke:
.abdd	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.abe0	85 14		sta $14				sta 	zTemp0
.abe2	bd 00 0d	lda $0d00,x			lda 	stack1,x
.abe5	85 15		sta $15				sta 	zTemp0+1
.abe7	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 					; byte to write
.abea	92 14		sta ($14)			sta 	(zTemp0)
.abec	5a		phy				phy
.abed	a0 01		ldy #$01			ldy 	#1
.abef	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.abf2	91 14		sta ($14),y			sta 	(zTemp0),y
.abf4	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.abf7	c8		iny				iny
.abf8	91 14		sta ($14),y			sta 	(zTemp0),y
.abfa	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.abfd	c8		iny				iny
.abfe	91 14		sta ($14),y			sta 	(zTemp0),y
.ac00	7a		ply				ply
.ac01	ca		dex				dex
.ac02	ca		dex				dex
.ac03	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/binary.asm

.ac04					Stack_Add:
.ac04	ca		dex				dex
.ac05					Stack_Add_No_Dex:
.ac05	18		clc				clc
.ac06	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac09	7d 01 0c	adc $0c01,x			adc 	stack0+1,x
.ac0c	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac0f	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac12	7d 01 0d	adc $0d01,x			adc 	stack1+1,x
.ac15	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac18	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac1b	7d 01 0e	adc $0e01,x			adc 	stack2+1,x
.ac1e	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac21	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac24	7d 01 0f	adc $0f01,x			adc 	stack3+1,x
.ac27	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac2a	60		rts				rts
.ac2b					Stack_Sub:
.ac2b	ca		dex				dex
.ac2c	38		sec				sec
.ac2d	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac30	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.ac33	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac36	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac39	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.ac3c	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac3f	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac42	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ac45	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac48	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac4b	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ac4e	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac51	60		rts				rts
.ac52					Stack_And:
.ac52	ca		dex				dex
.ac53	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac56	3d 01 0c	and $0c01,x			and		stack0+1,x
.ac59	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac5c	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac5f	3d 01 0d	and $0d01,x			and 	stack1+1,x
.ac62	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac65	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac68	3d 01 0e	and $0e01,x			and 	stack2+1,x
.ac6b	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac6e	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac71	3d 01 0f	and $0f01,x			and 	stack3+1,x
.ac74	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac77	60		rts				rts
.ac78					Stack_Xor:
.ac78	ca		dex				dex
.ac79	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac7c	5d 01 0c	eor $0c01,x			eor		stack0+1,x
.ac7f	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac82	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac85	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.ac88	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac8b	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac8e	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.ac91	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac94	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac97	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.ac9a	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac9d	60		rts				rts
.ac9e					Stack_Or:
.ac9e	ca		dex				dex
.ac9f	bd 00 0c	lda $0c00,x			lda		stack0,x
.aca2	1d 01 0c	ora $0c01,x			ora		stack0+1,x
.aca5	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aca8	bd 00 0d	lda $0d00,x			lda		stack1,x
.acab	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.acae	9d 00 0d	sta $0d00,x			sta 	stack1,x
.acb1	bd 00 0e	lda $0e00,x			lda		stack2,x
.acb4	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.acb7	9d 00 0e	sta $0e00,x			sta 	stack2,x
.acba	bd 00 0f	lda $0f00,x			lda		stack3,x
.acbd	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.acc0	9d 00 0f	sta $0f00,x			sta 	stack3,x
.acc3	60		rts				rts
.acc4					Stack_Shl:
.acc4	38		sec				sec
.acc5	80 01		bra $acc8			bra 	StackShift
.acc7					Stack_Shr:
.acc7	18		clc				clc
.acc8					StackShift:
.acc8	08		php				php
.acc9	ca		dex				dex
.acca	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; if the shift >= 32
.accd	29 e0		and #$e0			and 	#$E0 						; going to be zero.
.accf	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.acd2	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.acd5	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.acd8	d0 13		bne $aced			bne 	_SSZero
.acda					_SSLoop:
.acda	de 01 0c	dec $0c01,x			dec 	stack0+1,x 					; dec check count
.acdd	30 1a		bmi $acf9			bmi 	_SSDone 					; completed ?
.acdf	28		plp				plp 								; restore flag
.ace0	08		php				php
.ace1	b0 05		bcs $ace8			bcs 	_SSLeft 					; do either shift.
.ace3	20 46 ab	jsr $ab46			jsr 	Unary_Shr
.ace6	80 f2		bra $acda			bra 	_SSLoop
.ace8					_SSLeft:
.ace8	20 39 ab	jsr $ab39			jsr 	Unary_Shl
.aceb	80 ed		bra $acda			bra 	_SSLoop
.aced					_SSZero:
.aced	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; too many shifts.
.acf0	9e 00 0d	stz $0d00,x			stz 	stack1,x
.acf3	9e 00 0e	stz $0e00,x			stz 	stack2,x
.acf6	9e 00 0f	stz $0f00,x			stz 	stack3,x
.acf9					_SSDone:
.acf9	28		plp				plp 								; throw flag.
.acfa	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/multiply.asm

.acfb					MulInteger32:
.acfb	ca		dex				dex
.acfc	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy +0 to workspace
.acff	85 1e		sta $1e				sta 	zLTemp1
.ad01	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ad04	85 1f		sta $1f				sta 	zLTemp1+1
.ad06	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ad09	85 20		sta $20				sta 	zLTemp1+2
.ad0b	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ad0e	85 21		sta $21				sta 	zLTemp1+3
.ad10	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; zero +0, where the result goes.
.ad13	9e 00 0d	stz $0d00,x			stz 	stack1,x
.ad16	9e 00 0e	stz $0e00,x			stz 	stack2,x
.ad19	9e 00 0f	stz $0f00,x			stz 	stack3,x
.ad1c					_BFMMultiply:
.ad1c	a5 1e		lda $1e				lda 	zLTemp1 					; get LSBit of 8-11
.ad1e	29 01		and #$01			and 	#1
.ad20	f0 03		beq $ad25			beq 	_BFMNoAdd
.ad22	20 05 ac	jsr $ac05			jsr 	Stack_Add_No_Dex 			; co-opt this code
.ad25					_BFMNoAdd:
.ad25	1e 01 0c	asl $0c01,x			asl 	stack0+1,x 					; shift +4 left
.ad28	3e 01 0d	rol $0d01,x			rol 	stack1+1,x
.ad2b	3e 01 0e	rol $0e01,x			rol 	stack2+1,x
.ad2e	3e 01 0f	rol $0f01,x			rol 	stack3+1,x
.ad31	46 21		lsr $21				lsr 	zLTemp1+3 					; shift +8 right
.ad33	66 20		ror $20				ror 	zLTemp1+2
.ad35	66 1f		ror $1f				ror 	zLTemp1+1
.ad37	66 1e		ror $1e				ror 	zLTemp1
.ad39	a5 1e		lda $1e				lda 	zLTemp1 					; continue if +8 is nonzero
.ad3b	05 1f		ora $1f				ora 	zLTemp1+1
.ad3d	05 20		ora $20				ora 	zLTemp1+2
.ad3f	05 21		ora $21				ora 	zLTemp1+3
.ad41	d0 d9		bne $ad1c			bne 	_BFMMultiply
.ad43	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/divide.asm

.ad44					DivInteger32:
.ad44	ca		dex				dex
.ad45	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check for division by zero.
.ad48	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.ad4b	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.ad4e	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.ad51	d0 14		bne $ad67			bne 	_BFDOkay
.ad53	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>ad56	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>ad5e	20 42 59 20 5a 45 52 4f 00
.ad67					_BFDOkay:
.ad67	64 1e		stz $1e				stz 	zLTemp1 					; Q/Dividend/Left in +0
.ad69	64 1f		stz $1f				stz 	zLTemp1+1 					; M/Divisor/Right in +4
.ad6b	64 20		stz $20				stz 	zLTemp1+2
.ad6d	64 21		stz $21				stz 	zLTemp1+3
.ad6f	9c 23 08	stz $0823			stz 	SignCount 					; Count of signs.
.ad72	20 cd ad	jsr $adcd			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ad75	e8		inx				inx
.ad76	20 cd ad	jsr $adcd			jsr 	CheckIntegerNegate
.ad79	ca		dex				dex
.ad7a	5a		phy				phy 								; Y is the counter
.ad7b	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.ad7d					_BFDLoop:
.ad7d	1e 00 0c	asl $0c00,x			asl 	stack0,x 					; shift AQ left.
.ad80	3e 00 0d	rol $0d00,x			rol 	stack1,x
.ad83	3e 00 0e	rol $0e00,x			rol 	stack2,x
.ad86	3e 00 0f	rol $0f00,x			rol 	stack3,x
.ad89	26 1e		rol $1e				rol 	zLTemp1
.ad8b	26 1f		rol $1f				rol 	zLTemp1+1
.ad8d	26 20		rol $20				rol 	zLTemp1+2
.ad8f	26 21		rol $21				rol 	zLTemp1+3
.ad91	38		sec				sec
.ad92	a5 1e		lda $1e				lda 	zLTemp1+0 					; Calculate A-M on stack.
.ad94	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.ad97	48		pha				pha
.ad98	a5 1f		lda $1f				lda 	zLTemp1+1
.ad9a	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.ad9d	48		pha				pha
.ad9e	a5 20		lda $20				lda 	zLTemp1+2
.ada0	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ada3	48		pha				pha
.ada4	a5 21		lda $21				lda 	zLTemp1+3
.ada6	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ada9	90 15		bcc $adc0			bcc 	_BFDNoAdd
.adab	85 21		sta $21				sta 	zLTemp1+3 					; update A
.adad	68		pla				pla
.adae	85 20		sta $20				sta 	zLTemp1+2
.adb0	68		pla				pla
.adb1	85 1f		sta $1f				sta 	zLTemp1+1
.adb3	68		pla				pla
.adb4	85 1e		sta $1e				sta 	zLTemp1+0
.adb6	bd 00 0c	lda $0c00,x			lda 	stack0,x 			; set Q bit 1.
.adb9	09 01		ora #$01			ora 	#1
.adbb	9d 00 0c	sta $0c00,x			sta 	stack0,x
.adbe	80 03		bra $adc3			bra 	_BFDNext
.adc0					_BFDNoAdd:
.adc0	68		pla				pla 								; Throw away the intermediate calculations
.adc1	68		pla				pla
.adc2	68		pla				pla
.adc3					_BFDNext:
.adc3	88		dey				dey
.adc4	d0 b7		bne $ad7d			bne 	_BFDLoop
.adc6	7a		ply				ply 								; restore Y
.adc7	4e 23 08	lsr $0823			lsr 	SignCount 					; if sign count odd,
.adca	b0 07		bcs $add3			bcs		IntegerNegateAlways 		; negate the result
.adcc	60		rts				rts
.adcd					CheckIntegerNegate:
.adcd	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; is it -ve = MSB set ?
.add0	30 01		bmi $add3			bmi 	IntegerNegateAlways 		; if so negate it
.add2	60		rts				rts
.add3					IntegerNegateAlways:
.add3	ee 23 08	inc $0823			inc 	SignCount 					; bump the count of signs
.add6	4c c1 aa	jmp $aac1			jmp 	Unary_Negate
.add9					ModInteger32:
.add9	20 44 ad	jsr $ad44			jsr 	DivInteger32
.addc	a5 1e		lda $1e				lda 	zLTemp1
.adde	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ade1	a5 1f		lda $1f				lda 	zLTemp1+1
.ade3	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ade6	a5 20		lda $20				lda 	zLTemp1+2
.ade8	9d 00 0e	sta $0e00,x			sta 	stack2,x
.adeb	a5 21		lda $21				lda 	zLTemp1+3
.aded	9d 00 0f	sta $0f00,x			sta 	stack3,x
.adf0	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/compare.asm

.adf1					Comp_Equal:
.adf1	38		sec				sec
.adf2	80 01		bra $adf5			bra 	Comp_CheckEqual
.adf4					Comp_NotEqual:
.adf4	18		clc				clc
.adf5					Comp_CheckEqual:
.adf5	08		php				php
.adf6	ca		dex				dex
.adf7	bd 00 0c	lda $0c00,x			lda		stack0,x
.adfa	5d 01 0c	eor $0c01,x			eor 	stack0+1,x
.adfd	d0 16		bne $ae15			bne 	_CCENonZero
.adff	bd 00 0d	lda $0d00,x			lda		stack1,x
.ae02	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.ae05	d0 0e		bne $ae15			bne 	_CCENonZero
.ae07	bd 00 0e	lda $0e00,x			lda		stack2,x
.ae0a	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.ae0d	d0 06		bne $ae15			bne 	_CCENonZero
.ae0f	bd 00 0f	lda $0f00,x			lda		stack3,x
.ae12	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.ae15					_CCENonZero:
.ae15	f0 02		beq $ae19			beq 	_CCENotSet
.ae17	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.ae19					_CCENotSet:
.ae19					CompCheckFlip:
.ae19	28		plp				plp 								; if carry set, we want $FF if equal
.ae1a	90 02		bcc $ae1e			bcc 	CompReturn
.ae1c	49 ff		eor #$ff			eor 	#$FF
.ae1e					CompReturn:
.ae1e	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; save result on stack.
.ae21	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ae24	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ae27	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ae2a	60		rts				rts
.ae2b					Comp_Less:
.ae2b	18		clc				clc
.ae2c	80 01		bra $ae2f			bra 	Comp_LessCont
.ae2e					Comp_GreaterEqual:
.ae2e	38		sec				sec
.ae2f					Comp_LessCont:
.ae2f	08		php				php
.ae30	ca		dex				dex
.ae31	38		sec				sec
.ae32	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; do a subtraction w/o storing the result
.ae35	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.ae38	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ae3b	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.ae3e	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ae41	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ae44	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ae47	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ae4a	50 02		bvc $ae4e			bvc 	_CLNoFlip 					; unsigned -> signed
.ae4c	49 80		eor #$80			eor 	#$80
.ae4e					_CLNoFlip:
.ae4e	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.ae50	f0 c7		beq $ae19			beq 	CompCheckFlip
.ae52	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.ae54	80 c3		bra $ae19			bra 	CompCheckFlip
.ae56					Comp_LessEqual:
.ae56	38		sec				sec
.ae57	80 01		bra $ae5a			bra 	Comp_LessEqualCont
.ae59					Comp_Greater:
.ae59	18		clc				clc
.ae5a					Comp_LessEqualCont:
.ae5a	08		php				php
.ae5b	ca		dex				dex
.ae5c	38		sec				sec
.ae5d	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; do a subtraction w/o storing the result, backwards
.ae60	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.ae63	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.ae66	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.ae69	bd 01 0e	lda $0e01,x			lda 	stack2+1,x
.ae6c	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.ae6f	bd 01 0f	lda $0f01,x			lda 	stack3+1,x
.ae72	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.ae75	50 02		bvc $ae79			bvc 	_CLENoFlip 					; unsigned -> signed
.ae77	49 80		eor #$80			eor 	#$80
.ae79					_CLENoFlip:
.ae79	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.ae7b	f0 9c		beq $ae19			beq 	CompCheckFlip
.ae7d	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.ae7f	80 98		bra $ae19			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: miscellany/alloc.asm

.ae81					Allocate:
.ae81	bd 00 0d	lda $0d00,x			lda 	stack1,x					; check 0-32767 allocated.
.ae84	29 80		and #$80			and 	#$80
.ae86	1d 00 0e	ora $0e00,x			ora 	stack2,x
.ae89	1d 00 0f	ora $0f00,x			ora 	stack3,x
.ae8c	d0 26		bne $aeb4			bne 	_ALBad
.ae8e	18		clc				clc 								; add to varmemory pointer saving
.ae8f	ad 88 10	lda $1088			lda 	VarMemory 					; address
.ae92	48		pha				pha
.ae93	7d 00 0c	adc $0c00,x			adc 	stack0,x
.ae96	8d 88 10	sta $1088			sta 	VarMemory
.ae99	ad 89 10	lda $1089			lda 	VarMemory+1
.ae9c	48		pha				pha
.ae9d	7d 00 0d	adc $0d00,x			adc 	stack1,x
.aea0	8d 89 10	sta $1089			sta 	VarMemory+1
.aea3	68		pla				pla 								; pop and save
.aea4	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aea7	68		pla				pla
.aea8	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aeab	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aeae	cd 8b 10	cmp $108b			cmp 	AllocMemory+1 				; check range
.aeb1	b0 01		bcs $aeb4			bcs 	_ALBad
.aeb3	60		rts				rts
.aeb4					_ALBad:
.aeb4	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>aeb7	42 41 44 20 41 4c 4c 4f				.text 	"BAD ALLOC",0
>aebf	43 00

;******  Return to file: main.asm


;******  Processing file: miscellany/list.asm

.aec1					Cmd_List:
.aec1	20 42 a5	jsr $a542			jsr 	ResetCodePointer 			; back to the beginning
.aec4	64 18		stz $18				stz 	zTemp2						; clear the lowest-number
.aec6	64 19		stz $19				stz 	zTemp2+1
.aec8	e0 00		cpx #$00			cpx 	#0 							; stack empty ?
.aeca	f0 0b		beq $aed7			beq 	_CLINone
.aecc	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; use tos as start line
.aecf	85 18		sta $18				sta 	zTemp2
.aed1	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aed4	85 19		sta $19				sta 	zTemp2+1
.aed6	ca		dex				dex 								; and pop the tos
.aed7					_CLINone:
.aed7	a9 1e		lda #$1e			lda 	#30 						; list this many lines
.aed9	85 16		sta $16				sta 	zTemp1
.aedb					_CLILoop
.aedb	b2 10		lda ($10)			lda 	(codePtr)					; check end of program
.aedd	f0 24		beq $af03			beq 	_CLIEnd
.aedf	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.aee1	38		sec				sec
.aee2	b1 10		lda ($10),y			lda 	(codePtr),y
.aee4	e5 18		sbc $18				sbc 	zTemp2
.aee6	c8		iny				iny
.aee7	b1 10		lda ($10),y			lda 	(codePtr),y
.aee9	e5 19		sbc $19				sbc 	zTemp2+1
.aeeb	90 09		bcc $aef6			bcc 	_CLISkip
.aeed	da		phx				phx
.aeee	20 06 af	jsr $af06			jsr 	ListCurrent 				; list the line.
.aef1	fa		plx				plx
.aef2	c6 16		dec $16				dec 	zTemp1 						; done all lines
.aef4	f0 0d		beq $af03			beq 	_CLIEnd
.aef6					_CLISkip:
.aef6	18		clc				clc
.aef7	b2 10		lda ($10)			lda 	(codePtr) 					; go to next
.aef9	65 10		adc $10				adc 	codePtr
.aefb	85 10		sta $10				sta 	codePtr
.aefd	90 dc		bcc $aedb			bcc 	_CLILoop
.aeff	e6 11		inc $11				inc 	codePtr+1
.af01	80 d8		bra $aedb			bra 	_CLILoop
.af03					_CLIEnd:
.af03	4c 3e a0	jmp $a03e			jmp 	WarmStart
.af06					ListCurrent:
.af06	a0 03		ldy #$03			ldy 	#3
.af08	b1 10		lda ($10),y			lda 	(codePtr),y
.af0a	c9 02		cmp #$02			cmp 	#2
.af0c	d0 0e		bne $af1c			bne 	_LCList
.af0e	a9 0d		lda #$0d			lda 	#13
.af10	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.af13	20 1c af	jsr $af1c			jsr 	_LCList
.af16	a9 0d		lda #$0d			lda 	#13
.af18	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.af1b	60		rts				rts
.af1c					_LCList:
.af1c	a9 05		lda #$05			lda 	#CTH_LINENO
.af1e	20 af a2	jsr $a2af			jsr 	ExternColour 				; set colour
.af21	a0 01		ldy #$01			ldy 	#1							; print line#
.af23	b1 10		lda ($10),y			lda 	(codePtr),y
.af25	48		pha				pha
.af26	c8		iny				iny
.af27	b1 10		lda ($10),y			lda 	(codePtr),y
.af29	a8		tay				tay
.af2a	68		pla				pla
.af2b	20 40 a6	jsr $a640			jsr 	ErrorPrint16
.af2e	a8		tay				tay
.af2f					_LCPadOut:
.af2f	a9 20		lda #$20			lda 	#' '
.af31	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.af34	c8		iny				iny
.af35	c0 05		cpy #$05			cpy 	#5
.af37	d0 f6		bne $af2f			bne 	_LCPadOut
.af39	a0 03		ldy #$03			ldy 	#3 							; start here
.af3b					_LCLoop:
.af3b	a9 20		lda #$20			lda 	#' '						; space
.af3d	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.af40					_LCLoopNoSpace:
.af40	b1 10		lda ($10),y			lda 	(codePtr),y 				; get first
.af42	30 44		bmi $af88			bmi 	_LCIdentConst 				; identifier or constant
.af44	d0 05		bne $af4b			bne 	_LCStringToken
.af46	a9 0d		lda #$0d			lda 	#13
.af48	4c a5 a2	jmp $a2a5			jmp 	ExternPrint
.af4b					_LCStringToken:
.af4b	c9 10		cmp #$10			cmp 	#$10 						; if < 10 it's a string.
.af4d	90 0c		bcc $af5b			bcc		_LCString
.af4f	20 c9 af	jsr $afc9			jsr 	ListPrintToken
.af52	b1 10		lda ($10),y			lda 	(codePtr),y 				; no space if ^
.af54	c8		iny				iny 								; advance pointer
.af55	c9 4d		cmp #$4d			cmp 	#KWD_HAT
.af57	f0 e7		beq $af40			beq 	_LCLoopNoSpace
.af59	80 e0		bra $af3b			bra 	_LCLoop 					; go round again.
.af5b					_LCString:
.af5b	4a		lsr a				lsr 	a 							; CS if 1 (string) CC if 2 (comment)
.af5c	a9 05		lda #$05			lda 	#CTH_STRING 				; decide on colour.
.af5e	a2 22		ldx #$22			ldx 	#'"'
.af60	b0 0a		bcs $af6c			bcs 	_LCSSkip
.af62	a9 0a		lda #$0a			lda 	#CTH_COMMENT
.af64	a2 27		ldx #$27			ldx 	#"'"
.af66	c0 03		cpy #$03			cpy 	#3
.af68	f0 02		beq $af6c			beq 	_LCSSkip
.af6a	a9 09		lda #$09			lda 	#CTH_LCOMMENT
.af6c					_LCSSkip:
.af6c	20 af a2	jsr $a2af			jsr 	ExternColour 				; set colour
.af6f	8a		txa				txa
.af70	48		pha				pha 								; save end quote on stack.
.af71	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.af74	c8		iny				iny 								; skip type size
.af75	c8		iny				iny
.af76					_LCSPrint:
.af76	b1 10		lda ($10),y			lda 	(codePtr),y
.af78	c8		iny				iny
.af79	c9 00		cmp #$00			cmp 	#0 							; 0 is end
.af7b	f0 05		beq $af82			beq 	_LCSExit
.af7d	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.af80	80 f4		bra $af76			bra 	_LCSPrint
.af82					_LCSExit:
.af82	68		pla				pla
.af83	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.af86	80 b3		bra $af3b			bra 	_LCLoop
.af88					_LCIdentConst:
.af88	c9 c0		cmp #$c0			cmp 	#$C0						; check if constant
.af8a	90 1e		bcc $afaa			bcc 	_LCConstant
.af8c	a9 03		lda #$03			lda 	#CTH_IDENT 					; set colour
.af8e	20 af a2	jsr $a2af			jsr 	ExternColour
.af91					_LCCIdLoop:
.af91	b1 10		lda ($10),y			lda 	(codePtr),y 				; read
.af93	29 1f		and #$1f			and 	#$1F 						; convert
.af95	18		clc				clc
.af96	69 41		adc #$41			adc 	#'A'
.af98	c9 60		cmp #$60			cmp 	#'A'+31 					; handle '.'
.af9a	d0 02		bne $af9e			bne 	_LCCNotDot
.af9c	a9 2e		lda #$2e			lda 	#'.'
.af9e					_LCCNotDot:
.af9e	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.afa1	b1 10		lda ($10),y			lda 	(codePtr),y 				; at end ?
.afa3	c8		iny				iny
.afa4	c9 e0		cmp #$e0			cmp 	#$E0
.afa6	b0 93		bcs $af3b			bcs 	_LCLoop
.afa8	80 e7		bra $af91			bra 	_LCCIdLoop
.afaa					_LCConstant:
.afaa	a9 06		lda #$06			lda 	#CTH_NUMBER 				; number colour
.afac	20 af a2	jsr $a2af			jsr 	ExternColour
.afaf	a2 fe		ldx #$fe			ldx 	#254 						; use the topmost stack element
.afb1	20 07 a4	jsr $a407			jsr 	ExtractIntegerToTOS 		; so there is a very rare case
.afb4	bd 00 0f	lda $0f00,x			lda 	stack3+0,x					; save stack top byte
.afb7	48		pha				pha
.afb8	20 65 a6	jsr $a665			jsr 	IntegerToString 			; this could corrupt stack if full :)
.afbb	20 53 a6	jsr $a653			jsr 	ErrorPrintIntegerBuffer
.afbe	68		pla				pla 								; sign back
.afbf	10 05		bpl $afc6			bpl 	_LCLoop2
.afc1	a9 2d		lda #$2d			lda 	#"-"
.afc3	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.afc6					_LCLoop2:
.afc6	4c 3b af	jmp $af3b			jmp 	_LCLoop
.afc9					ListPrintToken:
.afc9	5a		phy				phy
.afca	48		pha				pha 								; token colour
.afcb	a9 07		lda #$07			lda 	#CTH_TOKEN
.afcd	20 af a2	jsr $a2af			jsr 	ExternColour
.afd0	fa		plx				plx
.afd1	a9 0c		lda #$0c			lda 	#KeywordText & $FF
.afd3	85 14		sta $14				sta 	zTemp0
.afd5	a9 a1		lda #$a1			lda 	#KeywordText >> 8
.afd7	85 15		sta $15				sta 	zTemp0+1
.afd9					_LPTLoop:
.afd9	e0 10		cpx #$10			cpx 	#$10 						; first token is $10
.afdb	f0 0e		beq $afeb			beq 	_LPTFound
.afdd	ca		dex				dex
.afde	b2 14		lda ($14)			lda 	(zTemp0)
.afe0	38		sec				sec									; add 1, it's length+name
.afe1	65 14		adc $14				adc 	zTemp0
.afe3	85 14		sta $14				sta 	zTemp0
.afe5	90 f2		bcc $afd9			bcc 	_LPTLoop
.afe7	e6 15		inc $15				inc 	zTemp0+1
.afe9	80 ee		bra $afd9			bra 	_LPTLoop
.afeb					_LPTFound:
.afeb	a0 01		ldy #$01			ldy 	#1 							; start here.
.afed					_LPTShow:
.afed	b1 14		lda ($14),y			lda 	(zTemp0),y 					; get character
.afef	c9 20		cmp #$20			cmp 	#32 						; < 32, length, so exit
.aff1	90 06		bcc $aff9			bcc 	_LPTExit
.aff3	c8		iny				iny
.aff4	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.aff7	80 f4		bra $afed			bra 	_LPTShow
.aff9					_LPTExit:
.aff9	7a		ply				ply
.affa	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/renumber.asm

.affb					Cmd_Renumber:
.affb	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; zTemp1 line number being changed
.affd	85 16		sta $16				sta 	zTemp1
.afff	a9 11		lda #$11			lda 	#ProgramStart >> 8
.b001	85 17		sta $17				sta 	zTemp1+1
.b003	a9 e8		lda #$e8			lda 	#1000 & $FF 				; zTemp2 new number
.b005	85 18		sta $18				sta 	zTemp2
.b007	a9 03		lda #$03			lda 	#1000 >> 8
.b009	85 19		sta $19				sta 	zTemp2+1
.b00b					_CRLoop:
.b00b	b2 16		lda ($16)			lda 	(zTemp1) 					; check end of program
.b00d	f0 23		beq $b032			beq 	_CRExit
.b00f	a0 01		ldy #$01			ldy 	#1 							; copy new number in
.b011	a5 18		lda $18				lda 	zTemp2
.b013	91 16		sta ($16),y			sta 	(zTemp1),y
.b015	c8		iny				iny
.b016	a5 19		lda $19				lda 	zTemp2+1
.b018	91 16		sta ($16),y			sta 	(zTemp1),y
.b01a	18		clc				clc 								; add 10 to new number
.b01b	a5 18		lda $18				lda 	zTemp2
.b01d	69 0a		adc #$0a			adc 	#10
.b01f	85 18		sta $18				sta 	zTemp2
.b021	90 02		bcc $b025			bcc 	_CRNoCarry
.b023	e6 19		inc $19				inc 	zTemp2+1
.b025					_CRNoCarry:
.b025	18		clc				clc 								; go to next line
.b026	b2 16		lda ($16)			lda 	(zTemp1)
.b028	65 16		adc $16				adc 	zTemp1
.b02a	85 16		sta $16				sta 	zTemp1
.b02c	90 dd		bcc $b00b			bcc 	_CRLoop
.b02e	e6 17		inc $17				inc 	zTemp1+1
.b030	80 d9		bra $b00b			bra 	_CRLoop
.b032					_CRExit:
.b032	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/system.asm

.b033					System_RUN:
.b033	20 4d a5	jsr $a54d			jsr		ResetForRun 				; clear vars, stacks etc.
.b036	20 42 a5	jsr $a542			jsr 	ResetCodePointer 			; point to first thing to do.
.b039	4c 88 a3	jmp $a388			jmp 	Execute						; and run
.b03c					System_END:
.b03c	4c 3e a0	jmp $a03e			jmp 	WarmStart
.b03f					System_STOP:
.b03f	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b042	53 54 4f 50 00					.text 	"STOP",0
.b047					System_Assert:
.b047	ca		dex				dex
.b048	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.b04b	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.b04e	1d 02 0d	ora $0d02,x			ora 	stack1+2,x
.b051	1d 03 0d	ora $0d03,x			ora 	stack1+3,x
.b054	d0 0a		bne $b060			bne 	_SAOkay
.b056	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b059	41 53 53 45 52 54 00				.text 	"ASSERT",0
.b060	60		rts		_SAOkay:rts
.b061					System_New:
.b061	9c 00 11	stz $1100			stz 	ProgramStart 				; zero the first offset, erases.
.b064	20 4d a5	jsr $a54d			jsr		ResetForRun 				; clear vars, stacks etc.
.b067	4c 3e a0	jmp $a03e			jmp 	WarmStart
.b06a					System_Old:
.b06a	20 42 a5	jsr $a542			jsr 	ResetCodePointer 			; start of first line.
.b06d					_SOFindZero:
.b06d	b1 10		lda ($10),y			lda 	(codePtr),y 				; look for trailing $00
.b06f	f0 15		beq $b086			beq 	_SOFoundEnd
.b071	c8		iny				iny
.b072	d0 f9		bne $b06d			bne 	_SOFindZero
.b074	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b077	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER",0
>b07f	45 43 4f 56 45 52 00
.b086					_SOFoundEnd:
.b086	c8		iny				iny 								; update the offset
.b087	8c 00 11	sty $1100			sty 	ProgramStart
.b08a	20 4d a5	jsr $a54d			jsr 	ResetForRun 				; redo all stacks etc.
.b08d	60		rts				rts
.b08e					System_Sys:
.b08e	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy and drop call address
.b091	85 14		sta $14				sta 	zTemp0
.b093	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b096	85 15		sta $15				sta 	zTemp0+1
.b098	ca		dex				dex
.b099	da		phx				phx
.b09a	5a		phy				phy
.b09b	ad 00 10	lda $1000			lda 	AZVariables+('A'-'A')*4		; load AXY
.b09e	ae 5c 10	ldx $105c			ldx 	AZVariables+('X'-'A')*4
.b0a1	ac 60 10	ldy $1060			ldy 	AZVariables+('Y'-'A')*4
.b0a4	20 b3 b0	jsr $b0b3			jsr 	_SSCall 					; effectively jsr (zTemp)
.b0a7	8d 00 10	sta $1000			sta 	AZVariables+('A'-'A')*4 	; store AXY
.b0aa	8e 5c 10	stx $105c			stx 	AZVariables+('X'-'A')*4
.b0ad	8c 60 10	sty $1060			sty 	AZVariables+('Y'-'A')*4
.b0b0	7a		ply				ply
.b0b1	fa		plx				plx
.b0b2	60		rts				rts
.b0b3	6c 14 00	jmp ($0014)	_SSCall:jmp 	(zTemp0)
.b0b6					System_ShowStack:
.b0b6	da		phx				phx 								; save stack
.b0b7	5a		phy				phy
.b0b8	86 18		stx $18				stx 	zTemp2 						; save old TOS
.b0ba	a9 5b		lda #$5b			lda 	#"["
.b0bc	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.b0bf	e0 00		cpx #$00			cpx 	#0 							; empty
.b0c1	f0 14		beq $b0d7			beq 	_SSEnd
.b0c3	a2 01		ldx #$01			ldx 	#1 							; start here
.b0c5					_SSLoop:
.b0c5	20 65 a6	jsr $a665			jsr 	IntegerToString 			; print TOS
.b0c8	20 53 a6	jsr $a653			jsr 	ErrorPrintIntegerBuffer
.b0cb	e4 18		cpx $18				cpx 	zTemp2 						; done TOS exit
.b0cd	f0 08		beq $b0d7			beq 	_SSEnd
.b0cf	e8		inx				inx	 								; advance pointer print ,
.b0d0	a9 2c		lda #$2c			lda 	#','
.b0d2	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.b0d5	80 ee		bra $b0c5			bra 	_SSLoop
.b0d7					_SSEnd:
.b0d7	a9 5d		lda #$5d			lda 	#"]"						; finish off.
.b0d9	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.b0dc	a9 0d		lda #$0d			lda 	#13
.b0de	20 a5 a2	jsr $a2a5			jsr 	ExternPrint
.b0e1	7a		ply				ply
.b0e2	fa		plx				plx
.b0e3	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/saveload.asm

.b0e4					System_Save:
.b0e4	da		phx				phx
.b0e5	5a		phy				phy
.b0e6	20 73 a5	jsr $a573			jsr 	ResetVarMemory 				; make sure start/end are right
.b0e9	20 14 b1	jsr $b114			jsr 	SLGetFileName 				; get filename -> zTemp0
.b0ec	ad 88 10	lda $1088			lda 	VarMemory 					; end address
.b0ef	85 16		sta $16				sta 	zTemp1
.b0f1	ad 89 10	lda $1089			lda 	VarMemory+1
.b0f4	85 17		sta $17				sta 	zTemp1+1
.b0f6	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.b0f8	a0 11		ldy #$11			ldy 	#ProgramStart >> 8
.b0fa	20 01 a3	jsr $a301			jsr 	ExternSave
.b0fd	7a		ply				ply
.b0fe	fa		plx				plx
.b0ff	4c 3e a0	jmp $a03e			jmp 	WarmStart
.b102					System_Load:
.b102	5a		phy				phy
.b103	20 14 b1	jsr $b114			jsr 	SLGetFileName 				; get filename -> zTemp0
.b106	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; program start to YA
.b108	a0 11		ldy #$11			ldy 	#ProgramStart >> 8
.b10a	20 37 a3	jsr $a337			jsr 	ExternLoad
.b10d	20 4d a5	jsr $a54d			jsr 	ResetForRun 				; re-initialise everything
.b110	7a		ply				ply
.b111	4c 3e a0	jmp $a03e			jmp 	WarmStart
.b114					SLGetFileName:
.b114	e0 00		cpx #$00			cpx 	#0 							; gotta be something on the stack
.b116	f0 4d		beq $b165			beq 	_SLFNFail
.b118	bd 00 0e	lda $0e00,x			lda 	stack2,x 					; must be a tokenise buffer address
.b11b	1d 00 0f	ora $0f00,x			ora 	stack3,x
.b11e	d0 45		bne $b165			bne 	_SLFNFail
.b120	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b123	c9 0a		cmp #$0a			cmp 	#TokeniseBuffer >> 8
.b125	d0 3e		bne $b165			bne 	_SLFNFail
.b127	85 17		sta $17				sta 	zTemp1+1 					; copy the filename address to zTemp0/1
.b129	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b12c	85 16		sta $16				sta 	zTemp1
.b12e	a9 00		lda #$00			lda 	#InputBuffer & $FF 			; f/n in input buffer.
.b130	85 14		sta $14				sta 	zTemp0
.b132	a9 09		lda #$09			lda 	#InputBuffer >> 8
.b134	85 15		sta $15				sta 	zTemp0+1
.b136	da		phx				phx 								; save XY
.b137	5a		phy				phy
.b138	a0 ff		ldy #$ff			ldy 	#255 						; go to the end, copying into input buffer
.b13a					_SLCheckEnd:
.b13a	c8		iny				iny
.b13b	b1 16		lda ($16),y			lda 	(zTemp1),y
.b13d	99 00 09	sta $0900,y			sta 	InputBuffer,y
.b140	d0 f8		bne $b13a			bne 	_SLCheckEnd
.b142	84 18		sty $18				sty 	zTemp2 						; save end position
.b144	a2 03		ldx #$03			ldx 	#3 							; check to see if ends in .RPL
.b146					_SLCheckDotRPL:
.b146	88		dey				dey
.b147	bd 75 b1	lda $b175,x			lda 	_SLEXT,x
.b14a	d1 16		cmp ($16),y			cmp 	(zTemp1),y
.b14c	d0 05		bne $b153			bne 	_SLNotMatch
.b14e	ca		dex				dex
.b14f	10 f5		bpl $b146			bpl 	_SLCheckDotRPL
.b151	80 0f		bra $b162			bra 	_SLExit 					; yes it does
.b153					_SLNotMatch:
.b153	a2 00		ldx #$00			ldx 	#0
.b155	a4 18		ldy $18				ldy 	zTemp2
.b157					_SLAppend:
.b157	bd 75 b1	lda $b175,x			lda 	_SLEXT,x
.b15a	91 14		sta ($14),y			sta 	(zTemp0),y
.b15c	f0 04		beq $b162			beq 	_SLExit
.b15e	e8		inx				inx
.b15f	c8		iny				iny
.b160	80 f5		bra $b157			bra 	_SLAppend
.b162					_SLExit:
.b162	7a		ply				ply
.b163	fa		plx				plx
.b164	60		rts				rts
.b165					_SLFNFail:
.b165	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b168	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>b170	4e 41 4d 45 00
.b175					_SLEXT:
>b175	2e 52 50 4c 00					.text 	".RPL",0

;******  Return to file: main.asm


;******  Processing file: miscellany/variables.asm

.b17a					Identifier:
.b17a	88		dey				dey 								; wind back to identifier start
.b17b	20 59 a4	jsr $a459			jsr 	IdentifierSearch 			; try to find it.
.b17e	90 2f		bcc $b1af			bcc 	_IDUnknown 					; not known, give up.
.b180	48		pha				pha
.b181					_IDSkip:
.b181	b1 10		lda ($10),y			lda 	(codePtr),y
.b183	c8		iny				iny
.b184	c9 e0		cmp #$e0			cmp 	#$E0
.b186	90 f9		bcc $b181			bcc 	_IDSkip
.b188	68		pla				pla
.b189	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; check a variable
.b18b	d0 52		bne $b1df			bne 	_IDCall
.b18d	20 93 b2	jsr $b293			jsr 	IndexCheck 					; check index/subscript
.b190	5a		phy				phy
.b191	e8		inx				inx 								; make space on stack
.b192	a0 00		ldy #$00			ldy 	#0 							; copy it back
.b194	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b196	9d 00 0c	sta $0c00,x			sta 	stack0,x
.b199	c8		iny				iny
.b19a	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b19c	9d 00 0d	sta $0d00,x			sta 	stack1,x
.b19f	c8		iny				iny
.b1a0	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b1a2	9d 00 0e	sta $0e00,x			sta 	stack2,x
.b1a5	c8		iny				iny
.b1a6	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b1a8	9d 00 0f	sta $0f00,x			sta 	stack3,x
.b1ab	7a		ply				ply
.b1ac	4c 88 a3	jmp $a388			jmp 	Execute
.b1af					_IDUnknown:
.b1af	ad 26 08	lda $0826			lda 	ReturnDefZero				; unknown identifiers return 0
.b1b2	d0 14		bne $b1c8			bne 	_IDDefault
.b1b4	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b1b7	55 4e 4b 4e 4f 57 4e 20				.text 	"UNKNOWN VARIABLE",0
>b1bf	56 41 52 49 41 42 4c 45 00
.b1c8					_IDDefault:
.b1c8	b1 10		lda ($10),y			lda 	(codePtr),y
.b1ca	c8		iny				iny
.b1cb	c9 e0		cmp #$e0			cmp 	#$E0
.b1cd	90 f9		bcc $b1c8			bcc 	_IDDefault
.b1cf	e8		inx				inx
.b1d0	9e 00 0c	stz $0c00,x			stz 	stack0,x
.b1d3	9e 00 0d	stz $0d00,x			stz 	stack1,x
.b1d6	9e 00 0e	stz $0e00,x			stz 	stack2,x
.b1d9	9e 00 0f	stz $0f00,x			stz 	stack3,x
.b1dc	4c 88 a3	jmp $a388			jmp 	Execute
.b1df					_IDCall:
.b1df	c9 50		cmp #$50			cmp 	#IDT_PROCEDURE
.b1e1	d0 1b		bne $b1fe			bne 	_IDCode
.b1e3	20 45 b4	jsr $b445			jsr 	StructPushCurrent 			; push current on the stack.
.b1e6	a9 43		lda #$43			lda 	#STM_CALL 					; push marker
.b1e8	c6 12		dec $12				dec 	StructSP
.b1ea	92 12		sta ($12)			sta 	(StructSP)
.b1ec	a0 01		ldy #$01			ldy 	#1 							; line address
.b1ee	b2 22		lda ($22)			lda 	(idDataAddr)
.b1f0	85 10		sta $10				sta 	codePtr
.b1f2	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b1f4	85 11		sta $11				sta 	codePtr+1
.b1f6	a0 03		ldy #$03			ldy 	#3 							; line position
.b1f8	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b1fa	a8		tay				tay
.b1fb	4c 88 a3	jmp $a388			jmp 	Execute
.b1fe					_IDCode:
.b1fe	b2 22		lda ($22)			lda 	(idDataAddr) 				; copy the address
.b200	85 14		sta $14				sta 	zTemp0
.b202	5a		phy				phy
.b203	a0 01		ldy #$01			ldy 	#1
.b205	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b207	85 15		sta $15				sta 	zTemp0+1
.b209	7a		ply				ply
.b20a	20 10 b2	jsr $b210			jsr 	_IDCallZTemp0 				; call the routine
.b20d	4c 88 a3	jmp $a388			jmp 	Execute
.b210					_IDCallZTemp0:
.b210	6c 14 00	jmp ($0014)			jmp 	(zTemp0)
.b213					ProcReturn:
.b213					ProcReturn2:
.b213	b2 12		lda ($12)			lda 	(StructSP)					; check it's CALL
.b215	c9 43		cmp #$43			cmp 	#STM_CALL
.b217	a0 01		ldy #$01			ldy 	#1 							; restore the position
.b219	20 79 b4	jsr $b479			jsr 	StructPopCurrent
.b21c	a9 05		lda #$05			lda 	#5 							; pop 5 elements off structure stack.
.b21e	20 3f b4	jsr $b43f			jsr 	StructPopCount
.b221	60		rts				rts
.b222					WriteVariable:
.b222	b1 10		lda ($10),y			lda 	(codePtr),y 				; check variable
.b224	c9 c0		cmp #$c0			cmp 	#$C0
.b226	90 5d		bcc $b285			bcc 	_WVTypeError
.b228	20 59 a4	jsr $a459			jsr 	IdentifierSearch 			; does it exist
.b22b	90 06		bcc $b233			bcc 	_WVNoIdentifier
.b22d	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.b22f	f0 12		beq $b243			beq 	_WVWriteTOS 				; if so write TOS to it.
.b231	80 52		bra $b285			bra 	_WVTypeError 				; not, then can't do anything.
.b233					_WVNoIdentifier:
.b233	5a		phy				phy 								; get current line number
.b234	a0 01		ldy #$01			ldy 	#1
.b236	b1 10		lda ($10),y			lda 	(codePtr),y
.b238	c8		iny				iny
.b239	11 10		ora ($10),y			ora 	(codePtr),y
.b23b	f0 2e		beq $b26b			beq 	_WVCantCreate 				; if zero (command line) no new vars
.b23d	7a		ply				ply
.b23e	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; create identifier
.b240	20 c0 a4	jsr $a4c0			jsr 	IdentifierCreate 			; try to find it
.b243					_WVWriteTOS:
.b243	88		dey				dey 								; skip over identifier.
.b244					_WVSkipIdentifier:
.b244	b1 10		lda ($10),y			lda 	(codePtr),y
.b246	c8		iny				iny
.b247	c9 e0		cmp #$e0			cmp 	#$E0
.b249	90 f9		bcc $b244			bcc 	_WVSkipIdentifier
.b24b	20 93 b2	jsr $b293			jsr 	IndexCheck 					; check index/subscript
.b24e	5a		phy				phy									; copy TOS in
.b24f	a0 00		ldy #$00			ldy 	#0
.b251	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b254	91 22		sta ($22),y			sta 	(idDataAddr),y
.b256	c8		iny				iny
.b257	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b25a	91 22		sta ($22),y			sta 	(idDataAddr),y
.b25c	c8		iny				iny
.b25d	bd 00 0e	lda $0e00,x			lda 	stack2,x
.b260	91 22		sta ($22),y			sta 	(idDataAddr),y
.b262	c8		iny				iny
.b263	bd 00 0f	lda $0f00,x			lda 	stack3,x
.b266	91 22		sta ($22),y			sta 	(idDataAddr),y
.b268	7a		ply				ply
.b269	ca		dex				dex 								; drop
.b26a	60		rts				rts									; go back and execute again.
.b26b					_WVCantCreate:
.b26b	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b26e	43 41 4e 4e 4f 54 20 43				.text 	"CANNOT CREATE VARIABLE",0
>b276	52 45 41 54 45 20 56 41 52 49 41 42 4c 45 00
.b285					_WVTypeError:
.b285	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b288	57 52 4f 4e 47 20 54 59				.text 	"WRONG TYPE",0
>b290	50 45 00

;******  Return to file: main.asm


;******  Processing file: miscellany/indexing.asm

.b293					IndexCheck:
.b293	b1 10		lda ($10),y			lda 	(codePtr),y 				; check next character
.b295	c9 4b		cmp #$4b			cmp 	#KWD_LSQPAREN 				; is it [ ?
.b297	d0 10		bne $b2a9			bne 	_ICExit
.b299	c8		iny				iny
.b29a	b1 10		lda ($10),y			lda 	(codePtr),y 				; next is ] ?
.b29c	c9 4c		cmp #$4c			cmp 	#KWD_RSQPAREN
.b29e	f0 23		beq $b2c3			beq 	_ICArrayAccess
.b2a0	29 c0		and #$c0			and 	#$C0 						; is it a constant
.b2a2	c9 80		cmp #$80			cmp 	#$80
.b2a4	f0 04		beq $b2aa			beq 	_ICConstAccess
.b2a6					_ICSyntax:
.b2a6	4c db a5	jmp $a5db			jmp 	SyntaxError
.b2a9					_ICExit:
.b2a9	60		rts				rts
.b2aa					_ICConstAccess:
.b2aa	b1 10		lda ($10),y			lda 	(codePtr),y 				; get constant, copy in.
.b2ac	29 3f		and #$3f			and 	#$3F 						; to subscript in zTemp1
.b2ae	85 16		sta $16				sta 	zTemp1
.b2b0	64 17		stz $17				stz 	zTemp1+1
.b2b2	c8		iny				iny
.b2b3	b1 10		lda ($10),y			lda 	(codePtr),y 				; get next
.b2b5	c8		iny				iny
.b2b6	c9 4e		cmp #$4e			cmp 	#KWD_CONSTANT_PLUS 			; ok if K+
.b2b8	d0 ec		bne $b2a6			bne 	_ICSyntax
.b2ba	b1 10		lda ($10),y			lda 	(codePtr),y 				; get next
.b2bc	c8		iny				iny
.b2bd	c9 4c		cmp #$4c			cmp 	#KWD_RSQPAREN 				; ok if ]
.b2bf	d0 e5		bne $b2a6			bne 	_ICSyntax
.b2c1	80 0c		bra $b2cf			bra 	_ICAddSubscript
.b2c3					_ICArrayAccess:
.b2c3	c8		iny				iny 								; point to next
.b2c4	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy TOS to zTemp1
.b2c7	85 16		sta $16				sta 	zTemp1 						; no point in the rest !
.b2c9	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b2cc	85 17		sta $17				sta 	zTemp1+1
.b2ce	ca		dex				dex
.b2cf					_ICAddSubscript:
.b2cf	06 16		asl $16				asl 	zTemp1 						; subscript x 4
.b2d1	26 17		rol $17				rol 	zTemp1+1
.b2d3	06 16		asl $16				asl 	zTemp1
.b2d5	26 17		rol $17				rol 	zTemp1+1
.b2d7	5a		phy				phy
.b2d8	b2 22		lda ($22)			lda 	(idDataAddr)				; check indirecting through 0
.b2da	a0 01		ldy #$01			ldy 	#1
.b2dc	11 22		ora ($22),y			ora 	(idDataAddr),y 				; probably means uninitialised
.b2de	c8		iny				iny
.b2df	11 22		ora ($22),y			ora 	(idDataAddr),y
.b2e1	c8		iny				iny
.b2e2	11 22		ora ($22),y			ora 	(idDataAddr),y
.b2e4	f0 17		beq $b2fd			beq 	_ICZero
.b2e6	18		clc				clc									; add zTemp1 to value at (idDataAddr)
.b2e7	b2 22		lda ($22)			lda 	(idDataAddr)
.b2e9	65 16		adc $16				adc 	zTemp1
.b2eb	48		pha				pha
.b2ec	a0 01		ldy #$01			ldy 	#1
.b2ee	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b2f0	65 17		adc $17				adc 	zTemp1+1
.b2f2	85 23		sta $23				sta 	idDataAddr+1 				; write it out
.b2f4	68		pla				pla
.b2f5	85 22		sta $22				sta 	idDataAddr
.b2f7	64 24		stz $24				stz 	idDataAddr+2 				; extend to 32 bits
.b2f9	64 25		stz $25				stz 	idDataAddr+3
.b2fb	7a		ply				ply
.b2fc	60		rts				rts
.b2fd					_ICZero:
.b2fd	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b300	55 4e 49 4e 49 54 49 41				.text 	"UNINITIALISED ARRAY",0
>b308	4c 49 53 45 44 20 41 52 52 41 59 00

;******  Return to file: main.asm


;******  Processing file: structures/if.asm

.b314					Struct_IF:
.b314	ca		dex				dex 								; drop TOS
.b315	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check TOS
.b318	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.b31b	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.b31e	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.b321	f0 01		beq $b324			beq 	_SIFSkipForward
.b323	60		rts				rts
.b324					_SIFSkipForward:
.b324	a9 2c		lda #$2c			lda 	#KWD_ELSE
.b326	4c 2f b3	jmp $b32f			jmp 	StructSkipForward
.b329					Struct_ELSE:
.b329	a9 2e		lda #$2e			lda 	#KWD_ENDIF
.b32b	4c 2f b3	jmp $b32f			jmp 	StructSkipForward
.b32e					Struct_ENDIF:
.b32e	60		rts				rts
.b32f					StructSkipForward:
.b32f	85 14		sta $14				sta 	zTemp0 						; 2nd match
.b331					_SSFLoop:
.b331	b1 10		lda ($10),y			lda 	(codePtr),y 				; read it
.b333	f0 14		beq $b349			beq 	_SSFExit 					; if EOL then exit
.b335	c8		iny				iny 								; advance past it
.b336	c9 2e		cmp #$2e			cmp 	#KWD_ENDIF 					; exit if ENDIF or 2nd match
.b338	f0 0f		beq $b349			beq 	_SSFExit
.b33a	c5 14		cmp $14				cmp 	zTemp0
.b33c	f0 0b		beq $b349			beq 	_SSFExit
.b33e	c9 03		cmp #$03			cmp 	#3 							; if not 1,2 go round again
.b340	b0 ef		bcs $b331			bcs 	_SSFLoop
.b342	98		tya				tya 								; add length offset
.b343	3a		dec a				dec 	a
.b344	71 10		adc ($10),y			adc 	(codePtr),y
.b346	a8		tay				tay
.b347	80 e8		bra $b331			bra 	_SSFLoop
.b349					_SSFExit:
.b349	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: structures/fornext.asm

.b34a					Command_For:
.b34a	20 45 b4	jsr $b445			jsr 	StructPushCurrent 			; push current on the stack.
.b34d	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check zero
.b350	1d 00 0d	ora $0d00,x			ora 	stack1,x
.b353	1d 00 0e	ora $0e00,x			ora 	stack2,x
.b356	1d 00 0f	ora $0f00,x			ora 	stack3,x
.b359	f0 2c		beq $b387			beq 	_CFZero
.b35b	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; push 1's complement of index on
.b35e	49 ff		eor #$ff			eor 	#$FF 						; structure stack.
.b360	c6 12		dec $12				dec 	StructSP
.b362	92 12		sta ($12)			sta 	(StructSP)
.b364	bd 00 0e	lda $0e00,x			lda 	stack2,x
.b367	49 ff		eor #$ff			eor 	#$FF
.b369	c6 12		dec $12				dec 	StructSP
.b36b	92 12		sta ($12)			sta 	(StructSP)
.b36d	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b370	49 ff		eor #$ff			eor 	#$FF
.b372	c6 12		dec $12				dec 	StructSP
.b374	92 12		sta ($12)			sta 	(StructSP)
.b376	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b379	49 ff		eor #$ff			eor 	#$FF
.b37b	c6 12		dec $12				dec 	StructSP
.b37d	92 12		sta ($12)			sta 	(StructSP)
.b37f	ca		dex				dex 								; pop stack value
.b380	a9 46		lda #$46			lda 	#STM_FOR 					; push FOR marker
.b382	c6 12		dec $12				dec 	StructSP
.b384	92 12		sta ($12)			sta 	(StructSP)
.b386	60		rts				rts
.b387					_CFZero:
.b387	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b38a	46 4f 52 20 43 4f 55 4e				.text 	"FOR COUNT ZERO",0
>b392	54 20 5a 45 52 4f 00
.b399					Command_Next:
.b399	b2 12		lda ($12)			lda 	(StructSP)					; check it's FOR.
.b39b	c9 46		cmp #$46			cmp 	#STM_FOR
.b39d	d0 28		bne $b3c7			bne 	CNNoFor
.b39f	5a		phy				phy
.b3a0	a0 00		ldy #$00			ldy 	#0
.b3a2					_CNIncrement:
.b3a2	c8		iny				iny
.b3a3	b1 12		lda ($12),y			lda 	(StructSP),y 				; increment the index
.b3a5	1a		inc a				inc 	a
.b3a6	91 12		sta ($12),y			sta 	(StructSP),y
.b3a8	f0 f8		beq $b3a2			beq		_CNIncrement 				; carry out.
.b3aa	a0 01		ldy #$01			ldy 	#1 							; now and all the counts together
.b3ac	b1 12		lda ($12),y			lda 	(StructSP),y 				; on the last time round they
.b3ae	c8		iny				iny 								; will all be $FF
.b3af	31 12		and ($12),y			and 	(StructSP),y
.b3b1	c8		iny				iny
.b3b2	31 12		and ($12),y			and 	(StructSP),y
.b3b4	c8		iny				iny
.b3b5	31 12		and ($12),y			and 	(StructSP),y
.b3b7	7a		ply				ply 								; restore Y
.b3b8	1a		inc a				inc 	a 							; so this will be zero last time round
.b3b9	d0 06		bne $b3c1			bne 	_CNLoop 					; loop back if non-zero
.b3bb	a9 09		lda #$09			lda 	#9 							; pop 9 elements off structure stack.
.b3bd	20 3f b4	jsr $b43f			jsr 	StructPopCount
.b3c0	60		rts				rts
.b3c1					_CNLoop:
.b3c1	a0 05		ldy #$05			ldy 	#5 							; restore the position
.b3c3	20 79 b4	jsr $b479			jsr 	StructPopCurrent
.b3c6	60		rts				rts
.b3c7					CNNoFor:
.b3c7	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b3ca	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>b3d2	46 4f 52 00
.b3d6					Command_Index:
.b3d6	b2 12		lda ($12)			lda 	(StructSP)					; check it's FOR.
.b3d8	c9 46		cmp #$46			cmp 	#STM_FOR
.b3da	d0 eb		bne $b3c7			bne 	CNNoFor
.b3dc	5a		phy				phy
.b3dd	a0 01		ldy #$01			ldy 	#1 							; get the stack position of
.b3df	e8		inx				inx
.b3e0	38		sec				sec
.b3e1	a9 fe		lda #$fe			lda 	#$FE
.b3e3	f1 12		sbc ($12),y			sbc 	(StructSP),y
.b3e5	9d 00 0c	sta $0c00,x			sta 	stack0,x
.b3e8	c8		iny				iny
.b3e9	a9 ff		lda #$ff			lda 	#$FF
.b3eb	f1 12		sbc ($12),y			sbc 	(StructSP),y
.b3ed	9d 00 0d	sta $0d00,x			sta 	stack1,x
.b3f0	c8		iny				iny
.b3f1	a9 ff		lda #$ff			lda 	#$FF
.b3f3	f1 12		sbc ($12),y			sbc 	(StructSP),y
.b3f5	9d 00 0e	sta $0e00,x			sta 	stack2,x
.b3f8	c8		iny				iny
.b3f9	a9 ff		lda #$ff			lda 	#$FF
.b3fb	f1 12		sbc ($12),y			sbc 	(StructSP),y
.b3fd	9d 00 0f	sta $0f00,x			sta 	stack3,x
.b400	7a		ply				ply
.b401	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: structures/repeat.asm

.b402					Command_Repeat:
.b402	20 45 b4	jsr $b445			jsr 	StructPushCurrent 			; push current on the stack.
.b405	a9 52		lda #$52			lda 	#STM_REPEAT 				; push marker
.b407	c6 12		dec $12				dec 	StructSP
.b409	92 12		sta ($12)			sta 	(StructSP)
.b40b	60		rts				rts
.b40c					Command_Until:
.b40c	b2 12		lda ($12)			lda 	(StructSP)					; check it's REPEAT
.b40e	c9 52		cmp #$52			cmp 	#STM_REPEAT
.b410	d0 1b		bne $b42d			bne 	_CUNoRepeat
.b412	ca		dex				dex 								; pop
.b413	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check old TOS zero
.b416	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.b419	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.b41c	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.b41f	f0 06		beq $b427			beq 	_CULoop
.b421	a9 05		lda #$05			lda 	#5 							; pop 5 elements off structure stack.
.b423	20 3f b4	jsr $b43f			jsr 	StructPopCount
.b426	60		rts				rts
.b427					_CULoop:
.b427	a0 01		ldy #$01			ldy 	#1 							; restore the position
.b429	20 79 b4	jsr $b479			jsr 	StructPopCurrent
.b42c	60		rts				rts
.b42d					_CUNoRepeat:
.b42d	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b430	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>b438	52 45 50 45 41 54 00

;******  Return to file: main.asm


;******  Processing file: structures/structures.asm

.b43f					StructPopCount:
.b43f	18		clc				clc
.b440	65 12		adc $12				adc 	StructSP
.b442	85 12		sta $12				sta 	StructSP
.b444	60		rts				rts
.b445					StructPushCurrent:
.b445	a5 12		lda $12				lda 	StructSP 					; check space for more
.b447	c9 0a		cmp #$0a			cmp 	#10
.b449	90 18		bcc $b463			bcc 	_SPCSpace
.b44b	a9 00		lda #$00			lda 	#0							; push bank
.b44d	c6 12		dec $12				dec 	StructSP
.b44f	92 12		sta ($12)			sta 	(StructSP)
.b451	98		tya				tya									; y Offset
.b452	c6 12		dec $12				dec 	StructSP
.b454	92 12		sta ($12)			sta 	(StructSP)
.b456	a5 11		lda $11				lda 	codePtr+1 					; codeptr high
.b458	c6 12		dec $12				dec 	StructSP
.b45a	92 12		sta ($12)			sta 	(StructSP)
.b45c	a5 10		lda $10				lda 	codePtr 					; codeptr low
.b45e	c6 12		dec $12				dec 	StructSP
.b460	92 12		sta ($12)			sta 	(StructSP)
.b462	60		rts				rts
.b463					_SPCSpace:
.b463	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b466	52 45 54 55 52 4e 20 53				.text 	"RETURN STACK SPACE",0
>b46e	54 41 43 4b 20 53 50 41 43 45 00
.b479					StructPopCurrent:
.b479	b1 12		lda ($12),y			lda 	(StructSP),y 				; codeptr low
.b47b	85 10		sta $10				sta 	codePtr
.b47d	c8		iny				iny
.b47e	b1 12		lda ($12),y			lda 	(StructSP),y 				; codeptr high
.b480	85 11		sta $11				sta 	codePtr+1
.b482	c8		iny				iny
.b483	b1 12		lda ($12),y			lda 	(StructSP),y				; y offset
.b485	a8		tay				tay
.b486	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/hashes.inc

.b487					libfunc_1000:
>b487	00 00					.word 0
>b489	00 01 ff ff				.dword $FFFF0100
>b48d	91 b4					.word libfunc_1000_name
>b48f	00 41					.byte 0,'A'
.b491					libfunc_1000_name:
>b491	ce d1 e0				.byte $ce,$d1,$e0
.b494					libfunc_1001:
>b494	87 b4					.word libfunc_1000
>b496	80 01 ff ff				.dword $FFFF0180
>b49a	9e b4					.word libfunc_1001_name
>b49c	00 41					.byte 0,'A'
.b49e					libfunc_1001_name:
>b49e	d2 d3 e0				.byte $d2,$d3,$e0
.b4a1					libfunc_1002:
>b4a1	94 b4					.word libfunc_1001
>b4a3	a0 01 ff ff				.dword $FFFF01A0
>b4a7	ab b4					.word libfunc_1002_name
>b4a9	00 41					.byte 0,'A'
.b4ab					libfunc_1002_name:
>b4ab	cb c3 e0				.byte $cb,$c3,$e0
.b4ae					libfunc_1003:
>b4ae	a1 b4					.word libfunc_1002
>b4b0	f0 04 ff ff				.dword $FFFF04F0
>b4b4	b8 b4					.word libfunc_1003_name
>b4b6	00 41					.byte 0,'A'
.b4b8					libfunc_1003_name:
>b4b8	c1 c4 f0				.byte $c1,$c4,$f0
.b4bb					libfunc_1004:
>b4bb	ae b4					.word libfunc_1003
>b4bd	48 06 ff ff				.dword $FFFF0648
>b4c1	c5 b4					.word libfunc_1004_name
>b4c3	00 41					.byte 0,'A'
.b4c5					libfunc_1004_name:
>b4c5	cf c7 e0				.byte $cf,$c7,$e0
.b4c8					libfunc_1005:
>b4c8	bb b4					.word libfunc_1004
>b4ca	68 06 ff ff				.dword $FFFF0668
>b4ce	d2 b4					.word libfunc_1005_name
>b4d0	00 41					.byte 0,'A'
.b4d2					libfunc_1005_name:
>b4d2	cf cb e0				.byte $cf,$cb,$e0
.b4d5					libfunc_1006:
>b4d5	c8 b4					.word libfunc_1005
>b4d7	98 06 ff ff				.dword $FFFF0698
>b4db	df b4					.word libfunc_1006_name
>b4dd	00 41					.byte 0,'A'
.b4df					libfunc_1006_name:
>b4df	d3 d8 e0				.byte $d3,$d8,$e0
.b4e2					libfunc_1007:
>b4e2	d5 b4					.word libfunc_1006
>b4e4	8a 06 ff ff				.dword $FFFF068A
>b4e8	ec b4					.word libfunc_1007_name
>b4ea	00 41					.byte 0,'A'
.b4ec					libfunc_1007_name:
>b4ec	d3 d7 e0				.byte $d3,$d7,$e0
.b4ef					libfunc_1008:
>b4ef	e2 b4					.word libfunc_1007
>b4f1	80 04 ff ff				.dword $FFFF0480
>b4f5	f9 b4					.word libfunc_1008_name
>b4f7	00 41					.byte 0,'A'
.b4f9					libfunc_1008_name:
>b4f9	c1 d1 e0				.byte $c1,$d1,$e0
.b4fc					libfunc_1009:
>b4fc	00 00					.word 0
>b4fe	40 01 ff ff				.dword $FFFF0140
>b502	06 b5					.word libfunc_1009_name
>b504	00 41					.byte 0,'A'
.b506					libfunc_1009_name:
>b506	c4 ce f1				.byte $c4,$ce,$f1
.b509					libfunc_1010:
>b509	fc b4					.word libfunc_1009
>b50b	40 02 ff ff				.dword $FFFF0240
>b50f	13 b5					.word libfunc_1010_name
>b511	00 41					.byte 0,'A'
.b513					libfunc_1010_name:
>b513	cb d2 f1				.byte $cb,$d2,$f1
.b516					libfunc_1011:
>b516	09 b5					.word libfunc_1010
>b518	60 02 ff ff				.dword $FFFF0260
>b51c	20 b5					.word libfunc_1011_name
>b51e	00 41					.byte 0,'A'
.b520					libfunc_1011_name:
>b520	d1 ce f1				.byte $d1,$ce,$f1
.b523					libfunc_1012:
>b523	16 b5					.word libfunc_1011
>b525	20 05 ff ff				.dword $FFFF0520
>b529	2d b5					.word libfunc_1012_name
>b52b	00 41					.byte 0,'A'
.b52d					libfunc_1012_name:
>b52d	c9 d2 f1				.byte $c9,$d2,$f1
.b530					libfunc_1013:
>b530	00 00					.word 0
>b532	52 b9 00 00				.dword IO_Clear
>b536	3a b5					.word libfunc_1013_name
>b538	00 43					.byte 0,'C'
.b53a					libfunc_1013_name:
>b53a	c2 cb f2				.byte $c2,$cb,$f2
.b53d					libfunc_1014:
>b53d	30 b5					.word libfunc_1013
>b53f	ec b9 00 00				.dword Vera_Sprite
>b543	47 b5					.word libfunc_1014_name
>b545	00 43					.byte 0,'C'
.b547					libfunc_1014_name:
>b547	d5 c4 d1 c0 df f2			.byte $d5,$c4,$d1,$c0,$df,$f2
.b54d					libfunc_1015:
>b54d	3d b5					.word libfunc_1014
>b54f	60 01 ff ff				.dword $FFFF0160
>b553	57 b5					.word libfunc_1015_name
>b555	00 41					.byte 0,'A'
.b557					libfunc_1015_name:
>b557	c0 c3 e2				.byte $c0,$c3,$e2
.b55a					libfunc_1016:
>b55a	4d b5					.word libfunc_1015
>b55c	e0 01 ff ff				.dword $FFFF01E0
>b560	64 b5					.word libfunc_1016_name
>b562	00 41					.byte 0,'A'
.b564					libfunc_1016_name:
>b564	d2 c1 e2				.byte $d2,$c1,$e2
.b567					libfunc_1017:
>b567	5a b5					.word libfunc_1016
>b569	3a 06 ff ff				.dword $FFFF063A
>b56d	71 b5					.word libfunc_1017_name
>b56f	00 41					.byte 0,'A'
.b571					libfunc_1017_name:
>b571	c3 c4 e2				.byte $c3,$c4,$e2
.b574					libfunc_1018:
>b574	67 b5					.word libfunc_1017
>b576	1a 06 ff ff				.dword $FFFF061A
>b57a	7e b5					.word libfunc_1018_name
>b57c	00 41					.byte 0,'A'
.b57e					libfunc_1018_name:
>b57e	c8 cd e2				.byte $c8,$cd,$e2
.b581					libfunc_1019:
>b581	74 b5					.word libfunc_1018
>b583	50 04 ff ff				.dword $FFFF0450
>b587	8b b5					.word libfunc_1019_name
>b589	00 41					.byte 0,'A'
.b58b					libfunc_1019_name:
>b58b	c1 d5 e2				.byte $c1,$d5,$e2
.b58e					libfunc_1020:
>b58e	81 b5					.word libfunc_1019
>b590	70 04 ff ff				.dword $FFFF0470
>b594	98 b5					.word libfunc_1020_name
>b596	00 41					.byte 0,'A'
.b598					libfunc_1020_name:
>b598	c1 d5 f2				.byte $c1,$d5,$f2
.b59b					libfunc_1021:
>b59b	8e b5					.word libfunc_1020
>b59d	90 04 ff ff				.dword $FFFF0490
>b5a1	a5 b5					.word libfunc_1021_name
>b5a3	00 41					.byte 0,'A'
.b5a5					libfunc_1021_name:
>b5a5	c1 c2 e2				.byte $c1,$c2,$e2
.b5a8					libfunc_1022:
>b5a8	9b b5					.word libfunc_1021
>b5aa	b0 04 ff ff				.dword $FFFF04B0
>b5ae	b2 b5					.word libfunc_1022_name
>b5b0	00 41					.byte 0,'A'
.b5b2					libfunc_1022_name:
>b5b2	c1 c2 f2				.byte $c1,$c2,$f2
.b5b5					libfunc_1023:
>b5b5	a8 b5					.word libfunc_1022
>b5b7	60 06 ff ff				.dword $FFFF0660
>b5bb	bf b5					.word libfunc_1023_name
>b5bd	00 41					.byte 0,'A'
.b5bf					libfunc_1023_name:
>b5bf	d1 d3 f2				.byte $d1,$d3,$f2
.b5c2					libfunc_1024:
>b5c2	b5 b5					.word libfunc_1023
>b5c4	18 06 ff ff				.dword $FFFF0618
>b5c8	cc b5					.word libfunc_1024_name
>b5ca	00 41					.byte 0,'A'
.b5cc					libfunc_1024_name:
>b5cc	c2 cb e2				.byte $c2,$cb,$e2
.b5cf					libfunc_1025:
>b5cf	c2 b5					.word libfunc_1024
>b5d1	38 06 ff ff				.dword $FFFF0638
>b5d5	d9 b5					.word libfunc_1025_name
>b5d7	00 41					.byte 0,'A'
.b5d9					libfunc_1025_name:
>b5d9	d2 c4 e2				.byte $d2,$c4,$e2
.b5dc					libfunc_1026:
>b5dc	cf b5					.word libfunc_1025
>b5de	9a 06 ff ff				.dword $FFFF069A
>b5e2	e6 b5					.word libfunc_1026_name
>b5e4	00 41					.byte 0,'A'
.b5e6					libfunc_1026_name:
>b5e6	d3 d7 f2				.byte $d3,$d7,$f2
.b5e9					libfunc_1027:
>b5e9	00 00					.word 0
>b5eb	e5 b8 00 00				.dword System_Random
>b5ef	f3 b5					.word libfunc_1027_name
>b5f1	00 43					.byte 0,'C'
.b5f3					libfunc_1027_name:
>b5f3	d1 cd e3				.byte $d1,$cd,$e3
.b5f6					libfunc_1028:
>b5f6	e9 b5					.word libfunc_1027
>b5f8	57 b9 00 00				.dword IO_Emit
>b5fc	00 b6					.word libfunc_1028_name
>b5fe	00 43					.byte 0,'C'
.b600					libfunc_1028_name:
>b600	c4 cc c8 f3				.byte $c4,$cc,$c8,$f3
.b604					libfunc_1029:
>b604	f6 b5					.word libfunc_1028
>b606	91 b9 00 00				.dword Vera_SetAddress
>b60a	0e b6					.word libfunc_1029_name
>b60c	00 43					.byte 0,'C'
.b60e					libfunc_1029_name:
>b60e	d5 c4 d1 c0 df d2 c4 f3			.byte $d5,$c4,$d1,$c0,$df,$d2,$c4,$f3
.b616					libfunc_1030:
>b616	04 b6					.word libfunc_1029
>b618	ab b9 00 00				.dword Vera_GetAddress
>b61c	20 b6					.word libfunc_1030_name
>b61e	00 43					.byte 0,'C'
.b620					libfunc_1030_name:
>b620	d5 c4 d1 c0 df c6 c4 f3			.byte $d5,$c4,$d1,$c0,$df,$c6,$c4,$f3
.b628					libfunc_1031:
>b628	16 b6					.word libfunc_1030
>b62a	a6 ba 00 00				.dword Vera_Load
>b62e	32 b6					.word libfunc_1031_name
>b630	00 43					.byte 0,'C'
.b632					libfunc_1031_name:
>b632	d5 c4 d1 c0 df cb ce c0			.byte $d5,$c4,$d1,$c0,$df,$cb,$ce,$c0,$e3
>b63a	e3
.b63b					libfunc_1032:
>b63b	28 b6					.word libfunc_1031
>b63d	20 01 ff ff				.dword $FFFF0120
>b641	45 b6					.word libfunc_1032_name
>b643	00 41					.byte 0,'A'
.b645					libfunc_1032_name:
>b645	c0 cd e3				.byte $c0,$cd,$e3
.b648					libfunc_1033:
>b648	3b b6					.word libfunc_1032
>b64a	20 03 ff ff				.dword $FFFF0320
>b64e	52 b6					.word libfunc_1033_name
>b650	00 41					.byte 0,'A'
.b652					libfunc_1033_name:
>b652	c1 c8 f3				.byte $c1,$c8,$f3
.b655					libfunc_1034:
>b655	48 b6					.word libfunc_1033
>b657	d8 06 ff ff				.dword $FFFF06D8
>b65b	5f b6					.word libfunc_1034_name
>b65d	00 41					.byte 0,'A'
.b65f					libfunc_1034_name:
>b65f	c2 cb e3				.byte $c2,$cb,$e3
.b662					libfunc_1035:
>b662	55 b6					.word libfunc_1034
>b664	f8 06 ff ff				.dword $FFFF06F8
>b668	6c b6					.word libfunc_1035_name
>b66a	00 41					.byte 0,'A'
.b66c					libfunc_1035_name:
>b66c	d2 c4 e3				.byte $d2,$c4,$e3
.b66f					libfunc_1036:
>b66f	00 00					.word 0
>b671	c2 b9 00 00				.dword Vera_SetPalette
>b675	79 b6					.word libfunc_1036_name
>b677	00 43					.byte 0,'C'
.b679					libfunc_1036_name:
>b679	d5 c4 d1 c0 df cf c0 cb			.byte $d5,$c4,$d1,$c0,$df,$cf,$c0,$cb,$c4,$d3,$d3,$e4
>b681	c4 d3 d3 e4
.b685					libfunc_1037:
>b685	6f b6					.word libfunc_1036
>b687	16 ba 00 00				.dword Vera_SpriteMove
>b68b	8f b6					.word libfunc_1037_name
>b68d	00 43					.byte 0,'C'
.b68f					libfunc_1037_name:
>b68f	d5 c4 d1 c0 df d2 df cc			.byte $d5,$c4,$d1,$c0,$df,$d2,$df,$cc,$ce,$d5,$e4
>b697	ce d5 e4
.b69a					libfunc_1038:
>b69a	85 b6					.word libfunc_1037
>b69c	5e ba 00 00				.dword Vera_SetSize
>b6a0	a4 b6					.word libfunc_1038_name
>b6a2	00 43					.byte 0,'C'
.b6a4					libfunc_1038_name:
>b6a4	d5 c4 d1 c0 df d2 df d2			.byte $d5,$c4,$d1,$c0,$df,$d2,$df,$d2,$c8,$d9,$e4
>b6ac	c8 d9 e4
.b6af					libfunc_1039:
>b6af	9a b6					.word libfunc_1038
>b6b1	d0 04 ff ff				.dword $FFFF04D0
>b6b5	b9 b6					.word libfunc_1039_name
>b6b7	00 41					.byte 0,'A'
.b6b9					libfunc_1039_name:
>b6b9	c1 cd e4				.byte $c1,$cd,$e4
.b6bc					libfunc_1040:
>b6bc	00 00					.word 0
>b6be	fa b9 00 00				.dword Vera_SpriteDisable
>b6c2	c6 b6					.word libfunc_1040_name
>b6c4	00 43					.byte 0,'C'
.b6c6					libfunc_1040_name:
>b6c6	d5 c4 d1 c0 df d2 df ce			.byte $d5,$c4,$d1,$c0,$df,$d2,$df,$ce,$c5,$e5
>b6ce	c5 e5
.b6d0					libfunc_1041:
>b6d0	bc b6					.word libfunc_1040
>b6d2	b8 06 ff ff				.dword $FFFF06B8
>b6d6	da b6					.word libfunc_1041_name
>b6d8	00 41					.byte 0,'A'
.b6da					libfunc_1041_name:
>b6da	c2 cb f5				.byte $c2,$cb,$f5
.b6dd					libfunc_1042:
>b6dd	00 00					.word 0
>b6df	7c ba 00 00				.dword Vera_ByteW
>b6e3	e7 b6					.word libfunc_1042_name
>b6e5	00 43					.byte 0,'C'
.b6e7					libfunc_1042_name:
>b6e7	d5 c4 d1 c0 df f6			.byte $d5,$c4,$d1,$c0,$df,$f6
.b6ed					libfunc_1043:
>b6ed	00 00					.word 0
>b6ef	2e ba 00 00				.dword Vera_SpriteSetup
>b6f3	f7 b6					.word libfunc_1043_name
>b6f5	00 43					.byte 0,'C'
.b6f7					libfunc_1043_name:
>b6f7	d5 c4 d1 c0 df d2 df c6			.byte $d5,$c4,$d1,$c0,$df,$d2,$df,$c6,$c5,$f7
>b6ff	c5 f7
.b701					libfunc_1044:
>b701	ed b6					.word libfunc_1043
>b703	80 02 ff ff				.dword $FFFF0280
>b707	0b b7					.word libfunc_1044_name
>b709	00 41					.byte 0,'A'
.b70b					libfunc_1044_name:
>b70b	d2 d3 f7				.byte $d2,$d3,$f7
.b70e					libfunc_1045:
>b70e	01 b7					.word libfunc_1044
>b710	a0 02 ff ff				.dword $FFFF02A0
>b714	18 b7					.word libfunc_1045_name
>b716	00 41					.byte 0,'A'
.b718					libfunc_1045_name:
>b718	cb c3 f7				.byte $cb,$c3,$f7
.b71b					libfunc_1046:
>b71b	0e b7					.word libfunc_1045
>b71d	e0 03 ff ff				.dword $FFFF03E0
>b721	25 b7					.word libfunc_1046_name
>b723	00 41					.byte 0,'A'
.b725					libfunc_1046_name:
>b725	c2 cf f7				.byte $c2,$cf,$f7
.b728					libfunc_1047:
>b728	1b b7					.word libfunc_1046
>b72a	e8 06 ff ff				.dword $FFFF06E8
>b72e	32 b7					.word libfunc_1047_name
>b730	00 41					.byte 0,'A'
.b732					libfunc_1047_name:
>b732	c8 cd f7				.byte $c8,$cd,$f7
.b735					libfunc_1048:
>b735	28 b7					.word libfunc_1047
>b737	aa 06 ff ff				.dword $FFFF06AA
>b73b	3f b7					.word libfunc_1048_name
>b73d	00 41					.byte 0,'A'
.b73f					libfunc_1048_name:
>b73f	d3 c0 f7				.byte $d3,$c0,$f7
.b742					libfunc_1049:
>b742	35 b7					.word libfunc_1048
>b744	ba 06 ff ff				.dword $FFFF06BA
>b748	4c b7					.word libfunc_1049_name
>b74a	00 41					.byte 0,'A'
.b74c					libfunc_1049_name:
>b74c	d3 d2 f7				.byte $d3,$d2,$f7
.b74f					libfunc_1050:
>b74f	42 b7					.word libfunc_1049
>b751	ca 06 ff ff				.dword $FFFF06CA
>b755	59 b7					.word libfunc_1050_name
>b757	00 41					.byte 0,'A'
.b759					libfunc_1050_name:
>b759	c3 c4 f7				.byte $c3,$c4,$f7
.b75c					libfunc_1051:
>b75c	4f b7					.word libfunc_1050
>b75e	7c 05 ff ff				.dword $FFFF057C
>b762	66 b7					.word libfunc_1051_name
>b764	00 41					.byte 0,'A'
.b766					libfunc_1051_name:
>b766	c9 c8 f7				.byte $c9,$c8,$f7
.b769					libfunc_1052:
>b769	5c b7					.word libfunc_1051
>b76b	da 06 ff ff				.dword $FFFF06DA
>b76f	73 b7					.word libfunc_1052_name
>b771	00 41					.byte 0,'A'
.b773					libfunc_1052_name:
>b773	cf c7 f7				.byte $cf,$c7,$f7
.b776					libfunc_1053:
>b776	69 b7					.word libfunc_1052
>b778	fa 06 ff ff				.dword $FFFF06FA
>b77c	80 b7					.word libfunc_1053_name
>b77e	00 41					.byte 0,'A'
.b780					libfunc_1053_name:
>b780	cf cb f7				.byte $cf,$cb,$f7
.b783					libfunc_1054:
>b783	00 00					.word 0
>b785	80 03 ff ff				.dword $FFFF0380
>b789	8d b7					.word libfunc_1054_name
>b78b	00 41					.byte 0,'A'
.b78d					libfunc_1054_name:
>b78d	d2 d3 f8				.byte $d2,$d3,$f8
.b790					libfunc_1055:
>b790	83 b7					.word libfunc_1054
>b792	a0 03 ff ff				.dword $FFFF03A0
>b796	9a b7					.word libfunc_1055_name
>b798	00 41					.byte 0,'A'
.b79a					libfunc_1055_name:
>b79a	cb c3 f8				.byte $cb,$c3,$f8
.b79d					libfunc_1056:
>b79d	90 b7					.word libfunc_1055
>b79f	c0 03 ff ff				.dword $FFFF03C0
>b7a3	a7 b7					.word libfunc_1056_name
>b7a5	00 41					.byte 0,'A'
.b7a7					libfunc_1056_name:
>b7a7	c2 cf f8				.byte $c2,$cf,$f8
.b7aa					libfunc_1057:
>b7aa	9d b7					.word libfunc_1056
>b7ac	30 04 ff ff				.dword $FFFF0430
>b7b0	b4 b7					.word libfunc_1057_name
>b7b2	00 41					.byte 0,'A'
.b7b4					libfunc_1057_name:
>b7b4	c1 cc e8				.byte $c1,$cc,$e8
.b7b7					libfunc_1058:
>b7b7	aa b7					.word libfunc_1057
>b7b9	6c 05 ff ff				.dword $FFFF056C
>b7bd	c1 b7					.word libfunc_1058_name
>b7bf	00 41					.byte 0,'A'
.b7c1					libfunc_1058_name:
>b7c1	c9 cc e8				.byte $c9,$cc,$e8
.b7c4					libfunc_1059:
>b7c4	b7 b7					.word libfunc_1058
>b7c6	40 06 ff ff				.dword $FFFF0640
>b7ca	ce b7					.word libfunc_1059_name
>b7cc	00 41					.byte 0,'A'
.b7ce					libfunc_1059_name:
>b7ce	d1 d3 e8				.byte $d1,$d3,$e8
.b7d1					libfunc_1060:
>b7d1	c4 b7					.word libfunc_1059
>b7d3	88 06 ff ff				.dword $FFFF0688
>b7d7	db b7					.word libfunc_1060_name
>b7d9	00 41					.byte 0,'A'
.b7db					libfunc_1060_name:
>b7db	c3 c4 f8				.byte $c3,$c4,$f8
.b7de					libfunc_1061:
>b7de	d1 b7					.word libfunc_1060
>b7e0	a8 06 ff ff				.dword $FFFF06A8
>b7e4	e8 b7					.word libfunc_1061_name
>b7e6	00 41					.byte 0,'A'
.b7e8					libfunc_1061_name:
>b7e8	d3 c0 f8				.byte $d3,$c0,$f8
.b7eb					libfunc_1062:
>b7eb	de b7					.word libfunc_1061
>b7ed	c8 06 ff ff				.dword $FFFF06C8
>b7f1	f5 b7					.word libfunc_1062_name
>b7f3	00 41					.byte 0,'A'
.b7f5					libfunc_1062_name:
>b7f5	c8 cd f8				.byte $c8,$cd,$f8
.b7f8					libfunc_1063:
>b7f8	eb b7					.word libfunc_1062
>b7fa	58 06 ff ff				.dword $FFFF0658
>b7fe	02 b8					.word libfunc_1063_name
>b800	00 41					.byte 0,'A'
.b802					libfunc_1063_name:
>b802	c2 cb e8				.byte $c2,$cb,$e8
.b805					libfunc_1064:
>b805	f8 b7					.word libfunc_1063
>b807	78 06 ff ff				.dword $FFFF0678
>b80b	0f b8					.word libfunc_1064_name
>b80d	00 41					.byte 0,'A'
.b80f					libfunc_1064_name:
>b80f	d2 c4 e8				.byte $d2,$c4,$e8
.b812					libfunc_1065:
>b812	05 b8					.word libfunc_1064
>b814	5a 06 ff ff				.dword $FFFF065A
>b818	1c b8					.word libfunc_1065_name
>b81a	00 41					.byte 0,'A'
.b81c					libfunc_1065_name:
>b81c	cf c7 f8				.byte $cf,$c7,$f8
.b81f					libfunc_1066:
>b81f	12 b8					.word libfunc_1065
>b821	7a 06 ff ff				.dword $FFFF067A
>b825	29 b8					.word libfunc_1066_name
>b827	00 41					.byte 0,'A'
.b829					libfunc_1066_name:
>b829	cf cb f8				.byte $cf,$cb,$f8
.b82c					libfunc_1067:
>b82c	00 00					.word 0
>b82e	00 06 ff ff				.dword $FFFF0600
>b832	36 b8					.word libfunc_1067_name
>b834	00 41					.byte 0,'A'
.b836					libfunc_1067_name:
>b836	c1 d1 ea				.byte $c1,$d1,$ea
.b839					libfunc_1068:
>b839	00 00					.word 0
>b83b	00 02 ff ff				.dword $FFFF0200
>b83f	43 b8					.word libfunc_1068_name
>b841	00 41					.byte 0,'A'
.b843					libfunc_1068_name:
>b843	c0 d2 eb				.byte $c0,$d2,$eb
.b846					libfunc_1069:
>b846	39 b8					.word libfunc_1068
>b848	20 02 ff ff				.dword $FFFF0220
>b84c	50 b8					.word libfunc_1069_name
>b84e	00 41					.byte 0,'A'
.b850					libfunc_1069_name:
>b850	d1 ce eb				.byte $d1,$ce,$eb
.b853					libfunc_1070:
>b853	46 b8					.word libfunc_1069
>b855	10 04 ff ff				.dword $FFFF0410
>b859	5d b8					.word libfunc_1070_name
>b85b	00 41					.byte 0,'A'
.b85d					libfunc_1070_name:
>b85d	c1 cf eb				.byte $c1,$cf,$eb
.b860					libfunc_1071:
>b860	00 00					.word 0
>b862	5e b9 00 00				.dword String_Len
>b866	6a b8					.word libfunc_1071_name
>b868	00 43					.byte 0,'C'
.b86a					libfunc_1071_name:
>b86a	d2 d3 d1 df cb c4 ed			.byte $d2,$d3,$d1,$df,$cb,$c4,$ed
.b871					libfunc_1072:
>b871	60 b8					.word libfunc_1071
>b873	f6 b9 00 00				.dword Vera_SpriteEnable
>b877	7b b8					.word libfunc_1072_name
>b879	00 43					.byte 0,'C'
.b87b					libfunc_1072_name:
>b87b	d5 c4 d1 c0 df d2 df ce			.byte $d5,$c4,$d1,$c0,$df,$d2,$df,$ce,$ed
>b883	ed
.b884					libfunc_1073:
>b884	00 00					.word 0
>b886	c0 01 ff ff				.dword $FFFF01C0
>b88a	8e b8					.word libfunc_1073_name
>b88c	00 41					.byte 0,'A'
.b88e					libfunc_1073_name:
>b88e	c2 cc ef				.byte $c2,$cc,$ef
.b891					libfunc_1074:
>b891	84 b8					.word libfunc_1073
>b893	4c 05 ff ff				.dword $FFFF054C
>b897	9b b8					.word libfunc_1074_name
>b899	00 41					.byte 0,'A'
.b89b					libfunc_1074_name:
>b89b	c9 cc ef				.byte $c9,$cc,$ef
.b89e					libfunc_1075:
>b89e	91 b8					.word libfunc_1074
>b8a0	08 06 ff ff				.dword $FFFF0608
>b8a4	a8 b8					.word libfunc_1075_name
>b8a6	00 41					.byte 0,'A'
.b8a8					libfunc_1075_name:
>b8a8	cf c7 ef				.byte $cf,$c7,$ef
.b8ab					libfunc_1076:
>b8ab	9e b8					.word libfunc_1075
>b8ad	28 06 ff ff				.dword $FFFF0628
>b8b1	b5 b8					.word libfunc_1076_name
>b8b3	00 41					.byte 0,'A'
.b8b5					libfunc_1076_name:
>b8b5	cf cb ef				.byte $cf,$cb,$ef
.b8b8					libfunc_1077:
>b8b8	ab b8					.word libfunc_1076
>b8ba	ea 06 ff ff				.dword $FFFF06EA
>b8be	c2 b8					.word libfunc_1077_name
>b8c0	00 41					.byte 0,'A'
.b8c2					libfunc_1077_name:
>b8c2	cd ce ef				.byte $cd,$ce,$ef
.b8c5					DefaultHashTable:
>b8c5	ef b4					.word libfunc_1008
>b8c7	23 b5					.word libfunc_1012
>b8c9	dc b5					.word libfunc_1026
>b8cb	62 b6					.word libfunc_1035
>b8cd	af b6					.word libfunc_1039
>b8cf	d0 b6					.word libfunc_1041
>b8d1	dd b6					.word libfunc_1042
>b8d3	76 b7					.word libfunc_1053
>b8d5	1f b8					.word libfunc_1066
>b8d7	00 00					.word 0
>b8d9	2c b8					.word libfunc_1067
>b8db	53 b8					.word libfunc_1070
>b8dd	00 00					.word 0
>b8df	71 b8					.word libfunc_1072
>b8e1	00 00					.word 0
>b8e3	b8 b8					.word libfunc_1077

;******  Return to file: main.asm


;******  Processing file: generated/library.inc

.0827					RandomSeed:
>0827							.dword 		?
.b8e5					System_Random:
.b8e5	ad 27 08	lda $0827		lda 	RandomSeed
.b8e8	0d 28 08	ora $0828		ora 	RandomSeed+1
.b8eb	0d 29 08	ora $0829		ora 	RandomSeed+2
.b8ee	0d 2a 08	ora $082a		ora 	RandomSeed+3
.b8f1	d0 09		bne $b8fc		bne 	_SRSeeded
.b8f3	ee 28 08	inc $0828		inc 	RandomSeed+1
.b8f6	ce 2a 08	dec $082a		dec 	RandomSeed+3
.b8f9	20 e5 b8	jsr $b8e5		jsr 	System_Random
.b8fc					_SRSeeded:
.b8fc	5a		phy			phy
.b8fd	ac 29 08	ldy $0829		ldy RandomSeed+2 ; will move to RandomSeed+3 at the end
.b900	ad 28 08	lda $0828		lda RandomSeed+1
.b903	8d 29 08	sta $0829		sta RandomSeed+2
.b906	ad 2a 08	lda $082a		lda RandomSeed+3 ; original high byte
.b909	4a		lsr a			lsr
.b90a	8d 28 08	sta $0828		sta RandomSeed+1 ; reverse: 100011
.b90d	4a		lsr a			lsr
.b90e	4a		lsr a			lsr
.b90f	4a		lsr a			lsr
.b910	4a		lsr a			lsr
.b911	4d 28 08	eor $0828		eor RandomSeed+1
.b914	4a		lsr a			lsr
.b915	4d 28 08	eor $0828		eor RandomSeed+1
.b918	4d 27 08	eor $0827		eor RandomSeed+0 ; combine with original low byte
.b91b	8d 28 08	sta $0828		sta RandomSeed+1
.b91e	ad 2a 08	lda $082a		lda RandomSeed+3 ; original high byte
.b921	0a		asl a			asl
.b922	4d 2a 08	eor $082a		eor RandomSeed+3
.b925	0a		asl a			asl
.b926	0a		asl a			asl
.b927	0a		asl a			asl
.b928	0a		asl a			asl
.b929	4d 2a 08	eor $082a		eor RandomSeed+3
.b92c	0a		asl a			asl
.b92d	0a		asl a			asl
.b92e	4d 2a 08	eor $082a		eor RandomSeed+3
.b931	8c 2a 08	sty $082a		sty RandomSeed+3 ; finish rotating byte 2 into 3
.b934	8d 27 08	sta $0827		sta RandomSeed+0
.b937	e8		inx			inx
.b938	ad 27 08	lda $0827		lda	RandomSeed+0
.b93b	9d 00 0c	sta $0c00,x		sta stack0,x
.b93e	ad 28 08	lda $0828		lda	RandomSeed+1
.b941	9d 00 0d	sta $0d00,x		sta stack1,x
.b944	ad 29 08	lda $0829		lda	RandomSeed+2
.b947	9d 00 0e	sta $0e00,x		sta stack2,x
.b94a	ad 2a 08	lda $082a		lda	RandomSeed+3
.b94d	9d 00 0f	sta $0f00,x		sta stack3,x
.b950	7a		ply			ply
.b951	60		rts			rts
.b952					IO_Clear:
.b952	a9 93		lda #$93		lda 	#SCM_CLS
.b954	4c a5 a2	jmp $a2a5		jmp 	ExternPrint
.b957					IO_Emit:
.b957	bd 00 0c	lda $0c00,x		lda 	stack0,x
.b95a	ca		dex			dex
.b95b	4c a5 a2	jmp $a2a5		jmp 	ExternPrint
.b95e					String_Len:
.b95e	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy string address
.b961	85 14		sta $14				sta 	zTemp0
.b963	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b966	85 15		sta $15				sta 	zTemp0+1
.b968	5a		phy				phy
.b969	a0 ff		ldy #$ff			ldy 	#255 						; find string length
.b96b	c8		iny		_SLLoop:iny
.b96c	c0 ff		cpy #$ff			cpy 	#255 						; cant find EOS.
.b96e	f0 13		beq $b983			beq 	_SLFail
.b970	b1 14		lda ($14),y			lda 	(zTemp0),y
.b972	d0 f7		bne $b96b			bne 	_SLLoop
.b974	98		tya				tya
.b975	7a		ply				ply
.b976	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; return string
.b979	9e 00 0d	stz $0d00,x			stz 	stack1,x
.b97c	9e 00 0e	stz $0e00,x			stz 	stack2,x
.b97f	9e 00 0f	stz $0f00,x			stz 	stack3,x
.b982	60		rts				rts
.b983					_SLFail:
.b983	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>b986	4e 4f 54 20 53 54 52 49				.text 	"NOT STRING",0
>b98e	4e 47 00
=$9f20					Vera_Base = $9F20
.082b					veraCurrentLayer:
>082b							.byte 		? 						; current layer (0-1)
.082c					veraCurrentSprite:
>082c							.byte 		?						; current sprite (0-127)
.082d					veraSpriteMode:
>082d							.byte 		? 						; 0 4 bit, 1 8 bit
.b991					Vera_SetAddress:
.b991	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b994	8d 20 9f	sta $9f20			sta 	Vera_Base
.b997	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b99a	8d 21 9f	sta $9f21			sta 	Vera_Base+1
.b99d	bd 00 0e	lda $0e00,x			lda 	stack2,x
.b9a0	c9 10		cmp #$10			cmp 	#16
.b9a2	b0 02		bcs $b9a6			bcs 	_VSASetInc
.b9a4	09 10		ora #$10			ora 	#16
.b9a6					_VSASetInc:
.b9a6	8d 22 9f	sta $9f22			sta 	Vera_Base+2
.b9a9	ca		dex				dex
.b9aa	60		rts				rts
.b9ab					Vera_GetAddress:
.b9ab	e8		inx				inx
.b9ac	ad 20 9f	lda $9f20			lda 	Vera_Base
.b9af	9d 00 0c	sta $0c00,x			sta 	stack0,x
.b9b2	ad 21 9f	lda $9f21			lda 	Vera_Base+1
.b9b5	9d 00 0d	sta $0d00,x			sta 	stack1,x
.b9b8	ad 22 9f	lda $9f22			lda 	Vera_Base+2
.b9bb	9d 00 0e	sta $0e00,x			sta 	stack2,x
.b9be	9e 00 0f	stz $0f00,x			stz 	stack3,x
.b9c1	60		rts				rts
.b9c2					Vera_SetPalette:
.b9c2	1e 00 0c	asl $0c00,x			asl 	stack0,x
.b9c5	3e 00 0d	rol $0d00,x			rol 	stack1,x
.b9c8	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b9cb	8d 20 9f	sta $9f20			sta 	Vera_Base
.b9ce	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b9d1	29 01		and #$01			and 	#$01
.b9d3	09 10		ora #$10			ora 	#$10
.b9d5	8d 21 9f	sta $9f21			sta 	Vera_Base+1
.b9d8	a9 1f		lda #$1f			lda 	#$1F
.b9da	8d 22 9f	sta $9f22			sta 	Vera_Base+2
.b9dd	ca		dex				dex
.b9de	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b9e1	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b9e4	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b9e7	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.b9ea	ca		dex				dex
.b9eb	60		rts				rts
.b9ec					Vera_Sprite:
.b9ec	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b9ef	29 7f		and #$7f			and 	#$7F
.b9f1	8d 2c 08	sta $082c			sta 	veraCurrentSprite
.b9f4	ca		dex				dex
.b9f5	60		rts				rts
.b9f6					Vera_SpriteEnable:
.b9f6	a9 01		lda #$01			lda 	#1
.b9f8	80 02		bra $b9fc			bra 	Vera_SpriteControl
.b9fa					Vera_SpriteDisable:
.b9fa	a9 00		lda #$00			lda 	#0
.b9fc					Vera_SpriteControl:
.b9fc	48		pha				pha
.b9fd	a9 00		lda #$00			lda 	#$00
.b9ff	8d 20 9f	sta $9f20			sta 	Vera_Base
.ba02	a9 40		lda #$40			lda 	#$40
.ba04	8d 21 9f	sta $9f21			sta 	Vera_Base+1
.ba07	a9 1f		lda #$1f			lda 	#$1F
.ba09	8d 22 9f	sta $9f22			sta 	Vera_Base+2
.ba0c	68		pla				pla
.ba0d	29 01		and #$01			and 	#1
.ba0f	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.ba12	9c 23 9f	stz $9f23			stz 	Vera_Base+3
.ba15	60		rts				rts
.ba16					Vera_SpriteMove:
.ba16	a9 02		lda #$02			lda 	#2 							; physical position
.ba18	20 84 ba	jsr $ba84			jsr 	Vera_CurrentSprite
.ba1b	20 1e ba	jsr $ba1e			jsr 	_VSMOutPosition
.ba1e					_VSMOutPosition:
.ba1e	ca		dex				dex
.ba1f	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.ba22	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.ba25	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.ba28	29 03		and #$03			and 	#$03
.ba2a	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.ba2d	60		rts				rts
.ba2e					Vera_SpriteSetup:
.ba2e	a9 00		lda #$00			lda 	#0
.ba30	20 84 ba	jsr $ba84			jsr 	Vera_CurrentSprite
.ba33	ca		dex				dex
.ba34	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.ba37	85 14		sta $14				sta 	zTemp0
.ba39	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.ba3c	85 15		sta $15				sta 	zTemp0+1
.ba3e	bd 01 0e	lda $0e01,x			lda 	stack2+1,x
.ba41	85 16		sta $16				sta 	zTemp1
.ba43	5a		phy				phy
.ba44	a0 05		ldy #$05			ldy 	#5
.ba46	46 16		lsr $16		_VSSS:	lsr 	zTemp1
.ba48	66 15		ror $15				ror 	zTemp0+1
.ba4a	66 14		ror $14				ror 	zTemp0
.ba4c	88		dey				dey
.ba4d	d0 f7		bne $ba46			bne 	_VSSS
.ba4f	7a		ply				ply
.ba50	a5 14		lda $14				lda 	zTemp0
.ba52	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.ba55	a5 15		lda $15				lda 	zTemp0+1
.ba57	0d 2d 08	ora $082d			ora 	veraSpriteMode
.ba5a	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.ba5d	60		rts				rts
.ba5e					Vera_SetSize:
.ba5e	a9 06		lda #$06			lda 	#6
.ba60	20 84 ba	jsr $ba84			jsr 	Vera_CurrentSprite
.ba63	a9 1c		lda #$1c			lda 	#$1C
.ba65	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.ba68	ca		dex				dex
.ba69	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.ba6c	29 03		and #$03			and 	#3
.ba6e	85 14		sta $14				sta 	zTemp0
.ba70	0a		asl a				asl 	a
.ba71	0a		asl a				asl 	a
.ba72	05 14		ora $14				ora 	zTemp0
.ba74	0a		asl a				asl 	a
.ba75	0a		asl a				asl 	a
.ba76	0a		asl a				asl 	a
.ba77	0a		asl a				asl 	a
.ba78	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.ba7b	60		rts				rts
.ba7c					Vera_ByteW:
.ba7c	bd 00 0c	lda $0c00,x			lda 	stack0,x
.ba7f	8d 23 9f	sta $9f23			sta 	Vera_Base+3
.ba82	ca		dex				dex
.ba83	60		rts				rts
.ba84					Vera_CurrentSprite:
.ba84	48		pha				pha 								; save offset
.ba85	ad 2c 08	lda $082c			lda 	veraCurrentSprite 			; address in zTemp0
.ba88	0a		asl a				asl 	a
.ba89	85 14		sta $14				sta 	zTemp0		 				; sprite# x 2
.ba8b	64 15		stz $15				stz 	zTemp0+1
.ba8d	06 14		asl $14				asl 	zTemp0 						; x 8
.ba8f	26 15		rol $15				rol 	zTemp0+1
.ba91	06 14		asl $14				asl 	zTemp0
.ba93	68		pla				pla 								; fix up address
.ba94	05 14		ora $14				ora 	zTemp0
.ba96	8d 20 9f	sta $9f20			sta  	Vera_Base+0
.ba99	a5 15		lda $15				lda 	zTemp0+1
.ba9b	09 50		ora #$50			ora 	#$50
.ba9d	8d 21 9f	sta $9f21			sta 	Vera_Base+1
.baa0	a9 1f		lda #$1f			lda 	#$1F
.baa2	8d 22 9f	sta $9f22			sta 	Vera_Base+2
.baa5	60		rts				rts
.baa6					Vera_Load:
.baa6	da		phx				phx
.baa7	5a		phy				phy
.baa8	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; filename in zTemp0
.baab	85 14		sta $14				sta 	zTemp0
.baad	bd 00 0d	lda $0d00,x			lda 	stack1,x
.bab0	85 15		sta $15				sta 	zTemp0+1
.bab2	a2 00		ldx #$00			ldx 	#0 							; copy load code to input buffer
.bab4	bd dd ba	lda $badd,x	_VLCopy:lda 	_VLCopiableCode,x
.bab7	9d 00 09	sta $0900,x			sta 	InputBuffer,x
.baba	e8		inx				inx
.babb	e0 42		cpx #$42			cpx 	#_VLCopiableEnd-_VLCopiableCode
.babd	d0 f5		bne $bab4			bne 	_VLCopy
.babf	20 69 a3	jsr $a369			jsr 	EXGetLength 				; get file name length -> A
.bac2	20 00 09	jsr $0900			jsr 	InputBuffer
.bac5	b0 04		bcs $bacb			bcs 	_VLError
.bac7	7a		ply				ply
.bac8	fa		plx				plx
.bac9	ca		dex				dex 								; drop tos
.baca	60		rts				rts
.bacb					_VLError:
.bacb	20 fc a5	jsr $a5fc			jsr 	ErrorHandler
>bace	56 45 52 41 20 4c 4f 41				.text 	"VERA LOAD FAIL",0
>bad6	44 20 46 41 49 4c 00
.badd					_VLCopiableCode:
.badd	aa		tax				tax 								; length in X
.bade	ad 61 9f	lda $9f61			lda 	$9F61 						; save current bank
.bae1	48		pha				pha
.bae2	a9 fe		lda #$fe			lda 	#254 						; switch to useable buffer
.bae4	8d 61 9f	sta $9f61			sta 	$9F61
.bae7	8a		txa				txa
.bae8	a6 14		ldx $14				ldx 	zTemp0
.baea	a4 15		ldy $15				ldy 	zTemp0+1
.baec	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.baef	a9 01		lda #$01			lda 	#1
.baf1	a2 01		ldx #$01			ldx 	#1	 						; device #1
.baf3	a0 00		ldy #$00			ldy 	#0
.baf5	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.baf8	a0 a0		ldy #$a0			ldy 	#$A0 						; set target to $A000 and call load
.bafa	a9 00		lda #$00			lda 	#$00
.bafc	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.baff	b0 19		bcs $bb1a			bcs 	_VLExit
.bb01	a9 a0		lda #$a0			lda 	#$A0 						; send it all to VERA
.bb03	85 15		sta $15				sta 	zTemp0+1
.bb05	64 14		stz $14				stz 	zTemp0
.bb07	a0 00		ldy #$00			ldy 	#0
.bb09					_VLSendVera:
.bb09	b1 14		lda ($14),y			lda 	(zTemp0),y
.bb0b	8d 23 9f	sta $9f23			sta 	$9F23
.bb0e	c8		iny				iny
.bb0f	d0 f8		bne $bb09			bne 	_VLSendVera
.bb11	e6 15		inc $15				inc 	zTemp0+1
.bb13	a5 15		lda $15				lda 	zTemp0+1
.bb15	c9 c0		cmp #$c0			cmp 	#$C0
.bb17	d0 f0		bne $bb09			bne 	_VLSendVera
.bb19	18		clc				clc
.bb1a					_VLExit:
.bb1a	68		pla				pla 								; restore original bank
.bb1b	8d 61 9f	sta $9f61			sta 	$9F61
.bb1e	60		rts				rts
.bb1f					_VLCopiableEnd:

;******  Return to file: main.asm


;******  Processing file: generated/testcode.inc

>1100	15 64 00 02 11 20 74 65			.byte $15,$64,$00,$02,$11,$20,$74,$65,$73,$74,$20,$70,$72,$6f,$67,$72,$61,$6d,$20,$00,$00,$14,$6e,$00,$01,$07,$44,$45,$4d,$4f,$00,$d5,$c4,$d1,$c0,$df,$cb,$ce,$c0,$e3,$00,$06,$78,$00,$16,$2d,$00
>1108	73 74 20 70 72 6f 67 72 61 6d 20 00 00 14 6e 00
>1118	01 07 44 45 4d 4f 00 d5 c4 d1 c0 df cb ce c0 e3
>1128	00 06 78 00 16 2d 00

;******  Return to file: main.asm

>112f	00						.byte 	0

;******  End of listing
