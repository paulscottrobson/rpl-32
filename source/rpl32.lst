
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl32.prg -L rpl32.lst main.asm
; Sun Oct  6 13:28:00 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; build the interpreter here
=$0c00					StackAddress = $0C00 						; 1k of stack space (256 x 32 bits)
=$1000					MemoryStart = $1000 						; system memory starts here
=$6000					MemoryEnd = $6000 							; and ends here.
=$0bff					StructureStack = $0BFF 						; structure stack (works down to $xx00)
=$0a00					ExtDataArea = $0A00 						; space where non zp data goes
=16					HashTableSize = 16 							; hash tables to search.
>0000					CodePtr: 		.word ? 					; code pointer
>0002					StructSP: 		.word ?						; structure stack pointer
>0004					zTemp0:			.word ?						; temporary words
>0006					zTemp1: 		.word ?
>0008					zTemp2: 		.word ?
>000a					zTemp3: 		.word ?
>000c					zTemp4:			.word ?
>000e					zLTemp1:		.dword ?					; temporary longs
>0012					idDataAddr:		.word ? 					; data address.
>0014					ForAddr:		.byte ? 					; points to current FOR structure
>0a00					SBuffer:		.fill 32 					; string buffer
>0a20					SBPosition:		.byte ? 					; position in String Buffer
>0a21					NumConvCount:	.byte ? 					; used in int to string
>0a22					breakCount:		.byte ? 					; used to stop break firing every execution.
>0a23					SignCount:		.byte ?						; sign count for divide
>0a24					NumSuppress:	.byte ? 					; zero suppression flag
>1000					AZVariables:	.fill	26*4 				; 26 x 4 byte variables, which are A-Z
>1068					HashTable: 		.fill 	HashTableSize * 2 	; n x 2 links for the hash tables.
>1088	00 00				VarMemory:		.word 	0 					; next free byte available for VARIABLES (going up)
>108a	00 00				AllocMemory: 	.word 	0 					; last free byte availabel for ALLOC (going down)
=4352					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0c00					stack0 = StackAddress
=3328					stack1 = StackAddress+256
=3584					stack2 = StackAddress+512
=3840					stack3 = StackAddress+768
="V"					IDT_VARIABLE = 'V'							; type markers for the information store.
="P"					IDT_PROCEDURE = 'P'							; standard procedure (e.g. in code)
="C"					IDT_CODEPROC = 'C'							; machine language procedure.
="F"					STM_FOR = 'F'								; structure markers (for/next)
="C"					STM_CALL = 'C'								; call & return  (& ;)
="R"					STM_REPEAT = 'R'							; repeat & until
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=5					CTH_ERROR = COL_MAGENTA
=2					CTH_TOKEN = COL_GREEN
=3					CTH_IDENT = COL_YELLOW
=7					CTH_COMMENT = COL_WHITE
=5					CTH_STRING = COL_MAGENTA
=6					CTH_NUMBER = COL_CYAN

;******  Return to file: main.asm


;******  Processing file: macro.asm


;******  Return to file: main.asm

.0f00	4c 00 a0	jmp $a000			jmp 	Start
.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 b6 a1	jsr $a1b6			jsr 	ExternInitialise 			; interface setup
.a006	a2 00		ldx #$00			ldx 	#0 							; display boot message
.a008					_Display:
.a008	bd 20 a0	lda $a020,x			lda 	BootMessage,x
.a00b	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a00e	e8		inx				inx
.a00f	bd 20 a0	lda $a020,x			lda 	BootMessage,x
.a012	d0 f4		bne $a008			bne 	_Display
.a014	20 a3 a3	jsr $a3a3			jsr 	ResetForRun
.a017	20 98 a3	jsr $a398			jsr 	ResetCodePointer
.a01a	4c 10 a7	jmp $a710			jmp 	TTest
.a01d	4c 3d ac	jmp $ac3d			jmp 	System_RUN
.a020					BootMessage:

;******  Processing file: generated/bootmessage.inc

>a020	2a 2a 2a 2a 20 52 50 4c			.byte $2a,$2a,$2a,$2a,$20,$52,$50,$4c,$2f,$33,$32,$20,$49,$4e,$54,$45,$52,$50,$52,$45,$54,$45,$52,$20,$2a,$2a,$2a,$2a,$0d,$0d,$42,$55,$49,$4c,$44,$3a,$44,$45,$56,$20,$44,$41,$54,$45,$3a,$30,$36,$2d,$4f,$43,$54,$2d,$32,$30,$31,$39,$0d,$0d,$00
>a028	2f 33 32 20 49 4e 54 45 52 50 52 45 54 45 52 20
>a038	2a 2a 2a 2a 0d 0d 42 55 49 4c 44 3a 44 45 56 20
>a048	44 41 54 45 3a 30 36 2d 4f 43 54 2d 32 30 31 39
>a058	0d 0d 00

;******  Return to file: main.asm


;******  Processing file: generated/tables.inc

.a05b					KeywordText:
>a05b	01 20					.byte $01,$20                          ; $10
>a05d	01 21					.byte $01,$21                          ; $11 !
>a05f	01 26					.byte $01,$26                          ; $12 &
>a061	01 2a					.byte $01,$2a                          ; $13 *
>a063	01 2b					.byte $01,$2b                          ; $14 +
>a065	02 2b 2b				.byte $02,$2b,$2b                      ; $15 ++
>a068	01 2d					.byte $01,$2d                          ; $16 -
>a06a	02 2d 2d				.byte $02,$2d,$2d                      ; $17 --
>a06d	01 2f					.byte $01,$2f                          ; $18 /
>a06f	01 3b					.byte $01,$3b                          ; $19 ;
>a071	01 3c					.byte $01,$3c                          ; $1a <
>a073	02 3c 3c				.byte $02,$3c,$3c                      ; $1b <<
>a076	02 3c 3d				.byte $02,$3c,$3d                      ; $1c <=
>a079	02 3c 3e				.byte $02,$3c,$3e                      ; $1d <>
>a07c	01 3d					.byte $01,$3d                          ; $1e =
>a07e	01 3e					.byte $01,$3e                          ; $1f >
>a080	02 3e 3d				.byte $02,$3e,$3d                      ; $20 >=
>a083	02 3e 3e				.byte $02,$3e,$3e                      ; $21 >>
>a086	01 40					.byte $01,$40                          ; $22 @
>a088	03 41 42 53				.byte $03,$41,$42,$53                  ; $23 ABS
>a08c	05 41 4c 4c 4f 43			.byte $05,$41,$4c,$4c,$4f,$43          ; $24 ALLOC
>a092	03 41 4e 44				.byte $03,$41,$4e,$44                  ; $25 AND
>a096	06 41 53 53 45 52 54			.byte $06,$41,$53,$53,$45,$52,$54      ; $26 ASSERT
>a09d	02 43 21				.byte $02,$43,$21                      ; $27 C!
>a0a0	02 43 40				.byte $02,$43,$40                      ; $28 C@
>a0a3	03 44 45 46				.byte $03,$44,$45,$46                  ; $29 DEF
>a0a7	04 44 52 4f 50				.byte $04,$44,$52,$4f,$50              ; $2a DROP
>a0ac	03 44 55 50				.byte $03,$44,$55,$50                  ; $2b DUP
>a0b0	04 45 4c 53 45				.byte $04,$45,$4c,$53,$45              ; $2c ELSE
>a0b5	05 45 4d 50 54 59			.byte $05,$45,$4d,$50,$54,$59          ; $2d EMPTY
>a0bb	03 45 4e 44				.byte $03,$45,$4e,$44                  ; $2e END
>a0bf	05 45 4e 44 49 46			.byte $05,$45,$4e,$44,$49,$46          ; $2f ENDIF
>a0c5	03 46 4f 52				.byte $03,$46,$4f,$52                  ; $30 FOR
>a0c9	02 49 46				.byte $02,$49,$46                      ; $31 IF
>a0cc	05 49 4e 44 45 58			.byte $05,$49,$4e,$44,$45,$58          ; $32 INDEX
>a0d2	04 4c 49 53 54				.byte $04,$4c,$49,$53,$54              ; $33 LIST
>a0d7	03 4d 4f 44				.byte $03,$4d,$4f,$44                  ; $34 MOD
>a0db	06 4e 45 47 41 54 45			.byte $06,$4e,$45,$47,$41,$54,$45      ; $35 NEGATE
>a0e2	03 4e 45 57				.byte $03,$4e,$45,$57                  ; $36 NEW
>a0e6	04 4e 45 58 54				.byte $04,$4e,$45,$58,$54              ; $37 NEXT
>a0eb	03 4e 49 50				.byte $03,$4e,$49,$50                  ; $38 NIP
>a0ef	03 4e 4f 54				.byte $03,$4e,$4f,$54                  ; $39 NOT
>a0f3	03 4f 4c 44				.byte $03,$4f,$4c,$44                  ; $3a OLD
>a0f7	02 4f 52				.byte $02,$4f,$52                      ; $3b OR
>a0fa	04 4f 56 45 52				.byte $04,$4f,$56,$45,$52              ; $3c OVER
>a0ff	06 52 45 50 45 41 54			.byte $06,$52,$45,$50,$45,$41,$54      ; $3d REPEAT
>a106	03 52 55 4e				.byte $03,$52,$55,$4e                  ; $3e RUN
>a10a	03 53 48 4c				.byte $03,$53,$48,$4c                  ; $3f SHL
>a10e	03 53 48 52				.byte $03,$53,$48,$52                  ; $40 SHR
>a112	05 53 54 41 43 4b			.byte $05,$53,$54,$41,$43,$4b          ; $41 STACK
>a118	04 53 54 4f 50				.byte $04,$53,$54,$4f,$50              ; $42 STOP
>a11d	04 53 57 41 50				.byte $04,$53,$57,$41,$50              ; $43 SWAP
>a122	03 53 59 53				.byte $03,$53,$59,$53                  ; $44 SYS
>a126	05 55 4e 54 49 4c			.byte $05,$55,$4e,$54,$49,$4c          ; $45 UNTIL
>a12c	02 57 21				.byte $02,$57,$21                      ; $46 W!
>a12f	02 57 40				.byte $02,$57,$40                      ; $47 W@
>a132	03 58 4f 52				.byte $03,$58,$4f,$52                  ; $48 XOR
>a136	02 5b 5d				.byte $02,$5b,$5d                      ; $49 []
>a139	01 5e					.byte $01,$5e                          ; $4a ^
>a13b	01 2d					.byte $01,$2d                          ; $4b {-}
>a13d	00					.byte $00
.a13e					KeywordVectorTable:
>a13e	99 a4					.word SyntaxError                      ; $10
>a140	99 a9					.word Mem_DPoke                        ; $11 !
>a142	99 a4					.word SyntaxError                      ; $12 &
>a144	b7 aa					.word MulInteger32                     ; $13 *
>a146	c0 a9					.word Stack_Add                        ; $14 +
>a148	c0 a8					.word Unary_Increment                  ; $15 ++
>a14a	e7 a9					.word Stack_Sub                        ; $16 -
>a14c	d3 a8					.word Unary_Decrement                  ; $17 --
>a14e	00 ab					.word DivInteger32                     ; $18 /
>a150	99 a4					.word SyntaxError                      ; $19 ;
>a152	e7 ab					.word Comp_Less                        ; $1a <
>a154	f5 a8					.word Unary_Shl                        ; $1b <<
>a156	12 ac					.word Comp_LessEqual                   ; $1c <=
>a158	b0 ab					.word Comp_NotEqual                    ; $1d <>
>a15a	ad ab					.word Comp_Equal                       ; $1e =
>a15c	15 ac					.word Comp_Greater                     ; $1f >
>a15e	ea ab					.word Comp_GreaterEqual                ; $20 >=
>a160	02 a9					.word Unary_Shr                        ; $21 >>
>a162	47 a9					.word Mem_DPeek                        ; $22 @
>a164	77 a8					.word Unary_Absolute                   ; $23 ABS
>a166	99 a4					.word SyntaxError                      ; $24 ALLOC
>a168	0e aa					.word Stack_And                        ; $25 AND
>a16a	55 ac					.word System_Assert                    ; $26 ASSERT
>a16c	6c a9					.word Mem_Poke                         ; $27 C!
>a16e	0f a9					.word Mem_Peek                         ; $28 C@
>a170	99 a4					.word SyntaxError                      ; $29 DEF
>a172	ec a7					.word Stack_Drop                       ; $2a DROP
>a174	ee a7					.word Stack_Dup                        ; $2b DUP
>a176	99 a4					.word SyntaxError                      ; $2c ELSE
>a178	e9 a7					.word Stack_Empty                      ; $2d EMPTY
>a17a	46 ac					.word System_END                       ; $2e END
>a17c	99 a4					.word SyntaxError                      ; $2f ENDIF
>a17e	ae ad					.word Command_For                      ; $30 FOR
>a180	99 a4					.word SyntaxError                      ; $31 IF
>a182	4a ae					.word Command_Index                    ; $32 INDEX
>a184	10 a6					.word Cmd_List                         ; $33 LIST
>a186	95 ab					.word ModInteger32                     ; $34 MOD
>a188	7d a8					.word Unary_Negate                     ; $35 NEGATE
>a18a	6f ac					.word System_New                       ; $36 NEW
>a18c	05 ae					.word Command_Next                     ; $37 NEXT
>a18e	08 a8					.word Stack_Nip                        ; $38 NIP
>a190	9f a8					.word Unary_Not                        ; $39 NOT
>a192	76 ac					.word System_Old                       ; $3a OLD
>a194	5a aa					.word Stack_Or                         ; $3b OR
>a196	22 a8					.word Stack_Over                       ; $3c OVER
>a198	70 ae					.word Command_Repeat                   ; $3d REPEAT
>a19a	3d ac					.word System_RUN                       ; $3e RUN
>a19c	80 aa					.word Stack_Shl                        ; $3f SHL
>a19e	83 aa					.word Stack_Shr                        ; $40 SHR
>a1a0	c2 ac					.word System_Stack                     ; $41 STACK
>a1a2	4a ac					.word System_STOP                      ; $42 STOP
>a1a4	3c a8					.word Stack_Swap                       ; $43 SWAP
>a1a6	9a ac					.word System_Sys                       ; $44 SYS
>a1a8	7a ae					.word Command_Until                    ; $45 UNTIL
>a1aa	7e a9					.word Mem_WPoke                        ; $46 W!
>a1ac	28 a9					.word Mem_WPeek                        ; $47 W@
>a1ae	34 aa					.word Stack_Xor                        ; $48 XOR
>a1b0	99 a4					.word SyntaxError                      ; $49 []
>a1b2	4b ad					.word WriteVariable                    ; $4a ^
>a1b4	7d a8					.word Unary_Const_Minus                ; $4b {-}
=$10					KWD_SPACE = $10                  ; $10
=$11					KWD_PLING = $11                  ; $11 !
=$12					KWD_AMPERSAND = $12              ; $12 &
=$13					KWD_ASTERISK = $13               ; $13 *
=$14					KWD_PLUS = $14                   ; $14 +
=$15					KWD_PLUSPLUS = $15               ; $15 ++
=$16					KWD_MINUS = $16                  ; $16 -
=$17					KWD_MINUSMINUS = $17             ; $17 --
=$18					KWD_SLASH = $18                  ; $18 /
=$19					KWD_SEMICOLON = $19              ; $19 ;
=$1a					KWD_LESS = $1a                   ; $1a <
=$1b					KWD_LESSLESS = $1b               ; $1b <<
=$1c					KWD_LESSEQUAL = $1c              ; $1c <=
=$1d					KWD_LESSGREATER = $1d            ; $1d <>
=$1e					KWD_EQUAL = $1e                  ; $1e =
=$1f					KWD_GREATER = $1f                ; $1f >
=$20					KWD_GREATEREQUAL = $20           ; $20 >=
=$21					KWD_GREATERGREATER = $21         ; $21 >>
=$22					KWD_AT = $22                     ; $22 @
=$23					KWD_ABS = $23                    ; $23 ABS
=$24					KWD_ALLOC = $24                  ; $24 ALLOC
=$25					KWD_AND = $25                    ; $25 AND
=$26					KWD_ASSERT = $26                 ; $26 ASSERT
=$27					KWD_CPLING = $27                 ; $27 C!
=$28					KWD_CAT = $28                    ; $28 C@
=$29					KWD_DEF = $29                    ; $29 DEF
=$2a					KWD_DROP = $2a                   ; $2a DROP
=$2b					KWD_DUP = $2b                    ; $2b DUP
=$2c					KWD_ELSE = $2c                   ; $2c ELSE
=$2d					KWD_EMPTY = $2d                  ; $2d EMPTY
=$2e					KWD_END = $2e                    ; $2e END
=$2f					KWD_ENDIF = $2f                  ; $2f ENDIF
=$30					KWD_FOR = $30                    ; $30 FOR
=$31					KWD_IF = $31                     ; $31 IF
=$32					KWD_INDEX = $32                  ; $32 INDEX
=$33					KWD_LIST = $33                   ; $33 LIST
=$34					KWD_MOD = $34                    ; $34 MOD
=$35					KWD_NEGATE = $35                 ; $35 NEGATE
=$36					KWD_NEW = $36                    ; $36 NEW
=$37					KWD_NEXT = $37                   ; $37 NEXT
=$38					KWD_NIP = $38                    ; $38 NIP
=$39					KWD_NOT = $39                    ; $39 NOT
=$3a					KWD_OLD = $3a                    ; $3a OLD
=$3b					KWD_OR = $3b                     ; $3b OR
=$3c					KWD_OVER = $3c                   ; $3c OVER
=$3d					KWD_REPEAT = $3d                 ; $3d REPEAT
=$3e					KWD_RUN = $3e                    ; $3e RUN
=$3f					KWD_SHL = $3f                    ; $3f SHL
=$40					KWD_SHR = $40                    ; $40 SHR
=$41					KWD_STACK = $41                  ; $41 STACK
=$42					KWD_STOP = $42                   ; $42 STOP
=$43					KWD_SWAP = $43                   ; $43 SWAP
=$44					KWD_SYS = $44                    ; $44 SYS
=$45					KWD_UNTIL = $45                  ; $45 UNTIL
=$46					KWD_WPLING = $46                 ; $46 W!
=$47					KWD_WAT = $47                    ; $47 W@
=$48					KWD_XOR = $48                    ; $48 XOR
=$49					KWD_LSQPARENRSQPAREN = $49       ; $49 []
=$4a					KWD_HAT = $4a                    ; $4a ^
=$4b					KWD_CONSTANT_MINUS = $4b         ; $4b {-}

;******  Return to file: main.asm


;******  Processing file: system/extern.asm

.a1b6					ExternInitialise:
.a1b6	a9 07		lda #$07			lda 	#$07 						; set colour
.a1b8	8d 86 02	sta $0286			sta 	646
.a1bb	a9 0e		lda #$0e			lda 	#14							; lower case
.a1bd	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1c0	a9 93		lda #$93			lda 	#147 						; clear screen
.a1c2	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1c5	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a1c7	4c e1 a1	jmp $a1e1			jmp 	ExternColour
.a1ca					ExternCheckBreak:
.a1ca	da		phx				phx 								; make sure we keep XY
.a1cb	5a		phy				phy
.a1cc	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a1cf	f0 03		beq $a1d4			beq		_ECBExit 					; stopped
.a1d1	7a		ply				ply 								; restore and exit.
.a1d2	fa		plx				plx
.a1d3	60		rts				rts
.a1d4					_ECBExit:
.a1d4	4c ed a4	jmp $a4ed			jmp 	WarmStart
.a1d7					ExternPrint:
.a1d7	48		pha				pha
.a1d8	da		phx				phx
.a1d9	5a		phy				phy
.a1da	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1dd	7a		ply				ply
.a1de	fa		plx				plx
.a1df	68		pla				pla
.a1e0	60		rts				rts
.a1e1					ExternColour:
.a1e1	48		pha				pha
.a1e2	da		phx				phx
.a1e3	aa		tax				tax
.a1e4	bd ed a1	lda $a1ed,x			lda 	_ECTable,x
.a1e7	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a1ea	fa		plx				plx
.a1eb	68		pla				pla
.a1ec	60		rts				rts
.a1ed					_ECTable:
>a1ed	90						.byte 	144
>a1ee	1c						.byte 	28
>a1ef	1e						.byte 	30
>a1f0	9e						.byte 	158
>a1f1	1f						.byte 	31
>a1f2	9c						.byte 	156
>a1f3	9f						.byte 	159
>a1f4	05						.byte 	5

;******  Return to file: main.asm


;******  Processing file: system/execute.asm

.a1f5					EXNextLine:
.a1f5	b2 00		lda ($00)			lda 	(codePtr) 					; is it run from the buffer (offset 0)
.a1f7	f0 0f		beq $a208			beq 	_EXNLWarmStart
.a1f9	18		clc				clc 								; advance code pointer to next line
.a1fa	65 00		adc $00				adc 	codePtr
.a1fc	85 00		sta $00				sta 	codePtr
.a1fe	90 02		bcc $a202			bcc 	_EXNLNoBump
.a200	e6 01		inc $01				inc 	codePtr+1
.a202					_EXNLNoBump:
.a202	a0 03		ldy #$03			ldy 	#3 							; position in that line
.a204	b2 00		lda ($00)			lda 	(codePtr) 					; read offset
.a206	d0 03		bne $a20b			bne 	Execute 					; not end of program
.a208					_EXNLWarmStart:
.a208	4c 46 ac	jmp $ac46			jmp 	System_END
.a20b					Execute:
.a20b	ee 22 0a	inc $0a22			inc 	BreakCount 					; break occasionally. too slow otherwise.
.a20e	d0 03		bne $a213			bne 	_EXNoBreak
.a210	20 ca a1	jsr $a1ca			jsr 	ExternCheckBreak
.a213					_EXNoBreak:
.a213					_EXGetNext:
.a213	b1 00		lda ($00),y			lda 	(codePtr),y 				; load the character
.a215	f0 de		beq $a1f5			beq 	EXNextLine 					; reached end of the line.
.a217	c8		iny				iny 								; advance pointer.
.a218	c9 10		cmp #$10			cmp 	#KWD_SPACE 					; skip spaces
.a21a	f0 f7		beq $a213			beq 	_ExGetNext
.a21c	c9 10		cmp #$10			cmp 	#$10 						; is it 01-0F, which means a string/comment ?
.a21e	90 27		bcc $a247			bcc 	EXStringComment
.a220	c9 80		cmp #$80			cmp 	#$80 						; if it 10-7F, token
.a222	90 0d		bcc $a231			bcc 	EXTokenExecute
.a224	c9 c0		cmp #$c0			cmp 	#$C0 						; is it a numeric constant 80-BF
.a226	90 03		bcc $a22b			bcc 	EXPushConstant
.a228	4c f0 ac	jmp $acf0			jmp 	Identifier 					; it's an identifier C0-FF
.a22b					EXPushConstant:
.a22b	88		dey				dey
.a22c	20 76 a2	jsr $a276			jsr 	ExtractIntegerToTOS 		; extract integer
.a22f	80 da		bra $a20b			bra 	Execute
.a231					EXTokenExecute:
.a231	0a		asl a				asl 	a 							; double token, also clears carry
.a232	da		phx				phx 								; save X, put token x 2 in X
.a233	aa		tax				tax
.a234	bd 1e a1	lda $a11e,x			lda 	KeywordVectorTable-$20,x 	; copy vector. The -$20 is because the tokens
.a237	85 04		sta $04				sta 	zTemp0 						; start at $10.
.a239	bd 1f a1	lda $a11f,x			lda 	KeywordVectorTable-$20+1,x
.a23c	85 05		sta $05				sta 	zTemp0+1
.a23e	fa		plx				plx 								; restore X
.a23f	20 44 a2	jsr $a244			jsr 	_EXTCall 					; call the routine
.a242	80 c7		bra $a20b			bra 	Execute
.a244					_EXTCall:
.a244	6c 04 00	jmp ($0004)			jmp 	(zTemp0)
.a247					EXStringComment:
.a247	c9 02		cmp #$02			cmp 	#$02 						; 02 is the token for single quoted string
.a249	f0 15		beq $a260			beq 	EXStringSkip 				; (comment), so just skip it.
.a24b	e8		inx				inx 								; push Y + 1 + codePtr on the stack
.a24c	98		tya				tya
.a24d	38		sec				sec
.a24e	65 00		adc $00				adc 	codePtr
.a250	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a253	a5 01		lda $01				lda 	codePtr+1
.a255	69 00		adc #$00			adc 	#0
.a257	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a25a	9e 00 0e	stz $0e00,x			stz 	stack2,x 					; clear the upper 2 bytes.
.a25d	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a260					EXStringSkip:
.a260	98		tya				tya 								; the current position in A
.a261	18		clc				clc
.a262	71 00		adc ($00),y			adc 	(codePtr),y					; add the total length
.a264	a8		tay				tay 			 					; and make that the current position.
.a265	88		dey				dey 								; back one because of the initial skip
.a266	80 a3		bra $a20b			bra 	Execute
.a268					EXShiftTOSRight:
.a268	4a		lsr a				lsr 	a
.a269	7e 00 0f	ror $0f00,x			ror 	stack3,x
.a26c	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a26f	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a272	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a275	60		rts				rts
.a276					ExtractIntegerToTOS:
.a276	b1 00		lda ($00),y			lda 	(codePtr),y
.a278	c8		iny				iny
.a279	e8		inx				inx 								; make stack space
.a27a	29 3f		and #$3f			and 	#$3F 						; to start with, it's just that value
.a27c	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a27f	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a282	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a285	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a288					_EXConstantLoop:
.a288	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next ?
.a28a	29 c0		and #$c0			and 	#$C0 						; in range 80-FF e.g. 10xx xxxx
.a28c	c9 80		cmp #$80			cmp 	#$80
.a28e	d0 2d		bne $a2bd			bne		_EXDone 					; no then exit
.a290	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; put the MSB in A
.a293	48		pha				pha
.a294	bd 00 0e	lda $0e00,x			lda 	stack2,x 					; shift every byte up one, e.g. x 256
.a297	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a29a	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a29d	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a2a0	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a2a3	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a2a6	9e 00 0c	stz $0c00,x			stz 	stack0,x
.a2a9	68		pla				pla
.a2aa	20 68 a2	jsr $a268			jsr 	EXShiftTOSRight 				; shift the whole A:Top of Stack right twice
.a2ad	20 68 a2	jsr $a268			jsr 	EXShiftTOSRight				; which will be x64
.a2b0	b1 00		lda ($00),y			lda 	(codePtr),y 				; get and skip constant shift
.a2b2	c8		iny				iny
.a2b3	29 3f		and #$3f			and 	#$3F
.a2b5	1d 00 0c	ora $0c00,x			ora 	stack0,x 					; or into low byte
.a2b8	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a2bb	80 cb		bra $a288			bra 	_EXConstantLoop
.a2bd					_EXDone:
.a2bd	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/identifier.asm

.a2be					IdentifierSearch:
.a2be	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.a2c0	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a fast var ?
.a2c2	90 12		bcc $a2d6			bcc 	_ISSlow
.a2c4	c9 fa		cmp #$fa			cmp 	#$F9+1
.a2c6	b0 0e		bcs $a2d6			bcs 	_ISSlow
.a2c8	29 1f		and #$1f			and 	#$1F 						; index, then x 4
.a2ca	0a		asl a				asl 	a
.a2cb	0a		asl a				asl		a
.a2cc	85 12		sta $12				sta 	idDataAddr					; set up addres
.a2ce	a9 10		lda #$10			lda 	#AZVariables >> 8
.a2d0	85 13		sta $13				sta 	idDataAddr+1
.a2d2	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; type
.a2d4	38		sec				sec 								; return with CS.
.a2d5	60		rts				rts
.a2d6					_ISSlow:
.a2d6	20 8a a3	jsr $a38a			jsr 	IdentifierSetupHashPtr 		; set up hash table.
.a2d9	98		tya				tya 								; set (zTemp1) to point to the
.a2da	18		clc				clc 	 							; identifier to be searched.
.a2db	65 00		adc $00				adc 	codePtr
.a2dd	85 06		sta $06				sta 	zTemp1
.a2df	a5 01		lda $01				lda 	codePtr+1
.a2e1	69 00		adc #$00			adc 	#0
.a2e3	85 07		sta $07				sta 	zTemp1+1
.a2e5	5a		phy				phy 								; save Y
.a2e6	b2 04		lda ($04)	_ISLoop:lda 	(zTemp0)					; follow link
.a2e8	48		pha				pha
.a2e9	a0 01		ldy #$01			ldy 	#1
.a2eb	b1 04		lda ($04),y			lda 	(zTemp0),y
.a2ed	85 05		sta $05				sta 	zTemp0+1
.a2ef	68		pla				pla
.a2f0	85 04		sta $04				sta 	zTemp0
.a2f2	05 05		ora $05				ora 	zTemp0+1 					; if zero, then fail.
.a2f4	f0 2c		beq $a322			beq 	_ISFail
.a2f6	a0 06		ldy #$06			ldy 	#6 							; copy name into zTemp2
.a2f8	b1 04		lda ($04),y			lda 	(zTemp0),y
.a2fa	85 08		sta $08				sta 	zTemp2
.a2fc	c8		iny				iny
.a2fd	b1 04		lda ($04),y			lda 	(zTemp0),y
.a2ff	85 09		sta $09				sta 	zTemp2+1
.a301	a0 00		ldy #$00			ldy 	#0 							; compare names at zTemp1/zTemp2
.a303					_ISCompare:
.a303	b1 06		lda ($06),y			lda 	(zTemp1),y
.a305	d1 08		cmp ($08),y			cmp 	(zTemp2),y
.a307	d0 dd		bne $a2e6			bne		_ISLoop 					; different ?
.a309	c8		iny				iny
.a30a	c9 e0		cmp #$e0			cmp 	#$E0 						; until end identifiers matched.
.a30c	90 f5		bcc $a303			bcc 	_ISCompare
.a30e	18		clc				clc 								; set up the data pointer
.a30f	a5 04		lda $04				lda 	zTemp0
.a311	69 02		adc #$02			adc 	#2
.a313	85 12		sta $12				sta 	idDataAddr
.a315	a5 05		lda $05				lda 	zTemp0+1
.a317	69 00		adc #$00			adc		#0
.a319	85 13		sta $13				sta 	idDataAddr+1
.a31b	a0 09		ldy #$09			ldy 	#9 							; get the type
.a31d	b1 04		lda ($04),y			lda 	(zTemp0),y
.a31f	7a		ply				ply
.a320	38		sec				sec
.a321	60		rts				rts
.a322					_ISFail:
.a322	7a		ply				ply
.a323	18		clc				clc
.a324	60		rts				rts
.a325					IdentifierCreate:
.a325	5a		phy				phy 								; save Y
.a326	48		pha				pha 								; save type on stack
.a327	20 8a a3	jsr $a38a			jsr 	IdentifierSetUpHashPtr 		; zTemp0 = address of table.
.a32a	ad 88 10	lda $1088			lda 	VarMemory 					; copy VarMemory to zTemp1
.a32d	85 06		sta $06				sta 	zTemp1
.a32f	ad 89 10	lda $1089			lda 	VarMemory+1
.a332	85 07		sta $07				sta 	zTemp1+1
.a334	5a		phy				phy 								; save Y (code offset)
.a335	a0 00		ldy #$00			ldy 	#0 							; copy next link in.
.a337	b1 04		lda ($04),y			lda 	(zTemp0),y 					; +0,+1 is the link.
.a339	91 06		sta ($06),y			sta 	(zTemp1),y
.a33b	c8		iny				iny
.a33c	b1 04		lda ($04),y			lda 	(zTemp0),y
.a33e	91 06		sta ($06),y			sta 	(zTemp1),y
.a340	c8		iny				iny
.a341					_IDCErase:
.a341	a9 00		lda #$00			lda 	#0
.a343	91 06		sta ($06),y			sta 	(zTemp1),y
.a345	c8		iny				iny
.a346	c0 06		cpy #$06			cpy 	#6
.a348	d0 f7		bne $a341			bne 	_IDCErase
.a34a	68		pla				pla 								; original Y
.a34b	18		clc				clc
.a34c	65 00		adc $00				adc		codePtr 					; address of identifier +6,+7
.a34e	91 06		sta ($06),y			sta 	(zTemp1),y
.a350	c8		iny				iny
.a351	a5 01		lda $01				lda 	codePtr+1
.a353	69 00		adc #$00			adc 	#0
.a355	91 06		sta ($06),y			sta 	(zTemp1),y
.a357	c8		iny				iny
.a358	a9 00		lda #$00			lda 	#0 							; +8 bank (0)
.a35a	91 06		sta ($06),y			sta 	(zTemp1),y
.a35c	68		pla				pla 								; restore type
.a35d	c8		iny				iny
.a35e	91 06		sta ($06),y			sta 	(zTemp1),y 					; store at +9
.a360	c8		iny				iny
.a361	98		tya				tya									; add offset to VarMemory
.a362	18		clc				clc
.a363	6d 88 10	adc $1088			adc 	VarMemory
.a366	8d 88 10	sta $1088			sta 	VarMemory
.a369	ad 89 10	lda $1089			lda 	VarMemory+1
.a36c	69 00		adc #$00			adc 	#0
.a36e	8d 89 10	sta $1089			sta 	VarMemory+1
.a371	a5 06		lda $06				lda 	zTemp1 						; overwrite hash table entry
.a373	92 04		sta ($04)			sta 	(zTemp0)
.a375	a0 01		ldy #$01			ldy 	#1
.a377	a5 07		lda $07				lda 	zTemp1+1
.a379	91 04		sta ($04),y			sta 	(zTemp0),y
.a37b	a5 06		lda $06				lda 	zTemp1 						; set up idDataAddr
.a37d	18		clc				clc
.a37e	69 02		adc #$02			adc 	#2
.a380	85 12		sta $12				sta 	idDataAddr
.a382	a5 07		lda $07				lda 	zTemp1+1
.a384	69 00		adc #$00			adc 	#0
.a386	85 13		sta $13				sta 	idDataAddr+1
.a388	7a		ply				ply 								; restore Y and exit
.a389	60		rts				rts
.a38a					IdentifierSetUpHashPtr:
.a38a	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first operator
.a38c	29 0f		and #$0f			and 	#(HashTableSize-1)			; convert to a hash index
.a38e	0a		asl a				asl 	a 							; convert to an offset, clc
.a38f	69 68		adc #$68			adc 	#(HashTable & $FF)			; set zTemp0 to point to hashTable entry
.a391	85 04		sta $04				sta 	zTemp0
.a393	a9 10		lda #$10			lda 	#(HashTable >> 8) 			; assumes table in one page
.a395	85 05		sta $05				sta 	zTemp0+1
.a397	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/reset.asm

.a398					ResetCodePointer:
.a398	48		pha				pha
.a399	a9 11		lda #$11			lda 	#ProgramStart >> 8 			; set up line pointer
.a39b	85 01		sta $01				sta 	codePtr+1
.a39d	64 00		stz $00				stz 	codePtr
.a39f	a0 03		ldy #$03			ldy 	#3 							; point to first piece of code
.a3a1	68		pla				pla
.a3a2	60		rts				rts
.a3a3					ResetForRun:
.a3a3	48		pha				pha
.a3a4	5a		phy				phy
.a3a5	a2 00		ldx #$00			ldx 	#0 							; erase the hash table
.a3a7					_RRErase:
.a3a7	9e 68 10	stz $1068,x			stz		HashTable,x
.a3aa	e8		inx				inx
.a3ab	e0 20		cpx #$20			cpx 	#HashTableSize * 2
.a3ad	d0 f8		bne $a3a7			bne 	_RRErase
.a3af	20 98 a3	jsr $a398			jsr 	ResetCodePointer 			; code Pointer to start of program
.a3b2					_RRFindEnd:
.a3b2	b2 00		lda ($00)			lda 	(codePtr)					; at end ?
.a3b4	f0 0b		beq $a3c1			beq 	_RRFoundEnd
.a3b6	18		clc				clc 								; no, add offset to pointer.
.a3b7	65 00		adc $00				adc 	codePtr
.a3b9	85 00		sta $00				sta 	codePtr
.a3bb	90 f5		bcc $a3b2			bcc 	_RRFindEnd
.a3bd	e6 01		inc $01				inc 	codePtr+1
.a3bf	80 f1		bra $a3b2			bra 	_RRFindEnd
.a3c1					_RRFoundEnd:
.a3c1	18		clc				clc 								; add 1 to this, as it points to the last
.a3c2	a5 00		lda $00				lda 	codePtr 					; offset, and store in Variable Memory pointer
.a3c4	69 01		adc #$01			adc 	#1
.a3c6	8d 88 10	sta $1088			sta 	VarMemory
.a3c9	a5 01		lda $01				lda 	codePtr+1
.a3cb	69 00		adc #$00			adc 	#0
.a3cd	8d 89 10	sta $1089			sta 	VarMemory+1
.a3d0	a9 60		lda #$60			lda 	#MemoryEnd >> 8
.a3d2	8d 8b 10	sta $108b			sta 	AllocMemory+1
.a3d5	9c 8a 10	stz $108a			stz 	AllocMemory
.a3d8	a9 ff		lda #$ff			lda 	#StructureStack & $FF
.a3da	85 02		sta $02				sta 	StructSP
.a3dc	a9 0b		lda #$0b			lda 	#StructureStack >> 8
.a3de	85 03		sta $03				sta 	StructSP+1
.a3e0	a9 ff		lda #$ff			lda 	#$FF 						; put a value that will fail structure tests
.a3e2	92 02		sta ($02)			sta 	(StructSP)
.a3e4	20 ec a3	jsr $a3ec			jsr 	ProcedureScan
.a3e7	a2 00		ldx #$00			ldx 	#0 							; empty the stack
.a3e9	7a		ply				ply
.a3ea	68		pla				pla
.a3eb	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/scan.asm

.a3ec					ProcedureScan:
.a3ec	20 98 a3	jsr $a398			jsr 	ResetCodePointer 			; reset the code pointer.
.a3ef	b2 00		lda ($00)	_PSMain:lda 	(codePtr)					; check if end
.a3f1	f0 3c		beq $a42f			beq 	_PSExit
.a3f3	a0 03		ldy #$03			ldy 	#3 							; start of line
.a3f5					_PSSkipSpace:
.a3f5	b1 00		lda ($00),y			lda 	(codePtr),y 				; skip over spaces
.a3f7	c8		iny				iny
.a3f8	c9 10		cmp #$10			cmp 	#KWD_SPACE
.a3fa	f0 f9		beq $a3f5			beq 	_PSSkipSpace
.a3fc	c9 29		cmp #$29			cmp 	#KWD_DEF 					; first thing is DEF ?
.a3fe	d0 22		bne $a422			bne 	_PSNext
.a400					_PSSkipSpace2:
.a400	c8		iny				iny 								; skip over def first, any following spaces
.a401	b1 00		lda ($00),y			lda 	(codePtr),y
.a403	c9 10		cmp #$10			cmp 	#KWD_SPACE
.a405	f0 f9		beq $a400			beq 	_PSSkipSpace2
.a407	a9 50		lda #$50			lda 	#IDT_PROCEDURE 				; create a procedure
.a409	20 25 a3	jsr $a325			jsr 	IdentifierCreate
.a40c					_PSSkipIdentifier:
.a40c	b1 00		lda ($00),y			lda 	(codePtr),y
.a40e	c8		iny				iny
.a40f	c9 c0		cmp #$c0			cmp 	#$C0
.a411	b0 f9		bcs $a40c			bcs 	_PSSkipIdentifier
.a413	88		dey				dey 								; undo last, points at first non ID
.a414	98		tya				tya  								; save the address in the data slot.
.a415	18		clc				clc 								; changing Y doesn't matter.
.a416	65 00		adc $00				adc 	codePtr
.a418	92 12		sta ($12)			sta 	(idDataAddr)
.a41a	a5 01		lda $01				lda 	codePtr+1
.a41c	69 00		adc #$00			adc 	#0
.a41e	a0 01		ldy #$01			ldy 	#1
.a420	91 12		sta ($12),y			sta 	(idDataAddr),y
.a422					_PSNext:
.a422	18		clc				clc 								; go to next
.a423	b2 00		lda ($00)			lda 	(codePtr)
.a425	65 00		adc $00				adc 	codePtr
.a427	85 00		sta $00				sta 	codeptr
.a429	90 c4		bcc $a3ef			bcc 	_PSMain
.a42b	e6 01		inc $01				inc 	codePtr+1
.a42d	80 c0		bra $a3ef			bra 	_PSMain
.a42f					_PSExit:
.a42f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/indexing.asm

.a430					IndexCheck:
.a430	b1 00		lda ($00),y			lda 	(codePtr),y 				; check next character
.a432	c9 49		cmp #$49			cmp 	#KWD_LSQPARENRSQPAREN 		; left/right square bracket ?
.a434	f0 12		beq $a448			beq 	_ICArrayAccess
.a436	29 c0		and #$c0			and 	#$C0 						; constant (e.g. 10xx xxxx)
.a438	c9 80		cmp #$80			cmp 	#$80
.a43a	b0 01		bcs $a43d			bcs 	_ICSubscript
.a43c					_ICExit:
.a43c	60		rts				rts
.a43d					_ICSubscript:
.a43d	b1 00		lda ($00),y			lda 	(codePtr),y
.a43f	c8		iny				iny 								; skip over subscript
.a440	29 3f		and #$3f			and 	#$3F 						; lower 6 bits only.
.a442	85 06		sta $06				sta 	zTemp1 						; save in zTemp1
.a444	64 07		stz $07				stz 	zTemp1+1
.a446	80 0c		bra $a454			bra 	_ICAddSubscript 			; double and add to value.
.a448					_ICArrayAccess:
.a448	c8		iny				iny 								; point to next
.a449	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy TOS to zTemp1
.a44c	85 07		sta $07				sta 	zTemp1+1 					; no point in the rest !
.a44e	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a451	85 06		sta $06				sta 	zTemp1
.a453	ca		dex				dex
.a454					_ICAddSubscript:
.a454	06 06		asl $06				asl 	zTemp1 						; subscript x 4
.a456	26 07		rol $07				rol 	zTemp1+1
.a458	06 06		asl $06				asl 	zTemp1
.a45a	26 07		rol $07				rol 	zTemp1+1
.a45c	5a		phy				phy
.a45d	b2 12		lda ($12)			lda 	(idDataAddr)				; check indirecting through 0
.a45f	a0 01		ldy #$01			ldy 	#1
.a461	11 12		ora ($12),y			ora 	(idDataAddr),y 				; probably means uninitialised
.a463	c8		iny				iny
.a464	11 12		ora ($12),y			ora 	(idDataAddr),y
.a466	c8		iny				iny
.a467	11 12		ora ($12),y			ora 	(idDataAddr),y
.a469	f0 17		beq $a482			beq 	_ICZero
.a46b	18		clc				clc									; add zTemp1 to value at (idDataAddr)
.a46c	b2 12		lda ($12)			lda 	(idDataAddr)
.a46e	65 06		adc $06				adc 	zTemp1
.a470	48		pha				pha
.a471	a0 01		ldy #$01			ldy 	#1
.a473	b1 12		lda ($12),y			lda 	(idDataAddr),y
.a475	65 07		adc $07				adc 	zTemp1+1
.a477	85 13		sta $13				sta 	idDataAddr+1 				; write it out
.a479	68		pla				pla
.a47a	85 12		sta $12				sta 	idDataAddr
.a47c	64 14		stz $14				stz 	idDataAddr+2 				; extend to 32 bits
.a47e	64 15		stz $15				stz 	idDataAddr+3
.a480	7a		ply				ply
.a481	60		rts				rts
.a482					_ICZero:
.a482	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>a485	55 4e 49 4e 49 54 49 41				.text 	"UNINITIALISED ARRAY",0
>a48d	4c 49 53 45 44 20 41 52 52 41 59 00

;******  Return to file: main.asm


;******  Processing file: system/error.asm

.a499					SyntaxError:
.a499	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>a49c	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>a4a4	52 52 4f 52 00
.a4a9					ErrorHandler:
.a4a9	68		pla				pla 								; pop message address
.a4aa	85 04		sta $04				sta 	zTemp0
.a4ac	68		pla				pla
.a4ad	85 05		sta $05				sta 	zTemp0+1
.a4af	a9 05		lda #$05			lda 	#CTH_ERROR
.a4b1	20 e1 a1	jsr $a1e1			jsr 	ExternColour
.a4b4	a0 01		ldy #$01			ldy 	#1 							; print it
.a4b6					_ErrorPrint:
.a4b6	b1 04		lda ($04),y			lda 	(zTemp0),y
.a4b8	20 d7 a1	jsr $a1d7			jsr		ExternPrint
.a4bb	c8		iny				iny
.a4bc	b1 04		lda ($04),y			lda 	(zTemp0),y
.a4be	d0 f6		bne $a4b6			bne 	_ErrorPrint
.a4c0	a0 01		ldy #$01			ldy 	#1 							; check if line# 0
.a4c2	b1 00		lda ($00),y			lda		(codePtr),y
.a4c4	c8		iny				iny
.a4c5	12 00		ora ($00)			ora 	(codePtr)
.a4c7	f0 1c		beq $a4e5			beq 	_ErrorNoLine 				; if so, skip
.a4c9	a9 20		lda #$20			lda 	#32
.a4cb	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a4ce	a9 40		lda #$40			lda 	#'@'
.a4d0	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a4d3	a9 20		lda #$20			lda 	#32
.a4d5	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a4d8	a0 01		ldy #$01			ldy 	#1 							; load current line into YA
.a4da	b1 00		lda ($00),y			lda 	(codePtr),y
.a4dc	48		pha				pha
.a4dd	c8		iny				iny
.a4de	b1 00		lda ($00),y			lda 	(codePtr),y
.a4e0	a8		tay				tay
.a4e1	68		pla				pla
.a4e2	20 f6 a4	jsr $a4f6			jsr 	ErrorPrint16 				; print YA as unsigned 16 bit integer.
.a4e5					_ErrorNoLine:
.a4e5	a9 0d		lda #$0d			lda 	#13							; new line
.a4e7	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a4ea	4c ed a4	jmp $a4ed			jmp 	WarmStart
.a4ed					WarmStart:
.a4ed	a9 07		lda #$07			lda 	#COL_WHITE
.a4ef	20 e1 a1	jsr $a1e1			jsr 	ExternColour
.a4f2	4c ed a4	jmp $a4ed			jmp		WarmStart
>a4f5	ff						.byte 	$FF
.a4f6					ErrorPrint16:
.a4f6	da		phx				phx
.a4f7	e8		inx				inx 								; space on stack
.a4f8	9d 00 0c	sta $0c00,x			sta 	stack0,x					; save on TOS
.a4fb	98		tya				tya
.a4fc	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a4ff	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a502	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a505	20 1b a5	jsr $a51b			jsr 	IntegerToString 			; convert to string.
.a508	fa		plx				plx
.a509					ErrorPrintIntegerBuffer:
.a509	da		phx				phx
.a50a	a2 00		ldx #$00			ldx 	#0
.a50c					_EP16Loop:
.a50c	bd 00 0a	lda $0a00,x			lda 	SBuffer,x
.a50f	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a512	e8		inx				inx
.a513	bd 00 0a	lda $0a00,x			lda 	SBuffer,x
.a516	d0 f4		bne $a50c			bne 	_EP16Loop
.a518	8a		txa				txa
.a519	fa		plx				plx
.a51a	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/inttostr.asm

.a51b					IntegerToString:
.a51b	48		pha				pha
.a51c	5a		phy				phy
.a51d	bd 00 0f	lda $0f00,x			lda 		stack3,x 				; check -ve
.a520	10 08		bpl $a52a			bpl 		_ITSNotMinus
.a522	a9 2d		lda #$2d			lda 		#"-"
.a524	20 bc a5	jsr $a5bc			jsr 		ITSOutputCharacter
.a527	20 7d a8	jsr $a87d			jsr 		Unary_Negate
.a52a					_ITSNotMinus:
.a52a	9c 20 0a	stz $0a20			stz 		SBPosition 				; reset string buffer position
.a52d	9c 24 0a	stz $0a24			stz 		NumSuppress 			; clear zero suppression flag
.a530	8a		txa				txa 								; use Y for the integer index.
.a531	a8		tay				tay
.a532	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.a534					_ITSNextSubtractor:
.a534	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.a536	8d 21 0a	sta $0a21			sta 		NumConvCount
.a539					_ITSSubtract:
.a539	38		sec				sec
.a53a	b9 00 0c	lda $0c00,y			lda 		stack0,y 			; subtract number and push on stack
.a53d	fd 98 a5	sbc $a598,x			sbc 		_ITSSubtractors+0,x 	; only update if actually can subtract it.
.a540	48		pha				pha
.a541	b9 00 0d	lda $0d00,y			lda 		stack1,y
.a544	fd 99 a5	sbc $a599,x			sbc 		_ITSSubtractors+1,x
.a547	48		pha				pha
.a548	b9 00 0e	lda $0e00,y			lda 		stack2,y
.a54b	fd 9a a5	sbc $a59a,x			sbc 		_ITSSubtractors+2,x
.a54e	48		pha				pha
.a54f	b9 00 0f	lda $0f00,y			lda 		stack3,y
.a552	fd 9b a5	sbc $a59b,x			sbc 		_ITSSubtractors+3,x
.a555	90 14		bcc $a56b			bcc 		_ITSCantSubtract 		; if CC, then gone too far, can't subtract
.a557	99 00 0f	sta $0f00,y			sta 		stack3,y 		; save subtract off stack as it's okay
.a55a	68		pla				pla
.a55b	99 00 0e	sta $0e00,y			sta 		stack2,y
.a55e	68		pla				pla
.a55f	99 00 0d	sta $0d00,y			sta 		stack1,y
.a562	68		pla				pla
.a563	99 00 0c	sta $0c00,y			sta 		stack0,y
.a566	ee 21 0a	inc $0a21			inc 		NumConvCount 			; bump count.
.a569	80 ce		bra $a539			bra 		_ITSSubtract 			; go round again.
.a56b					_ITSCantSubtract:
.a56b	68		pla				pla 								; throw away interim answers
.a56c	68		pla				pla 								; (the subtraction that failed)
.a56d	68		pla				pla
.a56e	ad 21 0a	lda $0a21			lda 		NumConvCount 			; if not zero then no suppression check
.a571	c9 30		cmp #$30			cmp 		#"0"
.a573	d0 05		bne $a57a			bne 		_ITSOutputDigit
.a575	ad 24 0a	lda $0a24			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.a578	f0 09		beq $a583			beq	 		_ITSGoNextSubtractor
.a57a					_ITSOutputDigit:
.a57a	ce 24 0a	dec $0a24			dec 		NumSuppress 			; suppression check will be non-zero from now on.
.a57d	ad 21 0a	lda $0a21			lda 		NumConvCount 			; count of subtractions
.a580	20 bc a5	jsr $a5bc			jsr 		ITSOutputCharacter 		; output it.
.a583					_ITSGoNextSubtractor:
.a583	e8		inx				inx 								; next dword in subtractor table.
.a584	e8		inx				inx
.a585	e8		inx				inx
.a586	e8		inx				inx
.a587	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.a589	d0 a9		bne $a534			bne 		_ITSNextSubtractor 		; do all the subtractors.
.a58b	98		tya				tya 								; X is back as the mantissa index
.a58c	aa		tax				tax
.a58d	bd 00 0c	lda $0c00,x			lda 		stack0,x 		; and the last digit is left.
.a590	09 30		ora #$30			ora 		#"0"
.a592	20 bc a5	jsr $a5bc			jsr 		ITSOutputCharacter
.a595	7a		ply				ply 								; and exit
.a596	68		pla				pla
.a597	60		rts				rts
.a598					_ITSSubtractors:
>a598	00 ca 9a 3b					.dword 		1000000000
>a59c	00 e1 f5 05					.dword 		100000000
>a5a0	80 96 98 00					.dword 		10000000
>a5a4	40 42 0f 00					.dword 		1000000
>a5a8	a0 86 01 00					.dword 		100000
>a5ac	10 27 00 00					.dword 		10000
>a5b0	e8 03 00 00					.dword 		1000
>a5b4	64 00 00 00					.dword 		100
>a5b8	0a 00 00 00					.dword 		10
.a5bc					_ITSSubtractorsEnd:
.a5bc					ITSOutputCharacter:
.a5bc	48		pha				pha
.a5bd	da		phx				phx
.a5be	ae 20 0a	ldx $0a20			ldx 	SBPosition 					; save digit
.a5c1	9d 00 0a	sta $0a00,x			sta 	SBuffer,x
.a5c4	9e 01 0a	stz $0a01,x			stz 	SBuffer+1,x
.a5c7	ee 20 0a	inc $0a20			inc 	SBPosition					; bump pointer.
.a5ca	fa		plx				plx
.a5cb	68		pla				pla
.a5cc	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/intfromstr.asm

.a5cd					IntFromString:
.a5cd	a0 00		ldy #$00			ldy 	#0 							; from (zTemp0)
.a5cf	e8		inx				inx 								; space on stack
.a5d0	20 03 a6	jsr $a603			jsr 	IFSClearTOS
.a5d3					_IFSLoop:
.a5d3	b1 04		lda ($04),y			lda 	(zTemp0),y 					; get next
.a5d5	c9 30		cmp #$30			cmp 	#"0"						; validate it as range 0-9
.a5d7	90 24		bcc $a5fd			bcc 	_IFSExit
.a5d9	c9 3a		cmp #$3a			cmp 	#"9"+1
.a5db	b0 20		bcs $a5fd			bcs 	_IFSExit
.a5dd	20 ee a7	jsr $a7ee			jsr 	Stack_Dup 					; duplicate tos
.a5e0	20 f5 a8	jsr $a8f5			jsr 	Unary_Shl	 				; x 2
.a5e3	20 f5 a8	jsr $a8f5			jsr 	Unary_Shl 					; x 4
.a5e6	20 c0 a9	jsr $a9c0			jsr 	Stack_Add 					; x 5
.a5e9	20 f5 a8	jsr $a8f5			jsr 	Unary_Shl 					; x 10
.a5ec	e8		inx				inx  								; create space next up
.a5ed	20 03 a6	jsr $a603			jsr 	IFSClearTOS
.a5f0	b1 04		lda ($04),y			lda 	(zTemp0),y 					; add digit
.a5f2	29 0f		and #$0f			and 	#15
.a5f4	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; tos is new add
.a5f7	20 c0 a9	jsr $a9c0			jsr 	Stack_Add 					; add to tos
.a5fa	c8		iny				iny
.a5fb	80 d6		bra $a5d3			bra 	_IFSLoop
.a5fd					_IFSExit:
.a5fd	98		tya				tya
.a5fe	38		sec				sec
.a5ff	f0 01		beq $a602			beq 	_IFSSkipFail
.a601	18		clc				clc
.a602					_IFSSkipFail:
.a602	60		rts				rts
.a603					IFSClearTOS:
.a603	9e 00 0c	stz $0c00,x			stz		stack0,x
.a606	9e 00 0d	stz $0d00,x			stz		stack1,x
.a609	9e 00 0e	stz $0e00,x			stz		stack2,x
.a60c	9e 00 0f	stz $0f00,x			stz		stack3,x
.a60f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/list.asm

.a610					Cmd_List:
.a610	20 98 a3	jsr $a398			jsr 	ResetCodePointer 			; back to the beginning
.a613	64 08		stz $08				stz 	zTemp2						; clear the lowest-number
.a615	64 09		stz $09				stz 	zTemp2+1
.a617	e0 00		cpx #$00			cpx 	#0 							; stack empty ?
.a619	f0 0b		beq $a626			beq 	_CLINone
.a61b	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; use tos as start line
.a61e	85 08		sta $08				sta 	zTemp2
.a620	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a623	95 09		sta $09,x			sta 	zTemp2+1,x
.a625	ca		dex				dex 								; and pop the tos
.a626					_CLINone:
.a626	a9 10		lda #$10			lda 	#16 						; list this many lines
.a628	85 06		sta $06				sta 	zTemp1
.a62a					_CLILoop
.a62a	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.a62c	f0 24		beq $a652			beq 	_CLIEnd
.a62e	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.a630	38		sec				sec
.a631	b1 00		lda ($00),y			lda 	(codePtr),y
.a633	e5 08		sbc $08				sbc 	zTemp2
.a635	c8		iny				iny
.a636	b1 00		lda ($00),y			lda 	(codePtr),y
.a638	e5 09		sbc $09				sbc 	zTemp2+1
.a63a	90 09		bcc $a645			bcc 	_CLISkip
.a63c	da		phx				phx
.a63d	20 55 a6	jsr $a655			jsr 	ListCurrent 				; list the line.
.a640	fa		plx				plx
.a641	c6 06		dec $06				dec 	zTemp1 						; done all lines
.a643	f0 0d		beq $a652			beq 	_CLIEnd
.a645					_CLISkip:
.a645	18		clc				clc
.a646	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.a648	65 00		adc $00				adc 	codePtr
.a64a	85 00		sta $00				sta 	codePtr
.a64c	90 dc		bcc $a62a			bcc 	_CLILoop
.a64e	e6 01		inc $01				inc 	codePtr+1
.a650	80 d8		bra $a62a			bra 	_CLILoop
.a652					_CLIEnd:
.a652	4c ed a4	jmp $a4ed			jmp 	WarmStart
.a655					ListCurrent:
.a655	a9 06		lda #$06			lda 	#CTH_NUMBER
.a657	20 e1 a1	jsr $a1e1			jsr 	ExternColour 				; set colour
.a65a	a0 01		ldy #$01			ldy 	#1							; print line#
.a65c	b1 00		lda ($00),y			lda 	(codePtr),y
.a65e	48		pha				pha
.a65f	c8		iny				iny
.a660	b1 00		lda ($00),y			lda 	(codePtr),y
.a662	a8		tay				tay
.a663	68		pla				pla
.a664	20 f6 a4	jsr $a4f6			jsr 	ErrorPrint16
.a667	a8		tay				tay
.a668					_LCPadOut:
.a668	a9 20		lda #$20			lda 	#' '
.a66a	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a66d	c8		iny				iny
.a66e	c0 06		cpy #$06			cpy 	#6
.a670	d0 f6		bne $a668			bne 	_LCPadOut
.a672	a0 03		ldy #$03			ldy 	#3 							; start here
.a674	b1 00		lda ($00),y	_LCLoop:lda 	(codePtr),y 				; get first
.a676	30 38		bmi $a6b0			bmi 	_LCIdentConst 				; identifier or constant
.a678	d0 05		bne $a67f			bne 	_LCStringToken
.a67a	a9 0d		lda #$0d			lda 	#13
.a67c	4c d7 a1	jmp $a1d7			jmp 	ExternPrint
.a67f					_LCStringToken:
.a67f	c9 10		cmp #$10			cmp 	#$10 						; if < 10 it's a string.
.a681	90 06		bcc $a689			bcc		_LCString
.a683	20 de a6	jsr $a6de			jsr 	ListPrintToken
.a686	c8		iny				iny 								; advance pointer
.a687	80 eb		bra $a674			bra 	_LCLoop 					; go round again.
.a689					_LCString:
.a689	4a		lsr a				lsr 	a 							; CS if 1 (string) CC if 2 (comment)
.a68a	a9 05		lda #$05			lda 	#CTH_STRING 				; decide on colour.
.a68c	a2 22		ldx #$22			ldx 	#'"'
.a68e	b0 04		bcs $a694			bcs 	_LCSSkip
.a690	a9 07		lda #$07			lda 	#CTH_COMMENT
.a692	a2 27		ldx #$27			ldx 	#"'"
.a694					_LCSSkip:
.a694	20 e1 a1	jsr $a1e1			jsr 	ExternColour 				; set colour
.a697	8a		txa				txa
.a698	48		pha				pha 								; save end quote on stack.
.a699	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a69c	c8		iny				iny 								; skip type size
.a69d	c8		iny				iny
.a69e					_LCSPrint:
.a69e	b1 00		lda ($00),y			lda 	(codePtr),y
.a6a0	c8		iny				iny
.a6a1	c9 00		cmp #$00			cmp 	#0 							; 0 is end
.a6a3	f0 05		beq $a6aa			beq 	_LCSExit
.a6a5	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a6a8	80 f4		bra $a69e			bra 	_LCSPrint
.a6aa					_LCSExit:
.a6aa	68		pla				pla
.a6ab	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a6ae	80 c4		bra $a674			bra 	_LCLoop
.a6b0					_LCIdentConst:
.a6b0	c9 c0		cmp #$c0			cmp 	#$C0						; check if constant
.a6b2	90 18		bcc $a6cc			bcc 	_LCConstant
.a6b4	a9 03		lda #$03			lda 	#CTH_IDENT 					; set colour
.a6b6	20 e1 a1	jsr $a1e1			jsr 	ExternColour
.a6b9	b1 00		lda ($00),y			lda 	(codePtr),y 				; read
.a6bb	c8		iny				iny
.a6bc	29 1f		and #$1f			and 	#$1F 						; convert
.a6be	18		clc				clc
.a6bf	69 41		adc #$41			adc 	#'A'
.a6c1	c9 60		cmp #$60			cmp 	#'A'+31 					; handle '.'
.a6c3	d0 02		bne $a6c7			bne 	_LCCNotDot
.a6c5	a9 2e		lda #$2e			lda 	#'.'
.a6c7					_LCCNotDot:
.a6c7	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a6ca	80 a8		bra $a674			bra 	_LCLoop
.a6cc					_LCConstant:
.a6cc	a9 06		lda #$06			lda 	#CTH_NUMBER 				; number colour
.a6ce	20 e1 a1	jsr $a1e1			jsr 	ExternColour
.a6d1	a2 fe		ldx #$fe			ldx 	#254 						; use the topmost stack element
.a6d3	20 76 a2	jsr $a276			jsr 	ExtractIntegerToTOS 		; so there is a very rare case
.a6d6	20 1b a5	jsr $a51b			jsr 	IntegerToString 			; this could corrupt stack if full :)
.a6d9	20 09 a5	jsr $a509			jsr 	ErrorPrintIntegerBuffer
.a6dc	80 96		bra $a674			bra 	_LCLoop
.a6de					ListPrintToken:
.a6de	5a		phy				phy
.a6df	48		pha				pha 								; token colour
.a6e0	a9 02		lda #$02			lda 	#CTH_TOKEN
.a6e2	20 e1 a1	jsr $a1e1			jsr 	ExternColour
.a6e5	fa		plx				plx
.a6e6	a9 5b		lda #$5b			lda 	#KeywordText & $FF
.a6e8	85 04		sta $04				sta 	zTemp0
.a6ea	a9 a0		lda #$a0			lda 	#KeywordText >> 8
.a6ec	85 05		sta $05				sta 	zTemp0+1
.a6ee					_LPTLoop:
.a6ee	e0 10		cpx #$10			cpx 	#$10 						; first token is $10
.a6f0	f0 0e		beq $a700			beq 	_LPTFound
.a6f2	ca		dex				dex
.a6f3	b2 04		lda ($04)			lda 	(zTemp0)
.a6f5	38		sec				sec									; add 1, it's length+name
.a6f6	65 04		adc $04				adc 	zTemp0
.a6f8	85 04		sta $04				sta 	zTemp0
.a6fa	90 f2		bcc $a6ee			bcc 	_LPTLoop
.a6fc	e6 05		inc $05				inc 	zTemp0+1
.a6fe	80 ee		bra $a6ee			bra 	_LPTLoop
.a700					_LPTFound:
.a700	a0 01		ldy #$01			ldy 	#1 							; start here.
.a702					_LPTShow:
.a702	b1 04		lda ($04),y			lda 	(zTemp0),y 					; get character
.a704	c9 20		cmp #$20			cmp 	#32 						; < 32, length, so exit
.a706	90 06		bcc $a70e			bcc 	_LPTExit
.a708	c8		iny				iny
.a709	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.a70c	80 f4		bra $a702			bra 	_LPTShow
.a70e					_LPTExit:
.a70e	7a		ply				ply
.a70f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/tokeniser.asm

.a710	64 06		stz $06		TTest:	stz 	zTemp1
.a712	a9 0b		lda #$0b			lda 	#$0B
.a714	85 07		sta $07				sta		zTemp1+1
.a716	a9 23		lda #$23			lda 	#Test & 255
.a718	85 00		sta $00				sta 	codePtr
.a71a	a9 a7		lda #$a7			lda 	#Test >> 8
.a71c	85 01		sta $01				sta 	codePtr+1
.a71e	20 30 a7	jsr $a730			jsr 	Tokenise
.a721	80 fe		bra $a721	h1:		bra 	h1
>a723	20 35 31 37 20 52 45 50		Test:	.text 	" 517 REPEATX"
>a72b	45 41 54 58
>a72f	00						.byte 	0
.a730					Tokenise:
.a730	a0 00		ldy #$00			ldy 	#0
.a732	b1 00		lda ($00),y	_TKSkip:lda 	(codePtr),y 				; get next
.a734	f0 0a		beq $a740			beq 	_TKExit 					; exit if zero.
.a736	c8		iny				iny
.a737	c9 20		cmp #$20			cmp 	#" "
.a739	f0 f7		beq $a732			beq 	_TKSkip 					; skip leading spaces.
.a73b	88		dey				dey
.a73c					_TKMainLoop:
.a73c	b1 00		lda ($00),y			lda 	(codePtr),y 				; get and check end.
.a73e	d0 03		bne $a743			bne 	_TKNotEnd
.a740	92 06		sta ($06)	_TKExit:sta 	(zTemp1) 					; and ending $00
.a742	60		rts				rts
.a743					_TKNotEnd:
.a743	c9 20		cmp #$20			cmp 	#" " 						; is it space ?
.a745	d0 07		bne $a74e			bne 	_TKNotSpace
.a747	a9 10		lda #$10			lda 	#KWD_SPACE 					; write space token
.a749	20 b8 a7	jsr $a7b8			jsr 	TokWriteToken
.a74c	80 e4		bra $a732			bra 	_TKSkip 					; skip multiple spaces.
.a74e					_TKNotSpace:
.a74e	98		tya				tya 								; current pos -> zTemp0
.a74f	18		clc				clc
.a750	65 00		adc $00				adc 	codePtr
.a752	85 04		sta $04				sta 	zTemp0
.a754	85 00		sta $00				sta 	codePtr
.a756	a5 01		lda $01				lda 	codePtr+1
.a758	69 00		adc #$00			adc 	#0
.a75a	85 05		sta $05				sta 	zTemp0+1
.a75c	85 01		sta $01				sta 	codePtr+1
.a75e	a0 00		ldy #$00			ldy 	#0 							; reset.
.a760	b1 00		lda ($00),y			lda 	(codePtr),y
.a762	c9 30		cmp #$30			cmp 	#"0"						; check for decimal.
.a764	90 10		bcc $a776			bcc 	_TKNotNumber
.a766	c9 3a		cmp #$3a			cmp 	#"9"+1
.a768	b0 0c		bcs $a776			bcs 	_TKNotNumber
.a76a	e8		inx				inx
.a76b	20 cd a5	jsr $a5cd			jsr 	IntFromString 				; convert to integer
.a76e	48		pha				pha
.a76f	20 c1 a7	jsr $a7c1			jsr 	TokWriteConstant 			; do constant recursively.
.a772	7a		ply				ply
.a773	ca		dex				dex
.a774	80 c6		bra $a73c			bra 	_TKMainLoop 				; loop back.
.a776					_TKNotNumber:
.a776	a9 5b		lda #$5b			lda 	#KeywordText & $FF 			; zTemp2 -> token table
.a778	85 08		sta $08				sta 	zTemp2
.a77a	a9 a0		lda #$a0			lda 	#KeywordText >> 8
.a77c	85 09		sta $09				sta 	zTemp2+1
.a77e	64 0a		stz $0a				stz 	zTemp3 						; clear 'best'
.a780	a9 10		lda #$10			lda 	#$10
.a782	85 0b		sta $0b				sta 	zTemp3+1 					; set current token
.a784					_TKSearch:
.a784	a0 00		ldy #$00			ldy 	#0
.a786					_TKCompare:
.a786	b1 00		lda ($00),y			lda 	(codePtr),y 	 			; get char from buffer
.a788	c8		iny				iny
.a789	d1 08		cmp ($08),y			cmp 	(zTemp2),y 					; does it match.
.a78b	d0 07		bne $a794			bne 	_TKNext
.a78d	98		tya				tya
.a78e	d2 08		cmp ($08)			cmp 	(zTemp2) 					; Y = length
.a790	d0 f4		bne $a786			bne 	_TKCompare 					; found a match.
.a792	80 13		bra $a7a7			bra 	_TKFound
.a794	b2 08		lda ($08)	_TKNext:lda 	(zTemp2)					; get length
.a796	38		sec				sec 								; add length+1 to current
.a797	65 08		adc $08				adc 	zTemp2
.a799	85 08		sta $08				sta 	zTemp2
.a79b	90 02		bcc $a79f			bcc 	_TKNNC
.a79d	e6 09		inc $09				inc 	zTemp2+1
.a79f	e6 0b		inc $0b		_TKNNC:	inc 	zTemp3+1 					; increment current token
.a7a1	b2 08		lda ($08)			lda 	(zTemp2) 					; reached then end
.a7a3	d0 df		bne $a784			bne 	_TKSearch 					; go try again.
.a7a5	80 0d		bra $a7b4			bra 	_TKComplete
.a7a7					_TKFound:
.a7a7	98		tya				tya
.a7a8	c5 0a		cmp $0a				cmp 	zTemp3 						; check best
.a7aa	90 e8		bcc $a794			bcc 	_TKNext 					; if < best try next
.a7ac	85 0a		sta $0a				sta 	zTemp3 						; update best
.a7ae	a5 0b		lda $0b				lda 	zTemp3+1 					; save current token.
.a7b0	85 0c		sta $0c				sta 	zTemp4
.a7b2	80 e0		bra $a794			bra 	_TKNext
.a7b4					_TKComplete:
>a7b4	ff						.byte 	$FF
>a7b5	ff						.byte 	$FF
.a7b6	a5 0a		lda $0a				lda 	zTemp3 						; get "best score"
.a7b8					TokWriteToken:
.a7b8	92 06		sta ($06)			sta 	(zTemp1)
.a7ba	e6 06		inc $06				inc 	zTemp1
.a7bc	d0 02		bne $a7c0			bne 	_TWTExit
.a7be	e6 07		inc $07				inc 	zTemp1+1
.a7c0					_TWTExit:
.a7c0	60		rts				rts
.a7c1					TokWriteConstant:
.a7c1	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; get current
.a7c4	29 3f		and #$3f			and		#63
.a7c6	48		pha				pha 								; save on stack
.a7c7	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check if < 64
.a7ca	29 c0		and #$c0			and 	#$C0
.a7cc	1d 00 0d	ora $0d00,x			ora 	stack1,x
.a7cf	1d 00 0e	ora $0e00,x			ora 	stack2,x
.a7d2	1d 00 0f	ora $0f00,x			ora 	stack3,x
.a7d5	f0 0d		beq $a7e4			beq 	_TWCNoCall 					; no, don't call.
.a7d7	5a		phy				phy
.a7d8	a0 06		ldy #$06			ldy 	#6
.a7da					_TWCShift:
.a7da	20 02 a9	jsr $a902			jsr 	Unary_Shr
.a7dd	88		dey				dey
.a7de	d0 fa		bne $a7da			bne 	_TWCShift
.a7e0	7a		ply				ply
.a7e1	20 c1 a7	jsr $a7c1			jsr 	TokWriteConstant
.a7e4					_TWCNoCall:
.a7e4	68		pla				pla
.a7e5	09 80		ora #$80			ora 	#$80						; make digit token
.a7e7	80 cf		bra $a7b8			bra 	TokWriteToken 				; and write it out.

;******  Return to file: main.asm


;******  Processing file: functions/stack.asm

.a7e9					Stack_Empty:
.a7e9	a2 00		ldx #$00			ldx 	#0
.a7eb	60		rts				rts
.a7ec					Stack_Drop:
.a7ec	ca		dex				dex
.a7ed	60		rts				rts
.a7ee					Stack_Dup:
.a7ee	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy to next up
.a7f1	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.a7f4	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a7f7	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.a7fa	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a7fd	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.a800	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a803	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.a806	e8		inx				inx 								; bump stack pointer
.a807	60		rts				rts
.a808					Stack_Nip:
.a808	bd 00 0c	lda $0c00,x			lda 	stack0,x	 				; copy top to 2nd
.a80b	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.a80e	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a811	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.a814	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a817	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.a81a	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a81d	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.a820	ca		dex				dex 								; drop tos
.a821	60		rts				rts
.a822					Stack_Over:
.a822	bd ff 0b	lda $0bff,x			lda 	stack0-1,x				; copy to next up
.a825	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.a828	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a82b	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.a82e	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a831	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.a834	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a837	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.a83a	e8		inx				inx 							; bump stack pointer
.a83b	60		rts				rts
.a83c					Stack_Swap:
.a83c	5a		phy				phy
.a83d	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a840	a8		tay				tay
.a841	bd ff 0b	lda $0bff,x			lda 	stack0-1,x
.a844	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a847	98		tya				tya
.a848	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.a84b	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a84e	a8		tay				tay
.a84f	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a852	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a855	98		tya				tya
.a856	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.a859	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a85c	a8		tay				tay
.a85d	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a860	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a863	98		tya				tya
.a864	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.a867	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a86a	a8		tay				tay
.a86b	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a86e	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a871	98		tya				tya
.a872	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.a875	7a		ply				ply
.a876	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/unary.asm

.a877					Unary_Absolute:
.a877	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a87a	30 01		bmi $a87d			bmi 	Unary_Negate
.a87c	60		rts				rts
.a87d					Unary_Negate:
.a87d					Unary_Const_Minus:
.a87d	38		sec				sec
.a87e	a9 00		lda #$00			lda		#0
.a880	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.a883	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a886	a9 00		lda #$00			lda		#0
.a888	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.a88b	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a88e	a9 00		lda #$00			lda		#0
.a890	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.a893	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a896	a9 00		lda #$00			lda		#0
.a898	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.a89b	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a89e	60		rts				rts
.a89f					Unary_Not:
.a89f	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a8a2	49 ff		eor #$ff			eor 	#$FF
.a8a4	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a8a7	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a8aa	49 ff		eor #$ff			eor 	#$FF
.a8ac	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a8af	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a8b2	49 ff		eor #$ff			eor 	#$FF
.a8b4	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a8b7	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a8ba	49 ff		eor #$ff			eor 	#$FF
.a8bc	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a8bf	60		rts				rts
.a8c0					Unary_Increment:
.a8c0	fe 00 0c	inc $0c00,x			inc 	stack0,x
.a8c3	d0 0d		bne $a8d2			bne 	_UIExit
.a8c5	fe 00 0d	inc $0d00,x			inc 	stack1,x
.a8c8	d0 08		bne $a8d2			bne 	_UIExit
.a8ca	fe 00 0e	inc $0e00,x			inc 	stack2,x
.a8cd	d0 03		bne $a8d2			bne 	_UIExit
.a8cf	fe 00 0f	inc $0f00,x			inc 	stack3,x
.a8d2					_UIExit:
.a8d2	60		rts				rts
.a8d3					Unary_Decrement:
.a8d3	38		sec				sec
.a8d4	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a8d7	e9 01		sbc #$01			sbc 	#1
.a8d9	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a8dc	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a8df	e9 00		sbc #$00			sbc 	#0
.a8e1	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a8e4	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a8e7	e9 00		sbc #$00			sbc 	#0
.a8e9	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a8ec	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a8ef	e9 00		sbc #$00			sbc 	#0
.a8f1	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a8f4	60		rts				rts
.a8f5					Unary_Shl:
.a8f5	1e 00 0c	asl $0c00,x			asl 	stack0,x
.a8f8	3e 00 0d	rol $0d00,x			rol 	stack1,x
.a8fb	3e 00 0e	rol $0e00,x			rol 	stack2,x
.a8fe	3e 00 0f	rol $0f00,x			rol 	stack3,x
.a901	60		rts				rts
.a902					Unary_Shr:
.a902	5e 00 0f	lsr $0f00,x			lsr 	stack3,x
.a905	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a908	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a90b	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a90e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/memory.asm

.a90f					Mem_Peek:
.a90f	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a912	85 04		sta $04				sta 	zTemp0
.a914	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a917	85 05		sta $05				sta 	zTemp0+1
.a919	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a91b	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a91e	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a921	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a924	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a927	60		rts				rts
.a928					Mem_WPeek:
.a928	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a92b	85 04		sta $04				sta 	zTemp0
.a92d	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a930	85 05		sta $05				sta 	zTemp0+1
.a932	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a934	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a937	5a		phy				phy 								; read msb
.a938	a0 01		ldy #$01			ldy 	#1
.a93a	b1 04		lda ($04),y			lda 	(zTemp0),y
.a93c	7a		ply				ply
.a93d	9d 00 0d	sta $0d00,x			sta 	stack1,x 				; write to stack
.a940	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a943	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a946	60		rts				rts
.a947					Mem_DPeek:
.a947	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a94a	85 04		sta $04				sta 	zTemp0
.a94c	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a94f	85 05		sta $05				sta 	zTemp0+1
.a951	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a953	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a956	5a		phy				phy 								; read msb
.a957	a0 01		ldy #$01			ldy 	#1
.a959	b1 04		lda ($04),y			lda 	(zTemp0),y
.a95b	9d 00 0d	sta $0d00,x			sta 	stack1,x 					; write to stack
.a95e	c8		iny				iny
.a95f	b1 04		lda ($04),y			lda 	(zTemp0),y
.a961	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a964	c8		iny				iny
.a965	b1 04		lda ($04),y			lda 	(zTemp0),y
.a967	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a96a	7a		ply				ply
.a96b	60		rts				rts
.a96c					Mem_Poke:
.a96c	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a96f	85 04		sta $04				sta 	zTemp0
.a971	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a974	85 05		sta $05				sta 	zTemp0+1
.a976	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.a979	92 04		sta ($04)			sta 	(zTemp0)
.a97b	ca		dex				dex
.a97c	ca		dex				dex
.a97d	60		rts				rts
.a97e					Mem_WPoke:
.a97e	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a981	85 04		sta $04				sta 	zTemp0
.a983	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a986	85 05		sta $05				sta 	zTemp0+1
.a988	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.a98b	92 04		sta ($04)			sta 	(zTemp0)
.a98d	5a		phy				phy
.a98e	a0 01		ldy #$01			ldy 	#1
.a990	bd ff 0e	lda $0eff,x			lda 	stack3-1,x 				; byte to write
.a993	91 04		sta ($04),y			sta 	(zTemp0),y
.a995	7a		ply				ply
.a996	ca		dex				dex
.a997	ca		dex				dex
.a998	60		rts				rts
.a999					Mem_DPoke:
.a999	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a99c	85 04		sta $04				sta 	zTemp0
.a99e	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a9a1	85 05		sta $05				sta 	zTemp0+1
.a9a3	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 					; byte to write
.a9a6	92 04		sta ($04)			sta 	(zTemp0)
.a9a8	5a		phy				phy
.a9a9	a0 01		ldy #$01			ldy 	#1
.a9ab	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a9ae	91 04		sta ($04),y			sta 	(zTemp0),y
.a9b0	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a9b3	c8		iny				iny
.a9b4	91 04		sta ($04),y			sta 	(zTemp0),y
.a9b6	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a9b9	c8		iny				iny
.a9ba	91 04		sta ($04),y			sta 	(zTemp0),y
.a9bc	7a		ply				ply
.a9bd	ca		dex				dex
.a9be	ca		dex				dex
.a9bf	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/binary.asm

.a9c0					Stack_Add:
.a9c0	ca		dex				dex
.a9c1					Stack_Add_No_Dex:
.a9c1	18		clc				clc
.a9c2	bd 00 0c	lda $0c00,x			lda		stack0,x
.a9c5	7d 01 0c	adc $0c01,x			adc 	stack0+1,x
.a9c8	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a9cb	bd 00 0d	lda $0d00,x			lda		stack1,x
.a9ce	7d 01 0d	adc $0d01,x			adc 	stack1+1,x
.a9d1	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a9d4	bd 00 0e	lda $0e00,x			lda		stack2,x
.a9d7	7d 01 0e	adc $0e01,x			adc 	stack2+1,x
.a9da	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a9dd	bd 00 0f	lda $0f00,x			lda		stack3,x
.a9e0	7d 01 0f	adc $0f01,x			adc 	stack3+1,x
.a9e3	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a9e6	60		rts				rts
.a9e7					Stack_Sub:
.a9e7	ca		dex				dex
.a9e8	38		sec				sec
.a9e9	bd 00 0c	lda $0c00,x			lda		stack0,x
.a9ec	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.a9ef	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a9f2	bd 00 0d	lda $0d00,x			lda		stack1,x
.a9f5	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.a9f8	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a9fb	bd 00 0e	lda $0e00,x			lda		stack2,x
.a9fe	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.aa01	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aa04	bd 00 0f	lda $0f00,x			lda		stack3,x
.aa07	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.aa0a	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aa0d	60		rts				rts
.aa0e					Stack_And:
.aa0e	ca		dex				dex
.aa0f	bd 00 0c	lda $0c00,x			lda		stack0,x
.aa12	3d 01 0c	and $0c01,x			and		stack0+1,x
.aa15	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aa18	bd 00 0d	lda $0d00,x			lda		stack1,x
.aa1b	3d 01 0d	and $0d01,x			and 	stack1+1,x
.aa1e	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aa21	bd 00 0e	lda $0e00,x			lda		stack2,x
.aa24	3d 01 0e	and $0e01,x			and 	stack2+1,x
.aa27	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aa2a	bd 00 0f	lda $0f00,x			lda		stack3,x
.aa2d	3d 01 0f	and $0f01,x			and 	stack3+1,x
.aa30	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aa33	60		rts				rts
.aa34					Stack_Xor:
.aa34	ca		dex				dex
.aa35	bd 00 0c	lda $0c00,x			lda		stack0,x
.aa38	5d 01 0c	eor $0c01,x			eor		stack0+1,x
.aa3b	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aa3e	bd 00 0d	lda $0d00,x			lda		stack1,x
.aa41	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.aa44	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aa47	bd 00 0e	lda $0e00,x			lda		stack2,x
.aa4a	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.aa4d	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aa50	bd 00 0f	lda $0f00,x			lda		stack3,x
.aa53	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.aa56	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aa59	60		rts				rts
.aa5a					Stack_Or:
.aa5a	ca		dex				dex
.aa5b	bd 00 0c	lda $0c00,x			lda		stack0,x
.aa5e	1d 01 0c	ora $0c01,x			ora		stack0+1,x
.aa61	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aa64	bd 00 0d	lda $0d00,x			lda		stack1,x
.aa67	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.aa6a	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aa6d	bd 00 0e	lda $0e00,x			lda		stack2,x
.aa70	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.aa73	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aa76	bd 00 0f	lda $0f00,x			lda		stack3,x
.aa79	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.aa7c	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aa7f	60		rts				rts
.aa80					Stack_Shl:
.aa80	38		sec				sec
.aa81	80 01		bra $aa84			bra 	StackShift
.aa83					Stack_Shr:
.aa83	18		clc				clc
.aa84					StackShift:
.aa84	08		php				php
.aa85	ca		dex				dex
.aa86	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; if the shift >= 32
.aa89	29 e0		and #$e0			and 	#$E0 						; going to be zero.
.aa8b	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.aa8e	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.aa91	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.aa94	d0 13		bne $aaa9			bne 	_SSZero
.aa96					_SSLoop:
.aa96	de 01 0c	dec $0c01,x			dec 	stack0+1,x 					; dec check count
.aa99	30 1a		bmi $aab5			bmi 	_SSDone 					; completed ?
.aa9b	28		plp				plp 								; restore flag
.aa9c	08		php				php
.aa9d	b0 05		bcs $aaa4			bcs 	_SSLeft 					; do either shift.
.aa9f	20 02 a9	jsr $a902			jsr 	Unary_Shr
.aaa2	80 f2		bra $aa96			bra 	_SSLoop
.aaa4					_SSLeft:
.aaa4	20 f5 a8	jsr $a8f5			jsr 	Unary_Shl
.aaa7	80 ed		bra $aa96			bra 	_SSLoop
.aaa9					_SSZero:
.aaa9	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; too many shifts.
.aaac	9e 00 0d	stz $0d00,x			stz 	stack1,x
.aaaf	9e 00 0e	stz $0e00,x			stz 	stack2,x
.aab2	9e 00 0f	stz $0f00,x			stz 	stack3,x
.aab5					_SSDone:
.aab5	28		plp				plp 								; throw flag.
.aab6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/multiply.asm

.aab7					MulInteger32:
.aab7	ca		dex				dex
.aab8	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy +0 to workspace
.aabb	85 0e		sta $0e				sta 	zLTemp1
.aabd	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aac0	85 0f		sta $0f				sta 	zLTemp1+1
.aac2	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aac5	85 10		sta $10				sta 	zLTemp1+2
.aac7	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aaca	85 11		sta $11				sta 	zLTemp1+3
.aacc	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; zero +0, where the result goes.
.aacf	9e 00 0d	stz $0d00,x			stz 	stack1,x
.aad2	9e 00 0e	stz $0e00,x			stz 	stack2,x
.aad5	9e 00 0f	stz $0f00,x			stz 	stack3,x
.aad8					_BFMMultiply:
.aad8	a5 0e		lda $0e				lda 	zLTemp1 					; get LSBit of 8-11
.aada	29 01		and #$01			and 	#1
.aadc	f0 03		beq $aae1			beq 	_BFMNoAdd
.aade	20 c1 a9	jsr $a9c1			jsr 	Stack_Add_No_Dex 			; co-opt this code
.aae1					_BFMNoAdd:
.aae1	1e 01 0c	asl $0c01,x			asl 	stack0+1,x 					; shift +4 left
.aae4	3e 01 0d	rol $0d01,x			rol 	stack1+1,x
.aae7	3e 01 0e	rol $0e01,x			rol 	stack2+1,x
.aaea	3e 01 0f	rol $0f01,x			rol 	stack3+1,x
.aaed	46 11		lsr $11				lsr 	zLTemp1+3 					; shift +8 right
.aaef	66 10		ror $10				ror 	zLTemp1+2
.aaf1	66 0f		ror $0f				ror 	zLTemp1+1
.aaf3	66 0e		ror $0e				ror 	zLTemp1
.aaf5	a5 0e		lda $0e				lda 	zLTemp1 					; continue if +8 is nonzero
.aaf7	05 0f		ora $0f				ora 	zLTemp1+1
.aaf9	05 10		ora $10				ora 	zLTemp1+2
.aafb	05 11		ora $11				ora 	zLTemp1+3
.aafd	d0 d9		bne $aad8			bne 	_BFMMultiply
.aaff	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/divide.asm

.ab00					DivInteger32:
.ab00	ca		dex				dex
.ab01	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check for division by zero.
.ab04	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.ab07	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.ab0a	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.ab0d	d0 14		bne $ab23			bne 	_BFDOkay
.ab0f	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>ab12	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>ab1a	20 42 59 20 5a 45 52 4f 00
.ab23					_BFDOkay:
.ab23	64 0e		stz $0e				stz 	zLTemp1 					; Q/Dividend/Left in +0
.ab25	64 0f		stz $0f				stz 	zLTemp1+1 					; M/Divisor/Right in +4
.ab27	64 10		stz $10				stz 	zLTemp1+2
.ab29	64 11		stz $11				stz 	zLTemp1+3
.ab2b	9c 23 0a	stz $0a23			stz 	SignCount 					; Count of signs.
.ab2e	20 89 ab	jsr $ab89			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ab31	e8		inx				inx
.ab32	20 89 ab	jsr $ab89			jsr 	CheckIntegerNegate
.ab35	ca		dex				dex
.ab36	5a		phy				phy 								; Y is the counter
.ab37	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.ab39					_BFDLoop:
.ab39	1e 00 0c	asl $0c00,x			asl 	stack0,x 					; shift AQ left.
.ab3c	3e 00 0d	rol $0d00,x			rol 	stack1,x
.ab3f	3e 00 0e	rol $0e00,x			rol 	stack2,x
.ab42	3e 00 0f	rol $0f00,x			rol 	stack3,x
.ab45	26 0e		rol $0e				rol 	zLTemp1
.ab47	26 0f		rol $0f				rol 	zLTemp1+1
.ab49	26 10		rol $10				rol 	zLTemp1+2
.ab4b	26 11		rol $11				rol 	zLTemp1+3
.ab4d	38		sec				sec
.ab4e	a5 0e		lda $0e				lda 	zLTemp1+0 					; Calculate A-M on stack.
.ab50	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.ab53	48		pha				pha
.ab54	a5 0f		lda $0f				lda 	zLTemp1+1
.ab56	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.ab59	48		pha				pha
.ab5a	a5 10		lda $10				lda 	zLTemp1+2
.ab5c	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ab5f	48		pha				pha
.ab60	a5 11		lda $11				lda 	zLTemp1+3
.ab62	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ab65	90 15		bcc $ab7c			bcc 	_BFDNoAdd
.ab67	85 11		sta $11				sta 	zLTemp1+3 					; update A
.ab69	68		pla				pla
.ab6a	85 10		sta $10				sta 	zLTemp1+2
.ab6c	68		pla				pla
.ab6d	85 0f		sta $0f				sta 	zLTemp1+1
.ab6f	68		pla				pla
.ab70	85 0e		sta $0e				sta 	zLTemp1+0
.ab72	bd 00 0c	lda $0c00,x			lda 	stack0,x 			; set Q bit 1.
.ab75	09 01		ora #$01			ora 	#1
.ab77	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ab7a	80 03		bra $ab7f			bra 	_BFDNext
.ab7c					_BFDNoAdd:
.ab7c	68		pla				pla 								; Throw away the intermediate calculations
.ab7d	68		pla				pla
.ab7e	68		pla				pla
.ab7f					_BFDNext:
.ab7f	88		dey				dey
.ab80	d0 b7		bne $ab39			bne 	_BFDLoop
.ab82	7a		ply				ply 								; restore Y
.ab83	4e 23 0a	lsr $0a23			lsr 	SignCount 					; if sign count odd,
.ab86	b0 07		bcs $ab8f			bcs		IntegerNegateAlways 		; negate the result
.ab88	60		rts				rts
.ab89					CheckIntegerNegate:
.ab89	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; is it -ve = MSB set ?
.ab8c	30 01		bmi $ab8f			bmi 	IntegerNegateAlways 		; if so negate it
.ab8e	60		rts				rts
.ab8f					IntegerNegateAlways:
.ab8f	ee 23 0a	inc $0a23			inc 	SignCount 					; bump the count of signs
.ab92	4c 7d a8	jmp $a87d			jmp 	Unary_Negate
.ab95					ModInteger32:
.ab95	20 00 ab	jsr $ab00			jsr 	DivInteger32
.ab98	a5 0e		lda $0e				lda 	zLTemp1
.ab9a	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ab9d	a5 0f		lda $0f				lda 	zLTemp1+1
.ab9f	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aba2	a5 10		lda $10				lda 	zLTemp1+2
.aba4	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aba7	a5 11		lda $11				lda 	zLTemp1+3
.aba9	9d 00 0f	sta $0f00,x			sta 	stack3,x
.abac	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/compare.asm

.abad					Comp_Equal:
.abad	38		sec				sec
.abae	80 01		bra $abb1			bra 	Comp_CheckEqual
.abb0					Comp_NotEqual:
.abb0	18		clc				clc
.abb1					Comp_CheckEqual:
.abb1	08		php				php
.abb2	ca		dex				dex
.abb3	bd 00 0c	lda $0c00,x			lda		stack0,x
.abb6	5d 01 0c	eor $0c01,x			eor 	stack0+1,x
.abb9	d0 16		bne $abd1			bne 	_CCENonZero
.abbb	bd 00 0d	lda $0d00,x			lda		stack1,x
.abbe	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.abc1	d0 0e		bne $abd1			bne 	_CCENonZero
.abc3	bd 00 0e	lda $0e00,x			lda		stack2,x
.abc6	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.abc9	d0 06		bne $abd1			bne 	_CCENonZero
.abcb	bd 00 0f	lda $0f00,x			lda		stack3,x
.abce	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.abd1					_CCENonZero:
.abd1	f0 02		beq $abd5			beq 	_CCENotSet
.abd3	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.abd5					_CCENotSet:
.abd5					CompCheckFlip:
.abd5	28		plp				plp 								; if carry set, we want $FF if equal
.abd6	90 02		bcc $abda			bcc 	CompReturn
.abd8	49 ff		eor #$ff			eor 	#$FF
.abda					CompReturn:
.abda	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; save result on stack.
.abdd	9d 00 0d	sta $0d00,x			sta 	stack1,x
.abe0	9d 00 0e	sta $0e00,x			sta 	stack2,x
.abe3	9d 00 0f	sta $0f00,x			sta 	stack3,x
.abe6	60		rts				rts
.abe7					Comp_Less:
.abe7	18		clc				clc
.abe8	80 01		bra $abeb			bra 	Comp_LessCont
.abea					Comp_GreaterEqual:
.abea	38		sec				sec
.abeb					Comp_LessCont:
.abeb	08		php				php
.abec	ca		dex				dex
.abed	38		sec				sec
.abee	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; do a subtraction w/o storing the result
.abf1	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.abf4	bd 00 0d	lda $0d00,x			lda 	stack1,x
.abf7	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.abfa	bd 00 0e	lda $0e00,x			lda 	stack2,x
.abfd	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ac00	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ac03	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ac06	50 02		bvc $ac0a			bvc 	_CLNoFlip 					; unsigned -> signed
.ac08	49 80		eor #$80			eor 	#$80
.ac0a					_CLNoFlip:
.ac0a	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.ac0c	f0 c7		beq $abd5			beq 	CompCheckFlip
.ac0e	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.ac10	80 c3		bra $abd5			bra 	CompCheckFlip
.ac12					Comp_LessEqual:
.ac12	38		sec				sec
.ac13	80 01		bra $ac16			bra 	Comp_LessEqualCont
.ac15					Comp_Greater:
.ac15	18		clc				clc
.ac16					Comp_LessEqualCont:
.ac16	08		php				php
.ac17	ca		dex				dex
.ac18	38		sec				sec
.ac19	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; do a subtraction w/o storing the result, backwards
.ac1c	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.ac1f	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.ac22	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.ac25	bd 01 0e	lda $0e01,x			lda 	stack2+1,x
.ac28	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.ac2b	bd 01 0f	lda $0f01,x			lda 	stack3+1,x
.ac2e	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.ac31	50 02		bvc $ac35			bvc 	_CLENoFlip 					; unsigned -> signed
.ac33	49 80		eor #$80			eor 	#$80
.ac35					_CLENoFlip:
.ac35	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.ac37	f0 9c		beq $abd5			beq 	CompCheckFlip
.ac39	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.ac3b	80 98		bra $abd5			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: miscellany/system.asm

.ac3d					System_RUN:
.ac3d	20 a3 a3	jsr $a3a3			jsr		ResetForRun 				; clear vars, stacks etc.
.ac40	20 98 a3	jsr $a398			jsr 	ResetCodePointer 			; point to first thing to do.
.ac43	4c 0b a2	jmp $a20b			jmp 	Execute						; and run
.ac46					System_END:
>ac46	ff						.byte 	$FF
.ac47	4c ed a4	jmp $a4ed			jmp 	WarmStart
.ac4a					System_STOP:
.ac4a	4c ff ff	jmp $ffff			jmp 	$FFFF
.ac4d	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>ac50	53 54 4f 50 00					.text 	"STOP",0
.ac55					System_Assert:
.ac55	ca		dex				dex
.ac56	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.ac59	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.ac5c	1d 02 0d	ora $0d02,x			ora 	stack1+2,x
.ac5f	1d 03 0d	ora $0d03,x			ora 	stack1+3,x
.ac62	d0 0a		bne $ac6e			bne 	_SAOkay
.ac64	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>ac67	41 53 53 45 52 54 00				.text 	"ASSERT",0
.ac6e	60		rts		_SAOkay:rts
.ac6f					System_New:
.ac6f	9c 00 11	stz $1100			stz 	ProgramStart 				; zero the first offset, erases.
.ac72	20 a3 a3	jsr $a3a3			jsr		ResetForRun 				; clear vars, stacks etc.
.ac75	60		rts				rts
.ac76					System_Old:
.ac76	20 98 a3	jsr $a398			jsr 	ResetCodePointer 			; start of first line.
.ac79					_SOFindZero:
.ac79	b1 00		lda ($00),y			lda 	(codePtr),y 				; look for trailing $00
.ac7b	f0 15		beq $ac92			beq 	_SOFoundEnd
.ac7d	c8		iny				iny
.ac7e	d0 f9		bne $ac79			bne 	_SOFindZero
.ac80	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>ac83	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER",0
>ac8b	45 43 4f 56 45 52 00
.ac92					_SOFoundEnd:
.ac92	c8		iny				iny 								; update the offset
.ac93	8c 00 11	sty $1100			sty 	ProgramStart
.ac96	20 a3 a3	jsr $a3a3			jsr 	ResetForRun 				; redo all stacks etc.
.ac99	60		rts				rts
.ac9a					System_Sys:
.ac9a	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy and drop call address
.ac9d	85 04		sta $04				sta 	zTemp0
.ac9f	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aca2	85 05		sta $05				sta 	zTemp0+1
.aca4	ca		dex				dex
.aca5	da		phx				phx
.aca6	5a		phy				phy
.aca7	ad 00 10	lda $1000			lda 	AZVariables+('A'-'A')*4		; load AXY
.acaa	ae 5c 10	ldx $105c			ldx 	AZVariables+('X'-'A')*4
.acad	ac 60 10	ldy $1060			ldy 	AZVariables+('Y'-'A')*4
.acb0	20 bf ac	jsr $acbf			jsr 	_SSCall 					; effectively jsr (zTemp)
.acb3	8d 00 10	sta $1000			sta 	AZVariables+('A'-'A')*4 	; store AXY
.acb6	8e 5c 10	stx $105c			stx 	AZVariables+('X'-'A')*4
.acb9	8c 60 10	sty $1060			sty 	AZVariables+('Y'-'A')*4
.acbc	7a		ply				ply
.acbd	fa		plx				plx
.acbe	60		rts				rts
.acbf	6c 04 00	jmp ($0004)	_SSCall:jmp 	(zTemp0)
.acc2					System_Stack:
.acc2	da		phx				phx 								; save stack
.acc3	5a		phy				phy
.acc4	86 08		stx $08				stx 	zTemp2 						; save old TOS
.acc6	a9 5b		lda #$5b			lda 	#"["
.acc8	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.accb	e0 00		cpx #$00			cpx 	#0 							; empty
.accd	f0 14		beq $ace3			beq 	_SSEnd
.accf	a2 01		ldx #$01			ldx 	#1 							; start here
.acd1					_SSLoop:
.acd1	20 1b a5	jsr $a51b			jsr 	IntegerToString 			; print TOS
.acd4	20 09 a5	jsr $a509			jsr 	ErrorPrintIntegerBuffer
.acd7	e4 08		cpx $08				cpx 	zTemp2 						; done TOS exit
.acd9	f0 08		beq $ace3			beq 	_SSEnd
.acdb	e8		inx				inx	 								; advance pointer print ,
.acdc	a9 2c		lda #$2c			lda 	#','
.acde	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.ace1	80 ee		bra $acd1			bra 	_SSLoop
.ace3					_SSEnd:
.ace3	a9 5d		lda #$5d			lda 	#"]"						; finish off.
.ace5	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.ace8	a9 0d		lda #$0d			lda 	#13
.acea	20 d7 a1	jsr $a1d7			jsr 	ExternPrint
.aced	7a		ply				ply
.acee	fa		plx				plx
.acef	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/variables.asm

.acf0					Identifier:
.acf0	88		dey				dey 								; wind back to identifier start
.acf1	20 be a2	jsr $a2be			jsr 	IdentifierSearch 			; try to find it.
.acf4	90 2d		bcc $ad23			bcc 	_IDUnknown 					; not known, give up.
.acf6	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.acf8	d0 3d		bne $ad37			bne 	IDTypeError
.acfa	c8		iny		_IDSkip:iny
.acfb	b1 00		lda ($00),y			lda 	(codePtr),y
.acfd	c9 c0		cmp #$c0			cmp 	#$C0
.acff	b0 f9		bcs $acfa			bcs 	_IDSkip
.ad01	20 30 a4	jsr $a430			jsr 	IndexCheck 					; check index/subscript
.ad04	5a		phy				phy
.ad05	e8		inx				inx 								; make space on stack
.ad06	a0 00		ldy #$00			ldy 	#0 							; copy it back
.ad08	b1 12		lda ($12),y			lda 	(idDataAddr),y
.ad0a	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ad0d	c8		iny				iny
.ad0e	b1 12		lda ($12),y			lda 	(idDataAddr),y
.ad10	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ad13	c8		iny				iny
.ad14	b1 12		lda ($12),y			lda 	(idDataAddr),y
.ad16	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ad19	c8		iny				iny
.ad1a	b1 12		lda ($12),y			lda 	(idDataAddr),y
.ad1c	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ad1f	7a		ply				ply
.ad20	4c 0b a2	jmp $a20b			jmp 	Execute
.ad23					_IDUnknown:
.ad23	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>ad26	55 4e 4b 4e 4f 57 4e 20				.text 	"UNKNOWN VARIABLE",0
>ad2e	56 41 52 49 41 42 4c 45 00
.ad37					IDTypeError:
.ad37	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>ad3a	4d 49 53 53 49 4e 47 20				.text 	"MISSING VARIABLE",0
>ad42	56 41 52 49 41 42 4c 45 00
.ad4b					WriteVariable:
.ad4b	b1 00		lda ($00),y			lda 	(codePtr),y 				; check variable
.ad4d	c9 c0		cmp #$c0			cmp 	#$C0
.ad4f	90 e6		bcc $ad37			bcc 	IDTypeError
.ad51	20 be a2	jsr $a2be			jsr 	IdentifierSearch 			; does it exist
.ad54	90 06		bcc $ad5c			bcc 	_WVNoIdentifier
.ad56	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.ad58	f0 12		beq $ad6c			beq 	_WVWriteTOS 				; if so write TOS to it.
.ad5a	80 db		bra $ad37			bra 	IDTypeError 				; not, then can't do anything.
.ad5c					_WVNoIdentifier:
.ad5c	5a		phy				phy 								; get current line number
.ad5d	a0 01		ldy #$01			ldy 	#1
.ad5f	b1 00		lda ($00),y			lda 	(codePtr),y
.ad61	c8		iny				iny
.ad62	11 00		ora ($00),y			ora 	(codePtr),y
.ad64	7a		ply				ply
.ad65	f0 2d		beq $ad94			beq 	_WVCantCreate 				; if zero (command line) no new vars
.ad67	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; create identifier
.ad69	20 25 a3	jsr $a325			jsr 	IdentifierCreate 			; try to find it
.ad6c					_WVWriteTOS:
.ad6c	88		dey				dey 								; skip over identifier.
.ad6d					_WVSkipIdentifier:
.ad6d	c8		iny				iny
.ad6e	b1 00		lda ($00),y			lda 	(codePtr),y
.ad70	c9 c0		cmp #$c0			cmp 	#$C0
.ad72	b0 f9		bcs $ad6d			bcs 	_WVSkipIdentifier
.ad74	20 30 a4	jsr $a430			jsr 	IndexCheck 					; check index/subscript
.ad77	5a		phy				phy									; copy TOS in
.ad78	a0 00		ldy #$00			ldy 	#0
.ad7a	bd 00 0c	lda $0c00,x			lda 	stack0,x
.ad7d	91 12		sta ($12),y			sta 	(idDataAddr),y
.ad7f	c8		iny				iny
.ad80	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ad83	91 12		sta ($12),y			sta 	(idDataAddr),y
.ad85	c8		iny				iny
.ad86	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ad89	91 12		sta ($12),y			sta 	(idDataAddr),y
.ad8b	c8		iny				iny
.ad8c	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ad8f	91 12		sta ($12),y			sta 	(idDataAddr),y
.ad91	7a		ply				ply
.ad92	ca		dex				dex 								; drop
.ad93	60		rts				rts									; go back and execute again.
.ad94					_WVCantCreate:
.ad94	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>ad97	43 41 4e 4e 4f 54 20 43				.text 	"CANNOT CREATE VARIABLE",0
>ad9f	52 45 41 54 45 20 56 41 52 49 41 42 4c 45 00

;******  Return to file: main.asm


;******  Processing file: structures/fornext.asm

.adae					Command_For:
.adae	20 b3 ae	jsr $aeb3			jsr 	StructPushCurrent 			; push current on the stack.
.adb1	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check zero
.adb4	1d 00 0d	ora $0d00,x			ora 	stack1,x
.adb7	1d 00 0e	ora $0e00,x			ora 	stack2,x
.adba	1d 00 0f	ora $0f00,x			ora 	stack3,x
.adbd	f0 34		beq $adf3			beq 	_CFZero
.adbf	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; push 1's complement of index on
.adc2	49 ff		eor #$ff			eor 	#$FF 						; structure stack.
.adc4	c6 02		dec $02				dec 	StructSP
.adc6	92 02		sta ($02)			sta 	(StructSP)
.adc8	bd 00 0e	lda $0e00,x			lda 	stack2,x
.adcb	49 ff		eor #$ff			eor 	#$FF
.adcd	c6 02		dec $02				dec 	StructSP
.adcf	92 02		sta ($02)			sta 	(StructSP)
.add1	bd 00 0d	lda $0d00,x			lda 	stack1,x
.add4	49 ff		eor #$ff			eor 	#$FF
.add6	c6 02		dec $02				dec 	StructSP
.add8	92 02		sta ($02)			sta 	(StructSP)
.adda	bd 00 0c	lda $0c00,x			lda 	stack0,x
.addd	49 ff		eor #$ff			eor 	#$FF
.addf	c6 02		dec $02				dec 	StructSP
.ade1	92 02		sta ($02)			sta 	(StructSP)
.ade3	ca		dex				dex 								; pop stack value
.ade4	a9 46		lda #$46			lda 	#STM_FOR 					; push FOR marker
.ade6	c6 02		dec $02				dec 	StructSP
.ade8	92 02		sta ($02)			sta 	(StructSP)
.adea	a5 02		lda $02				lda 	StructSP 					; copy current so it can access it.
.adec	85 14		sta $14				sta 	ForAddr
.adee	a5 03		lda $03				lda 	StructSP+1
.adf0	85 15		sta $15				sta 	ForAddr+1
.adf2	60		rts				rts
.adf3					_CFZero:
.adf3	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>adf6	46 4f 52 20 43 4f 55 4e				.text 	"FOR COUNT ZERO",0
>adfe	54 20 5a 45 52 4f 00
.ae05					Command_Next:
.ae05	b2 02		lda ($02)			lda 	(StructSP)					; check it's FOR.
.ae07	c9 46		cmp #$46			cmp 	#STM_FOR
.ae09	d0 30		bne $ae3b			bne 	_CNNoFor
.ae0b	5a		phy				phy
.ae0c	a0 00		ldy #$00			ldy 	#0
.ae0e					_CNIncrement:
.ae0e	c8		iny				iny
.ae0f	b1 02		lda ($02),y			lda 	(StructSP),y 				; increment the index
.ae11	1a		inc a				inc 	a
.ae12	91 02		sta ($02),y			sta 	(StructSP),y
.ae14	f0 f8		beq $ae0e			beq		_CNIncrement 				; carry out.
.ae16	a0 01		ldy #$01			ldy 	#1 							; now and all the counts together
.ae18	b1 02		lda ($02),y			lda 	(StructSP),y 				; on the last time round they
.ae1a	c8		iny				iny 								; will all be $FF
.ae1b	31 02		and ($02),y			and 	(StructSP),y
.ae1d	c8		iny				iny
.ae1e	31 02		and ($02),y			and 	(StructSP),y
.ae20	c8		iny				iny
.ae21	31 02		and ($02),y			and 	(StructSP),y
.ae23	7a		ply				ply 								; restore Y
.ae24	1a		inc a				inc 	a 							; so this will be zero last time round
.ae25	d0 06		bne $ae2d			bne 	_CNLoop 					; loop back if non-zero
.ae27	a9 09		lda #$09			lda 	#9 							; pop 9 elements off structure stack.
.ae29	20 ad ae	jsr $aead			jsr 	StructPopCount
.ae2c	60		rts				rts
.ae2d					_CNLoop:
.ae2d	a5 02		lda $02				lda 	StructSP 					; copy current so it can access it.
.ae2f	85 14		sta $14				sta 	ForAddr
.ae31	a5 03		lda $03				lda 	StructSP+1
.ae33	85 15		sta $15				sta 	ForAddr+1
.ae35	a0 05		ldy #$05			ldy 	#5 							; restore the position
.ae37	20 cb ae	jsr $aecb			jsr 	StructPopCurrent
.ae3a	60		rts				rts
.ae3b					_CNNoFor:
.ae3b	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>ae3e	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>ae46	46 4f 52 00
.ae4a					Command_Index:
.ae4a	5a		phy				phy
.ae4b	a0 01		ldy #$01			ldy 	#1 							; get the stack position of
.ae4d	e8		inx				inx
.ae4e	38		sec				sec
.ae4f	a9 fe		lda #$fe			lda 	#$FE
.ae51	f1 14		sbc ($14),y			sbc 	(ForAddr),y
.ae53	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ae56	c8		iny				iny
.ae57	a9 ff		lda #$ff			lda 	#$FF
.ae59	f1 14		sbc ($14),y			sbc 	(ForAddr),y
.ae5b	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ae5e	c8		iny				iny
.ae5f	a9 ff		lda #$ff			lda 	#$FF
.ae61	f1 14		sbc ($14),y			sbc 	(ForAddr),y
.ae63	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ae66	c8		iny				iny
.ae67	a9 ff		lda #$ff			lda 	#$FF
.ae69	f1 14		sbc ($14),y			sbc 	(ForAddr),y
.ae6b	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ae6e	7a		ply				ply
.ae6f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: structures/repeat.asm

.ae70					Command_Repeat:
.ae70	20 b3 ae	jsr $aeb3			jsr 	StructPushCurrent 			; push current on the stack.
.ae73	a9 52		lda #$52			lda 	#STM_REPEAT 				; push marker
.ae75	c6 02		dec $02				dec 	StructSP
.ae77	92 02		sta ($02)			sta 	(StructSP)
.ae79	60		rts				rts
.ae7a					Command_Until:
.ae7a	b2 02		lda ($02)			lda 	(StructSP)					; check it's REPEAT
.ae7c	c9 52		cmp #$52			cmp 	#STM_REPEAT
.ae7e	d0 1b		bne $ae9b			bne 	_CUNoRepeat
.ae80	ca		dex				dex 								; pop
.ae81	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check old TOS zero
.ae84	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.ae87	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.ae8a	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.ae8d	f0 06		beq $ae95			beq 	_CULoop
.ae8f	a9 05		lda #$05			lda 	#5 							; pop 5 elements off structure stack.
.ae91	20 ad ae	jsr $aead			jsr 	StructPopCount
.ae94	60		rts				rts
.ae95					_CULoop:
.ae95	a0 01		ldy #$01			ldy 	#1 							; restore the position
.ae97	20 cb ae	jsr $aecb			jsr 	StructPopCurrent
.ae9a	60		rts				rts
.ae9b					_CUNoRepeat:
.ae9b	20 a9 a4	jsr $a4a9			jsr 	ErrorHandler
>ae9e	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>aea6	52 45 50 45 41 54 00

;******  Return to file: main.asm


;******  Processing file: structures/structures.asm

.aead					StructPopCount:
.aead	18		clc				clc
.aeae	65 02		adc $02				adc 	StructSP
.aeb0	85 02		sta $02				sta 	StructSP
.aeb2	60		rts				rts
.aeb3					StructPushCurrent:
.aeb3	a9 00		lda #$00			lda 	#0							; push bank
.aeb5	c6 02		dec $02				dec 	StructSP
.aeb7	92 02		sta ($02)			sta 	(StructSP)
.aeb9	98		tya				tya									; y Offset
.aeba	c6 02		dec $02				dec 	StructSP
.aebc	92 02		sta ($02)			sta 	(StructSP)
.aebe	a5 01		lda $01				lda 	codePtr+1 					; codeptr high
.aec0	c6 02		dec $02				dec 	StructSP
.aec2	92 02		sta ($02)			sta 	(StructSP)
.aec4	a5 00		lda $00				lda 	codePtr 					; codeptr low
.aec6	c6 02		dec $02				dec 	StructSP
.aec8	92 02		sta ($02)			sta 	(StructSP)
.aeca	60		rts				rts
.aecb					StructPopCurrent:
.aecb	b1 02		lda ($02),y			lda 	(StructSP),y 				; codeptr low
.aecd	85 00		sta $00				sta 	codePtr
.aecf	c8		iny				iny
.aed0	b1 02		lda ($02),y			lda 	(StructSP),y 				; codeptr high
.aed2	85 01		sta $01				sta 	codePtr+1
.aed4	c8		iny				iny
.aed5	b1 02		lda ($02),y			lda 	(StructSP),y				; y offset
.aed7	a8		tay				tay
.aed8	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/testcode.inc

>1100	07 64 00 83 80 b9 00 0a			.byte $07,$64,$00,$83,$80,$b9,$00,$0a,$6e,$00,$81,$4b,$10,$84,$10,$40,$00,$07,$78,$00,$8d,$90,$b1,$00,$05,$82,$00,$42,$00
>1108	6e 00 81 4b 10 84 10 40 00 07 78 00 8d 90 b1 00
>1118	05 82 00 42 00

;******  Return to file: main.asm

>111d	00						.byte 	0

;******  End of listing
