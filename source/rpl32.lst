
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -D debug=2 -q -c -o rpl32.prg -L rpl32.lst main.asm
; Wed Oct  9 11:53:38 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					debug=2

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; build the interpreter here
=$0c00					StackAddress = $0C00 						; 1k of stack space (256 x 32 bits)
=$1000					MemoryStart = $1000 						; system memory starts here
=$9800					MemoryEnd = $9800 							; and ends here.
=$0bff					StructureStack = $0BFF 						; structure stack (works down to $xx00)
=$0800					ExtDataArea = $0800 						; space where non zp data goes
=$0900					InputBuffer = $0900 						; Input Buffer
=$0a00					TokeniseBuffer = $0A00						; Tokenising buffer
=16					HashTableSize = 16 							; hash tables to search.
>0010					CodePtr: 		.word ? 					; code pointer
>0012					StructSP: 		.word ?						; structure stack pointer
>0014					zTemp0:			.word ?						; temporary words
>0016					zTemp1: 		.word ?
>0018					zTemp2: 		.word ?
>001a					zTemp3: 		.word ?
>001c					zTemp4:			.word ?
>001e					zLTemp1:		.dword ?					; temporary longs
>0022					idDataAddr:		.word ? 					; data address.
>0024					ForAddr:		.byte ? 					; points to current FOR structure
>0800					SBuffer:		.fill 32 					; string buffer
>0820					SBPosition:		.byte ? 					; position in String Buffer
>0821					NumConvCount:	.byte ? 					; used in int to string
>0822					breakCount:		.byte ? 					; used to stop break firing every execution.
>0823					SignCount:		.byte ?						; sign count for divide
>0824					NumSuppress:	.byte ? 					; zero suppression flag
>0825					IFSHexFlag:		.byte ? 					; $FF if hex, $00 if dec
>1000					AZVariables:	.fill	26*4 				; 26 x 4 byte variables, which are A-Z
>1068					HashTable: 		.fill 	HashTableSize * 2 	; n x 2 links for the hash tables.
>1088	00 00				VarMemory:		.word 	0 					; next free byte available for VARIABLES (going up)
>108a	00 00				AllocMemory: 	.word 	0 					; last free byte availabel for ALLOC (going down)
=4352					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0c00					stack0 = StackAddress
=3328					stack1 = StackAddress+256
=3584					stack2 = StackAddress+512
=3840					stack3 = StackAddress+768
="V"					IDT_VARIABLE = 'V'							; type markers for the information store.
="P"					IDT_PROCEDURE = 'P'							; standard procedure (e.g. in code)
="C"					IDT_CODEPROC = 'C'							; machine language procedure.
="F"					STM_FOR = 'F'								; structure markers (for/next)
="C"					STM_CALL = 'C'								; call & return  (& ;)
="R"					STM_REPEAT = 'R'							; repeat & until
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=5					CTH_ERROR = COL_MAGENTA
=2					CTH_TOKEN = COL_GREEN
=3					CTH_IDENT = COL_YELLOW
=7					CTH_COMMENT = COL_WHITE
=5					CTH_STRING = COL_MAGENTA
=6					CTH_NUMBER = COL_CYAN
=5					CTH_LINENO = COL_MAGENTA

;******  Return to file: main.asm


;******  Processing file: macro.asm


;******  Return to file: main.asm

.0f00	4c 00 a0	jmp $a000			jmp 	Start
.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 76 a2	jsr $a276			jsr 	ExternInitialise 			; interface setup
.a006	a2 00		ldx #$00			ldx 	#0 							; display boot message
.a008					_Display:
.a008	bd 99 a0	lda $a099,x			lda 	BootMessage,x
.a00b	20 97 a2	jsr $a297			jsr 	ExternPrint
.a00e	e8		inx				inx
.a00f	bd 99 a0	lda $a099,x			lda 	BootMessage,x
.a012	d0 f4		bne $a008			bne 	_Display
.a014	a9 00		lda #$00			lda 	#(MemoryEnd-ProgramStart) & $FF
.a016	a0 87		ldy #$87			ldy 	#(MemoryEnd-ProgramStart) >>8
.a018	a2 00		ldx #$00			ldx 	#0
.a01a	20 15 a6	jsr $a615			jsr 	ErrorPrint16
.a01d	a9 0d		lda #$0d			lda 	#13
.a01f	20 97 a2	jsr $a297			jsr 	ExternPrint
.a022	20 97 a2	jsr $a297			jsr 	ExternPrint
.a025	a9 98		lda #$98			lda 	#MemoryEnd >> 8 			; set top of memory address.
.a027	8d 8b 10	sta $108b			sta 	AllocMemory+1
.a02a	9c 8a 10	stz $108a			stz 	AllocMemory
.a02d	20 22 a5	jsr $a522			jsr 	ResetForRun
.a030	20 17 a5	jsr $a517			jsr 	ResetCodePointer
.a033					WarmStart:
.a033	a9 06		lda #$06			lda 	#COL_CYAN
.a035	20 a1 a2	jsr $a2a1			jsr 	ExternColour
.a038	a9 4f		lda #$4f			lda 	#"O"
.a03a	20 97 a2	jsr $a297			jsr 	ExternPrint
.a03d	a9 4b		lda #$4b			lda 	#"K"
.a03f	20 97 a2	jsr $a297			jsr 	ExternPrint
.a042	a9 0d		lda #$0d			lda 	#13
.a044	20 97 a2	jsr $a297			jsr 	ExternPrint
.a047					NewCommand:
.a047	8a		txa				txa
.a048	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack colour
.a04a	9a		txs				txs
.a04b	aa		tax				tax
.a04c	a9 07		lda #$07			lda 	#COL_WHITE
.a04e	20 a1 a2	jsr $a2a1			jsr 	ExternColour
.a051	20 b5 a2	jsr $a2b5			jsr 	ExternInput 				; input text
.a054	a9 00		lda #$00			lda 	#InputBuffer & $FF 			; codePtr = input buffer
.a056	85 10		sta $10				sta 	codePtr
.a058	a9 09		lda #$09			lda 	#InputBuffer >> 8
.a05a	85 11		sta $11				sta 	codePtr+1
.a05c	a9 03		lda #$03			lda 	#(TokeniseBuffer+3) & $FF 	; zTemp1 is set up as a fake line
.a05e	85 16		sta $16				sta 	zTemp1 						; with line number 0 by being
.a060	a9 0a		lda #$0a			lda 	#(TokeniseBuffer+3) >> 8 	; prefixed with three zeros
.a062	85 17		sta $17				sta 	zTemp1+1
.a064	9c 00 0a	stz $0a00			stz 	TokeniseBuffer+0			; put in those three zeroes
.a067	9c 01 0a	stz $0a01			stz		TokeniseBuffer+1
.a06a	9c 02 0a	stz $0a02			stz 	TokeniseBuffer+2
.a06d	20 85 a7	jsr $a785			jsr 	Tokenise
.a070	a0 00		ldy #$00			ldy 	#0 							; see what's at the start re numbers
.a072					SkipSpaces:
.a072	b9 00 09	lda $0900,y			lda 	InputBuffer,y
.a075	c8		iny				iny
.a076	c9 20		cmp #$20			cmp 	#' '
.a078	f0 f8		beq $a072			beq 	SkipSpaces
.a07a	c9 30		cmp #$30			cmp 	#'0'
.a07c	90 0e		bcc $a08c			bcc 	ExecuteCLI
.a07e	c9 3a		cmp #$3a			cmp 	#'9'+1
.a080	b0 0a		bcs $a08c			bcs 	ExecuteCLI
.a082	ad 00 09	lda $0900			lda 	InputBuffer
.a085	c9 20		cmp #$20			cmp 	#' '
.a087	f0 03		beq $a08c			beq 	ExecuteCLI
.a089	4c f6 a8	jmp $a8f6			jmp		EditProgram
.a08c					ExecuteCLI:
.a08c	a9 00		lda #$00			lda 	#TokeniseBuffer & 255 		; set tokenise buffer as faux line
.a08e	85 10		sta $10				sta 	codePtr
.a090	a9 0a		lda #$0a			lda 	#TokeniseBuffer >> 8
.a092	85 11		sta $11				sta 	codePtr+1
.a094	a0 03		ldy #$03			ldy 	#3
.a096	4c 66 a3	jmp $a366			jmp 	Execute 					; and run it
.a099					BootMessage:

;******  Processing file: generated/bootmessage.inc

>a099	2a 2a 2a 2a 20 52 50 4c			.byte $2a,$2a,$2a,$2a,$20,$52,$50,$4c,$2f,$33,$32,$20,$49,$4e,$54,$45,$52,$50,$52,$45,$54,$45,$52,$20,$2a,$2a,$2a,$2a,$0d,$0d,$57,$52,$49,$54,$54,$45,$4e,$20,$42,$59,$20,$50,$41,$55,$4c,$20,$52,$4f,$42,$53,$4f,$4e,$20,$32,$30,$31,$39,$0d,$0d,$42,$55,$49,$4c,$44,$3a,$35,$20,$44,$41,$54,$45,$3a,$30,$39,$2d,$4f,$43,$54,$2d,$32,$30,$31,$39,$0d,$0d,$4d,$45,$4d,$4f,$52,$59,$20,$41,$56,$41,$49,$4c,$41,$42,$4c,$45,$20,$00
>a0a1	2f 33 32 20 49 4e 54 45 52 50 52 45 54 45 52 20
>a0b1	2a 2a 2a 2a 0d 0d 57 52 49 54 54 45 4e 20 42 59
>a0c1	20 50 41 55 4c 20 52 4f 42 53 4f 4e 20 32 30 31
>a0d1	39 0d 0d 42 55 49 4c 44 3a 35 20 44 41 54 45 3a
>a0e1	30 39 2d 4f 43 54 2d 32 30 31 39 0d 0d 4d 45 4d
>a0f1	4f 52 59 20 41 56 41 49 4c 41 42 4c 45 20 00

;******  Return to file: main.asm


;******  Processing file: generated/tables.inc

.a100					KeywordText:
>a100	01 21					.byte $01,$21                          ; $10 !
>a102	01 2a					.byte $01,$2a                          ; $11 *
>a104	01 2b					.byte $01,$2b                          ; $12 +
>a106	02 2b 2b				.byte $02,$2b,$2b                      ; $13 ++
>a109	01 2d					.byte $01,$2d                          ; $14 -
>a10b	02 2d 2d				.byte $02,$2d,$2d                      ; $15 --
>a10e	01 2e					.byte $01,$2e                          ; $16 .
>a110	01 2f					.byte $01,$2f                          ; $17 /
>a112	01 3b					.byte $01,$3b                          ; $18 ;
>a114	01 3c					.byte $01,$3c                          ; $19 <
>a116	02 3c 3c				.byte $02,$3c,$3c                      ; $1a <<
>a119	02 3c 3d				.byte $02,$3c,$3d                      ; $1b <=
>a11c	02 3c 3e				.byte $02,$3c,$3e                      ; $1c <>
>a11f	01 3d					.byte $01,$3d                          ; $1d =
>a121	01 3e					.byte $01,$3e                          ; $1e >
>a123	02 3e 3d				.byte $02,$3e,$3d                      ; $1f >=
>a126	02 3e 3e				.byte $02,$3e,$3e                      ; $20 >>
>a129	01 40					.byte $01,$40                          ; $21 @
>a12b	03 41 42 53				.byte $03,$41,$42,$53                  ; $22 ABS
>a12f	05 41 4c 4c 4f 43			.byte $05,$41,$4c,$4c,$4f,$43          ; $23 ALLOC
>a135	03 41 4e 44				.byte $03,$41,$4e,$44                  ; $24 AND
>a139	06 41 53 53 45 52 54			.byte $06,$41,$53,$53,$45,$52,$54      ; $25 ASSERT
>a140	02 43 21				.byte $02,$43,$21                      ; $26 C!
>a143	02 43 40				.byte $02,$43,$40                      ; $27 C@
>a146	03 43 4c 52				.byte $03,$43,$4c,$52                  ; $28 CLR
>a14a	03 44 45 46				.byte $03,$44,$45,$46                  ; $29 DEF
>a14e	04 44 52 4f 50				.byte $04,$44,$52,$4f,$50              ; $2a DROP
>a153	03 44 55 50				.byte $03,$44,$55,$50                  ; $2b DUP
>a157	04 45 4c 53 45				.byte $04,$45,$4c,$53,$45              ; $2c ELSE
>a15c	03 45 4e 44				.byte $03,$45,$4e,$44                  ; $2d END
>a160	05 45 4e 44 49 46			.byte $05,$45,$4e,$44,$49,$46          ; $2e ENDIF
>a166	03 46 4f 52				.byte $03,$46,$4f,$52                  ; $2f FOR
>a16a	02 49 46				.byte $02,$49,$46                      ; $30 IF
>a16d	05 49 4e 44 45 58			.byte $05,$49,$4e,$44,$45,$58          ; $31 INDEX
>a173	04 4c 49 53 54				.byte $04,$4c,$49,$53,$54              ; $32 LIST
>a178	04 4c 4f 41 44				.byte $04,$4c,$4f,$41,$44              ; $33 LOAD
>a17d	03 4d 4f 44				.byte $03,$4d,$4f,$44                  ; $34 MOD
>a181	06 4e 45 47 41 54 45			.byte $06,$4e,$45,$47,$41,$54,$45      ; $35 NEGATE
>a188	03 4e 45 57				.byte $03,$4e,$45,$57                  ; $36 NEW
>a18c	04 4e 45 58 54				.byte $04,$4e,$45,$58,$54              ; $37 NEXT
>a191	03 4e 49 50				.byte $03,$4e,$49,$50                  ; $38 NIP
>a195	03 4e 4f 54				.byte $03,$4e,$4f,$54                  ; $39 NOT
>a199	03 4f 4c 44				.byte $03,$4f,$4c,$44                  ; $3a OLD
>a19d	02 4f 52				.byte $02,$4f,$52                      ; $3b OR
>a1a0	04 4f 56 45 52				.byte $04,$4f,$56,$45,$52              ; $3c OVER
>a1a5	08 52 45 4e 55 4d 42 45			.byte $08,$52,$45,$4e,$55,$4d,$42,$45,$52 ; $3d RENUMBER
>a1ad	52
>a1ae	06 52 45 50 45 41 54			.byte $06,$52,$45,$50,$45,$41,$54      ; $3e REPEAT
>a1b5	06 52 45 54 55 52 4e			.byte $06,$52,$45,$54,$55,$52,$4e      ; $3f RETURN
>a1bc	03 52 55 4e				.byte $03,$52,$55,$4e                  ; $40 RUN
>a1c0	04 53 41 56 45				.byte $04,$53,$41,$56,$45              ; $41 SAVE
>a1c5	03 53 48 4c				.byte $03,$53,$48,$4c                  ; $42 SHL
>a1c9	03 53 48 52				.byte $03,$53,$48,$52                  ; $43 SHR
>a1cd	04 53 54 4f 50				.byte $04,$53,$54,$4f,$50              ; $44 STOP
>a1d2	04 53 57 41 50				.byte $04,$53,$57,$41,$50              ; $45 SWAP
>a1d7	03 53 59 53				.byte $03,$53,$59,$53                  ; $46 SYS
>a1db	05 55 4e 54 49 4c			.byte $05,$55,$4e,$54,$49,$4c          ; $47 UNTIL
>a1e1	02 57 21				.byte $02,$57,$21                      ; $48 W!
>a1e4	02 57 40				.byte $02,$57,$40                      ; $49 W@
>a1e7	03 58 4f 52				.byte $03,$58,$4f,$52                  ; $4a XOR
>a1eb	01 5b					.byte $01,$5b                          ; $4b [
>a1ed	01 5d					.byte $01,$5d                          ; $4c ]
>a1ef	01 5e					.byte $01,$5e                          ; $4d ^
>a1f1	01 2b					.byte $01,$2b                          ; $4e {+}
>a1f3	01 2d					.byte $01,$2d                          ; $4f {-}
>a1f5	00					.byte $00
.a1f6					KeywordVectorTable:
>a1f6	b2 ab					.word Mem_DPoke                        ; $10 !
>a1f8	d0 ac					.word MulInteger32                     ; $11 *
>a1fa	d9 ab					.word Stack_Add                        ; $12 +
>a1fc	d9 aa					.word Unary_Increment                  ; $13 ++
>a1fe	00 ac					.word Stack_Sub                        ; $14 -
>a200	ec aa					.word Unary_Decrement                  ; $15 --
>a202	6f b0					.word System_ShowStack                 ; $16 .
>a204	19 ad					.word DivInteger32                     ; $17 /
>a206	5b b1					.word ProcReturn                       ; $18 ;
>a208	00 ae					.word Comp_Less                        ; $19 <
>a20a	0e ab					.word Unary_Shl                        ; $1a <<
>a20c	2b ae					.word Comp_LessEqual                   ; $1b <=
>a20e	c9 ad					.word Comp_NotEqual                    ; $1c <>
>a210	c6 ad					.word Comp_Equal                       ; $1d =
>a212	2e ae					.word Comp_Greater                     ; $1e >
>a214	03 ae					.word Comp_GreaterEqual                ; $1f >=
>a216	1b ab					.word Unary_Shr                        ; $20 >>
>a218	60 ab					.word Mem_DPeek                        ; $21 @
>a21a	90 aa					.word Unary_Absolute                   ; $22 ABS
>a21c	56 ae					.word Allocate                         ; $23 ALLOC
>a21e	27 ac					.word Stack_And                        ; $24 AND
>a220	00 b0					.word System_Assert                    ; $25 ASSERT
>a222	85 ab					.word Mem_Poke                         ; $26 C!
>a224	28 ab					.word Mem_Peek                         ; $27 C@
>a226	02 aa					.word Stack_Empty                      ; $28 CLR
>a228	b0 a5					.word SyntaxError                      ; $29 DEF
>a22a	05 aa					.word Stack_Drop                       ; $2a DROP
>a22c	07 aa					.word Stack_Dup                        ; $2b DUP
>a22e	71 b2					.word Struct_ELSE                      ; $2c ELSE
>a230	f5 af					.word System_END                       ; $2d END
>a232	76 b2					.word Struct_ENDIF                     ; $2e ENDIF
>a234	92 b2					.word Command_For                      ; $2f FOR
>a236	5c b2					.word Struct_IF                        ; $30 IF
>a238	2e b3					.word Command_Index                    ; $31 INDEX
>a23a	96 ae					.word Cmd_List                         ; $32 LIST
>a23c	a7 b0					.word System_Load                      ; $33 LOAD
>a23e	ae ad					.word ModInteger32                     ; $34 MOD
>a240	96 aa					.word Unary_Negate                     ; $35 NEGATE
>a242	1a b0					.word System_New                       ; $36 NEW
>a244	e9 b2					.word Command_Next                     ; $37 NEXT
>a246	21 aa					.word Stack_Nip                        ; $38 NIP
>a248	b8 aa					.word Unary_Not                        ; $39 NOT
>a24a	23 b0					.word System_Old                       ; $3a OLD
>a24c	73 ac					.word Stack_Or                         ; $3b OR
>a24e	3b aa					.word Stack_Over                       ; $3c OVER
>a250	b4 af					.word Cmd_Renumber                     ; $3d RENUMBER
>a252	54 b3					.word Command_Repeat                   ; $3e REPEAT
>a254	5b b1					.word ProcReturn2                      ; $3f RETURN
>a256	ec af					.word System_RUN                       ; $40 RUN
>a258	9d b0					.word System_Save                      ; $41 SAVE
>a25a	99 ac					.word Stack_Shl                        ; $42 SHL
>a25c	9c ac					.word Stack_Shr                        ; $43 SHR
>a25e	f8 af					.word System_STOP                      ; $44 STOP
>a260	55 aa					.word Stack_Swap                       ; $45 SWAP
>a262	47 b0					.word System_Sys                       ; $46 SYS
>a264	5e b3					.word Command_Until                    ; $47 UNTIL
>a266	97 ab					.word Mem_WPoke                        ; $48 W!
>a268	41 ab					.word Mem_WPeek                        ; $49 W@
>a26a	4d ac					.word Stack_Xor                        ; $4a XOR
>a26c	b0 a5					.word SyntaxError                      ; $4b [
>a26e	b0 a5					.word SyntaxError                      ; $4c ]
>a270	6a b1					.word WriteVariable                    ; $4d ^
>a272	b0 a5					.word SyntaxError                      ; $4e {+}
>a274	b0 a5					.word SyntaxError                      ; $4f {-}
=$10					KWD_PLING = $10                  ; $10 !
=$11					KWD_ASTERISK = $11               ; $11 *
=$12					KWD_PLUS = $12                   ; $12 +
=$13					KWD_PLUSPLUS = $13               ; $13 ++
=$14					KWD_MINUS = $14                  ; $14 -
=$15					KWD_MINUSMINUS = $15             ; $15 --
=$16					KWD_DOT = $16                    ; $16 .
=$17					KWD_SLASH = $17                  ; $17 /
=$18					KWD_SEMICOLON = $18              ; $18 ;
=$19					KWD_LESS = $19                   ; $19 <
=$1a					KWD_LESSLESS = $1a               ; $1a <<
=$1b					KWD_LESSEQUAL = $1b              ; $1b <=
=$1c					KWD_LESSGREATER = $1c            ; $1c <>
=$1d					KWD_EQUAL = $1d                  ; $1d =
=$1e					KWD_GREATER = $1e                ; $1e >
=$1f					KWD_GREATEREQUAL = $1f           ; $1f >=
=$20					KWD_GREATERGREATER = $20         ; $20 >>
=$21					KWD_AT = $21                     ; $21 @
=$22					KWD_ABS = $22                    ; $22 ABS
=$23					KWD_ALLOC = $23                  ; $23 ALLOC
=$24					KWD_AND = $24                    ; $24 AND
=$25					KWD_ASSERT = $25                 ; $25 ASSERT
=$26					KWD_CPLING = $26                 ; $26 C!
=$27					KWD_CAT = $27                    ; $27 C@
=$28					KWD_CLR = $28                    ; $28 CLR
=$29					KWD_DEF = $29                    ; $29 DEF
=$2a					KWD_DROP = $2a                   ; $2a DROP
=$2b					KWD_DUP = $2b                    ; $2b DUP
=$2c					KWD_ELSE = $2c                   ; $2c ELSE
=$2d					KWD_END = $2d                    ; $2d END
=$2e					KWD_ENDIF = $2e                  ; $2e ENDIF
=$2f					KWD_FOR = $2f                    ; $2f FOR
=$30					KWD_IF = $30                     ; $30 IF
=$31					KWD_INDEX = $31                  ; $31 INDEX
=$32					KWD_LIST = $32                   ; $32 LIST
=$33					KWD_LOAD = $33                   ; $33 LOAD
=$34					KWD_MOD = $34                    ; $34 MOD
=$35					KWD_NEGATE = $35                 ; $35 NEGATE
=$36					KWD_NEW = $36                    ; $36 NEW
=$37					KWD_NEXT = $37                   ; $37 NEXT
=$38					KWD_NIP = $38                    ; $38 NIP
=$39					KWD_NOT = $39                    ; $39 NOT
=$3a					KWD_OLD = $3a                    ; $3a OLD
=$3b					KWD_OR = $3b                     ; $3b OR
=$3c					KWD_OVER = $3c                   ; $3c OVER
=$3d					KWD_RENUMBER = $3d               ; $3d RENUMBER
=$3e					KWD_REPEAT = $3e                 ; $3e REPEAT
=$3f					KWD_RETURN = $3f                 ; $3f RETURN
=$40					KWD_RUN = $40                    ; $40 RUN
=$41					KWD_SAVE = $41                   ; $41 SAVE
=$42					KWD_SHL = $42                    ; $42 SHL
=$43					KWD_SHR = $43                    ; $43 SHR
=$44					KWD_STOP = $44                   ; $44 STOP
=$45					KWD_SWAP = $45                   ; $45 SWAP
=$46					KWD_SYS = $46                    ; $46 SYS
=$47					KWD_UNTIL = $47                  ; $47 UNTIL
=$48					KWD_WPLING = $48                 ; $48 W!
=$49					KWD_WAT = $49                    ; $49 W@
=$4a					KWD_XOR = $4a                    ; $4a XOR
=$4b					KWD_LSQPAREN = $4b               ; $4b [
=$4c					KWD_RSQPAREN = $4c               ; $4c ]
=$4d					KWD_HAT = $4d                    ; $4d ^
=$4e					KWD_CONSTANT_PLUS = $4e          ; $4e {+}
=$4f					KWD_CONSTANT_MINUS = $4f         ; $4f {-}

;******  Return to file: main.asm


;******  Processing file: system/extern.asm

.a276					ExternInitialise:
.a276	a9 07		lda #$07			lda 	#$07 						; set colour
.a278	8d 86 02	sta $0286			sta 	646
.a27b	a9 0e		lda #$0e			lda 	#14							; lower case
.a27d	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a280	a9 93		lda #$93			lda 	#147 						; clear screen
.a282	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a285	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a287	4c a1 a2	jmp $a2a1			jmp 	ExternColour
.a28a					ExternCheckBreak:
.a28a	da		phx				phx 								; make sure we keep XY
.a28b	5a		phy				phy
.a28c	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a28f	f0 03		beq $a294			beq		_ECBExit 					; stopped
.a291	7a		ply				ply 								; restore and exit.
.a292	fa		plx				plx
.a293	60		rts				rts
.a294					_ECBExit:
.a294	4c 33 a0	jmp $a033			jmp 	WarmStart
.a297					ExternPrint:
.a297	48		pha				pha
.a298	da		phx				phx
.a299	5a		phy				phy
.a29a	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a29d	7a		ply				ply
.a29e	fa		plx				plx
.a29f	68		pla				pla
.a2a0	60		rts				rts
.a2a1					ExternColour:
.a2a1	48		pha				pha
.a2a2	da		phx				phx
.a2a3	aa		tax				tax
.a2a4	bd ad a2	lda $a2ad,x			lda 	_ECTable,x
.a2a7	20 97 a2	jsr $a297			jsr 	ExternPrint
.a2aa	fa		plx				plx
.a2ab	68		pla				pla
.a2ac	60		rts				rts
.a2ad					_ECTable:
>a2ad	90						.byte 	144
>a2ae	1c						.byte 	28
>a2af	1e						.byte 	30
>a2b0	9e						.byte 	158
>a2b1	1f						.byte 	31
>a2b2	9c						.byte 	156
>a2b3	9f						.byte 	159
>a2b4	05						.byte 	5
.a2b5					ExternInput:
.a2b5	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a2b7	85 14		sta $14				sta 	zTemp0
.a2b9	a9 09		lda #$09			lda 	#(InputBuffer >> 8)
.a2bb	85 15		sta $15				sta 	zTemp0+1
.a2bd	a9 07		lda #$07			lda 	#COL_WHITE
.a2bf	20 a1 a2	jsr $a2a1			jsr 	ExternColour
.a2c2	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a2c5	c9 0d		cmp #$0d			cmp 	#13
.a2c7	f0 0a		beq $a2d3			beq 	_EIExit
.a2c9	92 14		sta ($14)			sta 	(zTemp0)
.a2cb	e6 14		inc $14				inc 	zTemp0
.a2cd	d0 f3		bne $a2c2			bne 	_EIRead
.a2cf	e6 15		inc $15				inc 	zTemp0+1
.a2d1	80 ef		bra $a2c2			bra 	_EIRead
.a2d3	a9 00		lda #$00	_EIExit:lda 	#0
.a2d5	92 14		sta ($14)			sta 	(zTemp0)
.a2d7	a9 0d		lda #$0d			lda 	#13
.a2d9	20 97 a2	jsr $a297			jsr 	ExternPrint
.a2dc	60		rts				rts
.a2dd					ExternSave:
.a2dd	da		phx				phx
.a2de	5a		phy				phy
.a2df	20 47 a3	jsr $a347			jsr 	EXGetLength 				; get length of file into A
.a2e2	a6 14		ldx $14				ldx 	zTemp0
.a2e4	a4 15		ldy $15				ldy 	zTemp0+1
.a2e6	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a2e9	a2 01		ldx #$01			ldx 	#1	 						; device #8
.a2eb	a0 00		ldy #$00			ldy 	#0
.a2ed	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a2f0	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; start address
.a2f2	85 c1		sta $c1				sta 	$C1
.a2f4	a9 11		lda #$11			lda 	#ProgramStart >> 8
.a2f6	85 c2		sta $c2				sta 	$C2
.a2f8	ae 88 10	ldx $1088			ldx 	VarMemory 					; end address
.a2fb	ac 89 10	ldy $1089			ldy 	VarMemory+1
.a2fe	a9 c1		lda #$c1			lda 	#$C1
.a300	20 d8 ff	jsr $ffd8			jsr 	$FFD8 						; save
.a303	b0 03		bcs $a308			bcs 	_ESSave
.a305	7a		ply				ply
.a306	fa		plx				plx
.a307	60		rts				rts
.a308					_ESSave:
.a308	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>a30b	53 41 56 45 20 46 41 49				.text 	"SAVE FAILED",0
>a313	4c 45 44 00
.a317					ExternLoad:
.a317	da		phx				phx
.a318	5a		phy				phy
.a319	20 47 a3	jsr $a347			jsr 	EXGetLength 				; get length of file into A
.a31c	a6 14		ldx $14				ldx 	zTemp0
.a31e	a4 15		ldy $15				ldy 	zTemp0+1
.a320	20 bd ff	jsr $ffbd			jsr 	$FFBD 						; set name
.a323	a2 01		ldx #$01			ldx 	#1	 						; device #8
.a325	a0 00		ldy #$00			ldy 	#0
.a327	20 ba ff	jsr $ffba			jsr 	$FFBA 						; set LFS
.a32a	a2 00		ldx #$00			ldx 	#ProgramStart & $FF 		; start address
.a32c	a0 11		ldy #$11			ldy 	#ProgramStart >> 8
.a32e	a9 00		lda #$00			lda 	#0 							; load command
.a330	20 d5 ff	jsr $ffd5			jsr 	$FFD5
.a333	b0 03		bcs $a338			bcs 	_ESLoad
.a335	7a		ply				ply
.a336	fa		plx				plx
.a337	60		rts				rts
.a338					_ESLoad:
.a338	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>a33b	4c 4f 41 44 20 46 41 49				.text 	"LOAD FAILED",0
>a343	4c 45 44 00
.a347					EXGetLength:
.a347	a0 ff		ldy #$ff			ldy 	#255
.a349	c8		iny		_EXGL:	iny
.a34a	b1 14		lda ($14),y			lda 	(zTemp0),y
.a34c	d0 fb		bne $a349			bne 	_EXGL
.a34e	98		tya				tya
.a34f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/execute.asm

.a350					EXNextLine:
.a350	b2 10		lda ($10)			lda 	(codePtr) 					; is it run from the buffer (offset 0)
.a352	f0 0f		beq $a363			beq 	_EXNLWarmStart
.a354	18		clc				clc 								; advance code pointer to next line
.a355	65 10		adc $10				adc 	codePtr
.a357	85 10		sta $10				sta 	codePtr
.a359	90 02		bcc $a35d			bcc 	_EXNLNoBump
.a35b	e6 11		inc $11				inc 	codePtr+1
.a35d					_EXNLNoBump:
.a35d	a0 03		ldy #$03			ldy 	#3 							; position in that line
.a35f	b2 10		lda ($10)			lda 	(codePtr) 					; read offset
.a361	d0 03		bne $a366			bne 	Execute 					; not end of program
.a363					_EXNLWarmStart:
.a363	4c f5 af	jmp $aff5			jmp 	System_END
.a366	e0 fc		cpx #$fc	Execute:cpx 	#$FC  						; stack overflow
.a368	b0 1c		bcs $a386			bcs 	EXStackOverflow
.a36a	ee 22 08	inc $0822			inc 	BreakCount 					; break occasionally. too slow otherwise.
.a36d	d0 03		bne $a372			bne 	_EXNoBreak
.a36f	20 8a a2	jsr $a28a			jsr 	ExternCheckBreak
.a372					_EXNoBreak:
.a372	b1 10		lda ($10),y			lda 	(codePtr),y 				; load the character
.a374	f0 da		beq $a350			beq 	EXNextLine 					; reached end of the line.
.a376	c8		iny				iny 								; advance pointer.
.a377	c9 10		cmp #$10			cmp 	#$10 						; is it 01-0F, which means a string/comment ?
.a379	90 39		bcc $a3b4			bcc 	EXStringComment
.a37b	c9 80		cmp #$80			cmp 	#$80 						; if it 10-7F, token
.a37d	90 1f		bcc $a39e			bcc 	EXTokenExecute
.a37f	c9 c0		cmp #$c0			cmp 	#$C0 						; is it a numeric constant 80-BF
.a381	90 15		bcc $a398			bcc 	EXPushConstant
.a383	4c de b0	jmp $b0de			jmp 	Identifier 					; it's an identifier C0-FF
.a386					EXStackOverflow:
.a386	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>a389	53 54 41 43 4b 20 4f 56				.text 	"STACK OVERFLOW",0
>a391	45 52 46 4c 4f 57 00
.a398					EXPushConstant:
.a398	88		dey				dey
.a399	20 e3 a3	jsr $a3e3			jsr 	ExtractIntegerToTOS 		; extract integer
.a39c	80 c8		bra $a366			bra 	Execute
.a39e					EXTokenExecute:
.a39e	0a		asl a				asl 	a 							; double token, also clears carry
.a39f	da		phx				phx 								; save X, put token x 2 in X
.a3a0	aa		tax				tax
.a3a1	bd d6 a1	lda $a1d6,x			lda 	KeywordVectorTable-$20,x 	; copy vector. The -$20 is because the tokens
.a3a4	85 14		sta $14				sta 	zTemp0 						; start at $10.
.a3a6	bd d7 a1	lda $a1d7,x			lda 	KeywordVectorTable-$20+1,x
.a3a9	85 15		sta $15				sta 	zTemp0+1
.a3ab	fa		plx				plx 								; restore X
.a3ac	20 b1 a3	jsr $a3b1			jsr 	_EXTCall 					; call the routine
.a3af	80 b5		bra $a366			bra 	Execute
.a3b1					_EXTCall:
.a3b1	6c 14 00	jmp ($0014)			jmp 	(zTemp0)
.a3b4					EXStringComment:
.a3b4	c9 02		cmp #$02			cmp 	#$02 						; 02 is the token for single quoted string
.a3b6	f0 15		beq $a3cd			beq 	EXStringSkip 				; (comment), so just skip it.
.a3b8	e8		inx				inx 								; push Y + 1 + codePtr on the stack
.a3b9	98		tya				tya
.a3ba	38		sec				sec
.a3bb	65 10		adc $10				adc 	codePtr
.a3bd	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a3c0	a5 11		lda $11				lda 	codePtr+1
.a3c2	69 00		adc #$00			adc 	#0
.a3c4	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a3c7	9e 00 0e	stz $0e00,x			stz 	stack2,x 					; clear the upper 2 bytes.
.a3ca	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a3cd					EXStringSkip:
.a3cd	98		tya				tya 								; the current position in A
.a3ce	18		clc				clc
.a3cf	71 10		adc ($10),y			adc 	(codePtr),y					; add the total length
.a3d1	a8		tay				tay 			 					; and make that the current position.
.a3d2	88		dey				dey 								; back one because of the initial skip
.a3d3	80 91		bra $a366			bra 	Execute
.a3d5					EXShiftTOSRight:
.a3d5	4a		lsr a				lsr 	a
.a3d6	7e 00 0f	ror $0f00,x			ror 	stack3,x
.a3d9	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a3dc	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a3df	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a3e2	60		rts				rts
.a3e3					ExtractIntegerToTOS:
.a3e3	b1 10		lda ($10),y			lda 	(codePtr),y
.a3e5	c8		iny				iny
.a3e6	e8		inx				inx 								; make stack space
.a3e7	29 3f		and #$3f			and 	#$3F 						; to start with, it's just that value
.a3e9	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a3ec	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a3ef	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a3f2	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a3f5					_EXConstantLoop:
.a3f5	b1 10		lda ($10),y			lda 	(codePtr),y 				; look at next ?
.a3f7	29 c0		and #$c0			and 	#$C0 						; in range 80-FF e.g. 10xx xxxx
.a3f9	c9 80		cmp #$80			cmp 	#$80
.a3fb	d0 2d		bne $a42a			bne		_EXDone 					; no then exit
.a3fd	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; put the MSB in A
.a400	48		pha				pha
.a401	bd 00 0e	lda $0e00,x			lda 	stack2,x 					; shift every byte up one, e.g. x 256
.a404	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a407	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a40a	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a40d	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a410	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a413	9e 00 0c	stz $0c00,x			stz 	stack0,x
.a416	68		pla				pla
.a417	20 d5 a3	jsr $a3d5			jsr 	EXShiftTOSRight 				; shift the whole A:Top of Stack right twice
.a41a	20 d5 a3	jsr $a3d5			jsr 	EXShiftTOSRight				; which will be x64
.a41d	b1 10		lda ($10),y			lda 	(codePtr),y 				; get and skip constant shift
.a41f	c8		iny				iny
.a420	29 3f		and #$3f			and 	#$3F
.a422	1d 00 0c	ora $0c00,x			ora 	stack0,x 					; or into low byte
.a425	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a428	80 cb		bra $a3f5			bra 	_EXConstantLoop
.a42a	b1 10		lda ($10),y	_EXDone:lda 	(codePtr),y
.a42c	c8		iny				iny 								; skip over unary constant + -
.a42d	c9 4f		cmp #$4f			cmp 	#KWD_CONSTANT_MINUS
.a42f	d0 03		bne $a434			bne 	_EXPositive
.a431	4c 96 aa	jmp $aa96			jmp 	Unary_Negate
.a434					_EXPositive:
.a434	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/identifier.asm

.a435					IdentifierSearch:
.a435	b1 10		lda ($10),y			lda 	(codePtr),y 				; get first character
.a437	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a fast var ?
.a439	90 12		bcc $a44d			bcc 	_ISSlow
.a43b	c9 fa		cmp #$fa			cmp 	#$F9+1
.a43d	b0 0e		bcs $a44d			bcs 	_ISSlow
.a43f	29 1f		and #$1f			and 	#$1F 						; index, then x 4
.a441	0a		asl a				asl 	a
.a442	0a		asl a				asl		a
.a443	85 22		sta $22				sta 	idDataAddr					; set up addres
.a445	a9 10		lda #$10			lda 	#AZVariables >> 8
.a447	85 23		sta $23				sta 	idDataAddr+1
.a449	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; type
.a44b	38		sec				sec 								; return with CS.
.a44c	60		rts				rts
.a44d					_ISSlow:
.a44d	20 09 a5	jsr $a509			jsr 	IdentifierSetupHashPtr 		; set up hash table.
.a450	98		tya				tya 								; set (zTemp1) to point to the
.a451	18		clc				clc 	 							; identifier to be searched.
.a452	65 10		adc $10				adc 	codePtr
.a454	85 16		sta $16				sta 	zTemp1
.a456	a5 11		lda $11				lda 	codePtr+1
.a458	69 00		adc #$00			adc 	#0
.a45a	85 17		sta $17				sta 	zTemp1+1
.a45c	5a		phy				phy 								; save Y
.a45d	b2 14		lda ($14)	_ISLoop:lda 	(zTemp0)					; follow link
.a45f	48		pha				pha
.a460	a0 01		ldy #$01			ldy 	#1
.a462	b1 14		lda ($14),y			lda 	(zTemp0),y
.a464	85 15		sta $15				sta 	zTemp0+1
.a466	68		pla				pla
.a467	85 14		sta $14				sta 	zTemp0
.a469	05 15		ora $15				ora 	zTemp0+1 					; if zero, then fail.
.a46b	f0 2c		beq $a499			beq 	_ISFail
.a46d	a0 06		ldy #$06			ldy 	#6 							; copy name into zTemp2
.a46f	b1 14		lda ($14),y			lda 	(zTemp0),y
.a471	85 18		sta $18				sta 	zTemp2
.a473	c8		iny				iny
.a474	b1 14		lda ($14),y			lda 	(zTemp0),y
.a476	85 19		sta $19				sta 	zTemp2+1
.a478	a0 00		ldy #$00			ldy 	#0 							; compare names at zTemp1/zTemp2
.a47a					_ISCompare:
.a47a	b1 16		lda ($16),y			lda 	(zTemp1),y
.a47c	d1 18		cmp ($18),y			cmp 	(zTemp2),y
.a47e	d0 dd		bne $a45d			bne		_ISLoop 					; different ?
.a480	c8		iny				iny
.a481	c9 e0		cmp #$e0			cmp 	#$E0 						; until end identifiers matched.
.a483	90 f5		bcc $a47a			bcc 	_ISCompare
.a485	18		clc				clc 								; set up the data pointer
.a486	a5 14		lda $14				lda 	zTemp0
.a488	69 02		adc #$02			adc 	#2
.a48a	85 22		sta $22				sta 	idDataAddr
.a48c	a5 15		lda $15				lda 	zTemp0+1
.a48e	69 00		adc #$00			adc		#0
.a490	85 23		sta $23				sta 	idDataAddr+1
.a492	a0 09		ldy #$09			ldy 	#9 							; get the type
.a494	b1 14		lda ($14),y			lda 	(zTemp0),y
.a496	7a		ply				ply
.a497	38		sec				sec
.a498	60		rts				rts
.a499					_ISFail:
.a499	7a		ply				ply
.a49a	18		clc				clc
.a49b	60		rts				rts
.a49c					IdentifierCreate:
.a49c	5a		phy				phy 								; save Y
.a49d	48		pha				pha 								; save type on stack
.a49e	20 09 a5	jsr $a509			jsr 	IdentifierSetUpHashPtr 		; zTemp0 = address of table.
.a4a1	ad 88 10	lda $1088			lda 	VarMemory 					; copy VarMemory to zTemp1
.a4a4	85 16		sta $16				sta 	zTemp1
.a4a6	ad 89 10	lda $1089			lda 	VarMemory+1
.a4a9	85 17		sta $17				sta 	zTemp1+1
.a4ab	5a		phy				phy 								; save Y (code offset)
.a4ac	a0 00		ldy #$00			ldy 	#0 							; copy next link in.
.a4ae	b1 14		lda ($14),y			lda 	(zTemp0),y 					; +0,+1 is the link.
.a4b0	91 16		sta ($16),y			sta 	(zTemp1),y
.a4b2	c8		iny				iny
.a4b3	b1 14		lda ($14),y			lda 	(zTemp0),y
.a4b5	91 16		sta ($16),y			sta 	(zTemp1),y
.a4b7	c8		iny				iny
.a4b8					_IDCErase:
.a4b8	a9 00		lda #$00			lda 	#0
.a4ba	91 16		sta ($16),y			sta 	(zTemp1),y
.a4bc	c8		iny				iny
.a4bd	c0 06		cpy #$06			cpy 	#6
.a4bf	d0 f7		bne $a4b8			bne 	_IDCErase
.a4c1	68		pla				pla 								; original Y
.a4c2	18		clc				clc
.a4c3	65 10		adc $10				adc		codePtr 					; address of identifier +6,+7
.a4c5	91 16		sta ($16),y			sta 	(zTemp1),y
.a4c7	c8		iny				iny
.a4c8	a5 11		lda $11				lda 	codePtr+1
.a4ca	69 00		adc #$00			adc 	#0
.a4cc	91 16		sta ($16),y			sta 	(zTemp1),y
.a4ce	c8		iny				iny
.a4cf	a9 00		lda #$00			lda 	#0 							; +8 bank (0)
.a4d1	91 16		sta ($16),y			sta 	(zTemp1),y
.a4d3	68		pla				pla 								; restore type
.a4d4	c8		iny				iny
.a4d5	91 16		sta ($16),y			sta 	(zTemp1),y 					; store at +9
.a4d7	c8		iny				iny
.a4d8	98		tya				tya									; add offset to VarMemory
.a4d9	18		clc				clc
.a4da	6d 88 10	adc $1088			adc 	VarMemory
.a4dd	8d 88 10	sta $1088			sta 	VarMemory
.a4e0	ad 89 10	lda $1089			lda 	VarMemory+1
.a4e3	69 00		adc #$00			adc 	#0
.a4e5	8d 89 10	sta $1089			sta 	VarMemory+1
.a4e8	cd 8b 10	cmp $108b			cmp 	AllocMemory+1 				; in the same page as allocated ?
.a4eb	f0 19		beq $a506			beq 	_IDCMemory
.a4ed	a5 16		lda $16				lda 	zTemp1 						; overwrite hash table entry
.a4ef	92 14		sta ($14)			sta 	(zTemp0)
.a4f1	a0 01		ldy #$01			ldy 	#1
.a4f3	a5 17		lda $17				lda 	zTemp1+1
.a4f5	91 14		sta ($14),y			sta 	(zTemp0),y
.a4f7	a5 16		lda $16				lda 	zTemp1 						; set up idDataAddr
.a4f9	18		clc				clc
.a4fa	69 02		adc #$02			adc 	#2
.a4fc	85 22		sta $22				sta 	idDataAddr
.a4fe	a5 17		lda $17				lda 	zTemp1+1
.a500	69 00		adc #$00			adc 	#0
.a502	85 23		sta $23				sta 	idDataAddr+1
.a504	7a		ply				ply 								; restore Y and exit
.a505	60		rts				rts
.a506					_IDCMemory:
.a506	4c c0 a5	jmp $a5c0			jmp 	OutOfMemoryError
.a509					IdentifierSetUpHashPtr:
.a509	b1 10		lda ($10),y			lda 	(codePtr),y 				; get the first operator
.a50b	29 0f		and #$0f			and 	#(HashTableSize-1)			; convert to a hash index
.a50d	0a		asl a				asl 	a 							; convert to an offset, clc
.a50e	69 68		adc #$68			adc 	#(HashTable & $FF)			; set zTemp0 to point to hashTable entry
.a510	85 14		sta $14				sta 	zTemp0
.a512	a9 10		lda #$10			lda 	#(HashTable >> 8) 			; assumes table in one page
.a514	85 15		sta $15				sta 	zTemp0+1
.a516	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/reset.asm

.a517					ResetCodePointer:
.a517	48		pha				pha
.a518	a9 11		lda #$11			lda 	#ProgramStart >> 8 			; set up line pointer
.a51a	85 11		sta $11				sta 	codePtr+1
.a51c	64 10		stz $10				stz 	codePtr
.a51e	a0 03		ldy #$03			ldy 	#3 							; point to first piece of code
.a520	68		pla				pla
.a521	60		rts				rts
.a522					ResetForRun:
.a522	48		pha				pha
.a523	5a		phy				phy
.a524	a2 00		ldx #$00			ldx 	#0 							; erase the hash table
.a526					_RRErase:
.a526	bd ea b3	lda $b3ea,x			lda 	DefaultHashTable,x
.a529	9d 68 10	sta $1068,x			sta		HashTable,x
.a52c	e8		inx				inx
.a52d	e0 20		cpx #$20			cpx 	#HashTableSize * 2
.a52f	d0 f5		bne $a526			bne 	_RRErase
.a531	20 48 a5	jsr $a548			jsr 	ResetVarMemory
.a534	a9 ff		lda #$ff			lda 	#StructureStack & $FF
.a536	85 12		sta $12				sta 	StructSP
.a538	a9 0b		lda #$0b			lda 	#StructureStack >> 8
.a53a	85 13		sta $13				sta 	StructSP+1
.a53c	a9 ff		lda #$ff			lda 	#$FF 						; put a value that will fail structure tests
.a53e	92 12		sta ($12)			sta 	(StructSP)
.a540	20 6f a5	jsr $a56f			jsr 	ProcedureScan
.a543	a2 00		ldx #$00			ldx 	#0 							; empty the stack
.a545	7a		ply				ply
.a546	68		pla				pla
.a547	60		rts				rts
.a548					ResetVarMemory:
.a548	a9 00		lda #$00			lda 	#ProgramStart & $FF
.a54a	85 14		sta $14				sta 	zTemp0
.a54c	a9 11		lda #$11			lda 	#ProgramStart >> 8
.a54e	85 15		sta $15				sta 	zTemp0+1
.a550					_RRFindEnd:
.a550	b2 14		lda ($14)			lda 	(zTemp0)					; at end ?
.a552	f0 0b		beq $a55f			beq 	_RRFoundEnd
.a554	18		clc				clc 								; no, add offset to pointer.
.a555	65 14		adc $14				adc 	zTemp0
.a557	85 14		sta $14				sta 	zTemp0
.a559	90 f5		bcc $a550			bcc 	_RRFindEnd
.a55b	e6 15		inc $15				inc 	zTemp0+1
.a55d	80 f1		bra $a550			bra 	_RRFindEnd
.a55f					_RRFoundEnd:
.a55f	18		clc				clc 								; add 1 to this, as it points to the last
.a560	a5 14		lda $14				lda 	zTemp0 					; offset, and store in Variable Memory pointer
.a562	69 01		adc #$01			adc 	#1
.a564	8d 88 10	sta $1088			sta 	VarMemory
.a567	a5 15		lda $15				lda 	zTemp0+1
.a569	69 00		adc #$00			adc 	#0
.a56b	8d 89 10	sta $1089			sta 	VarMemory+1
.a56e	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/scan.asm

.a56f					ProcedureScan:
.a56f	20 17 a5	jsr $a517			jsr 	ResetCodePointer 			; reset the code pointer.
.a572	b2 10		lda ($10)	_PSMain:lda 	(codePtr)					; check if end
.a574	f0 39		beq $a5af			beq 	_PSExit
.a576	a0 03		ldy #$03			ldy 	#3 							; start of line
.a578	b1 10		lda ($10),y			lda 	(codePtr),y 				; skip over spaces
.a57a	c9 29		cmp #$29			cmp 	#KWD_DEF 					; first thing is DEF ?
.a57c	d0 24		bne $a5a2			bne 	_PSNext
.a57e	c8		iny				iny 								; skip over def first
.a57f	b1 10		lda ($10),y			lda 	(codePtr),y 				; next, must be C0-DF - a multi char ID
.a581	29 e0		and #$e0			and 	#$E0
.a583	c9 c0		cmp #$c0			cmp 	#$C0
.a585	d0 1b		bne $a5a2			bne 	_PSNext 					; otherwise ignore it.
.a587	a9 50		lda #$50			lda 	#IDT_PROCEDURE 				; create a procedure
.a589	20 9c a4	jsr $a49c			jsr 	IdentifierCreate
.a58c					_PSSkipIdentifier:
.a58c	b1 10		lda ($10),y			lda 	(codePtr),y
.a58e	c9 e0		cmp #$e0			cmp 	#$E0
.a590	c8		iny				iny
.a591	90 f9		bcc $a58c			bcc 	_PSSkipIdentifier
.a593	98		tya				tya  								; save the address in the data slot.
.a594	a0 03		ldy #$03			ldy 	#3
.a596	91 22		sta ($22),y			sta 	(idDataAddr),y 				; offset
.a598	a5 10		lda $10				lda 	codePtr
.a59a	92 22		sta ($22)			sta 	(idDataAddr) 				; position.low
.a59c	a5 11		lda $11				lda 	codePtr+1
.a59e	a0 01		ldy #$01			ldy 	#1
.a5a0	91 22		sta ($22),y			sta 	(idDataAddr),y 				; position.high
.a5a2					_PSNext:
.a5a2	18		clc				clc 								; go to next
.a5a3	b2 10		lda ($10)			lda 	(codePtr)
.a5a5	65 10		adc $10				adc 	codePtr
.a5a7	85 10		sta $10				sta 	codeptr
.a5a9	90 c7		bcc $a572			bcc 	_PSMain
.a5ab	e6 11		inc $11				inc 	codePtr+1
.a5ad	80 c3		bra $a572			bra 	_PSMain
.a5af					_PSExit:
.a5af	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/error.asm

.a5b0					SyntaxError:
.a5b0	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>a5b3	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>a5bb	52 52 4f 52 00
.a5c0					OutOfMemoryError:
.a5c0	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>a5c3	4f 55 54 20 4f 46 20 4d				.text 	"OUT OF MEMORY",0
>a5cb	45 4d 4f 52 59 00
.a5d1					ErrorHandler:
.a5d1	68		pla				pla 								; pop message address
.a5d2	85 14		sta $14				sta 	zTemp0
.a5d4	68		pla				pla
.a5d5	85 15		sta $15				sta 	zTemp0+1
.a5d7	a9 05		lda #$05			lda 	#CTH_ERROR
.a5d9	20 a1 a2	jsr $a2a1			jsr 	ExternColour
.a5dc	a0 01		ldy #$01			ldy 	#1 							; print it
.a5de					_ErrorPrint:
.a5de	b1 14		lda ($14),y			lda 	(zTemp0),y
.a5e0	20 97 a2	jsr $a297			jsr		ExternPrint
.a5e3	c8		iny				iny
.a5e4	b1 14		lda ($14),y			lda 	(zTemp0),y
.a5e6	d0 f6		bne $a5de			bne 	_ErrorPrint
.a5e8	a0 01		ldy #$01			ldy 	#1 							; check if line# 0
.a5ea	b1 10		lda ($10),y			lda		(codePtr),y
.a5ec	c8		iny				iny
.a5ed	12 10		ora ($10)			ora 	(codePtr)
.a5ef	f0 1c		beq $a60d			beq 	_ErrorNoLine 				; if so, skip
.a5f1	a9 20		lda #$20			lda 	#32
.a5f3	20 97 a2	jsr $a297			jsr 	ExternPrint
.a5f6	a9 40		lda #$40			lda 	#'@'
.a5f8	20 97 a2	jsr $a297			jsr 	ExternPrint
.a5fb	a9 20		lda #$20			lda 	#32
.a5fd	20 97 a2	jsr $a297			jsr 	ExternPrint
.a600	a0 01		ldy #$01			ldy 	#1 							; load current line into YA
.a602	b1 10		lda ($10),y			lda 	(codePtr),y
.a604	48		pha				pha
.a605	c8		iny				iny
.a606	b1 10		lda ($10),y			lda 	(codePtr),y
.a608	a8		tay				tay
.a609	68		pla				pla
.a60a	20 15 a6	jsr $a615			jsr 	ErrorPrint16 				; print YA as unsigned 16 bit integer.
.a60d					_ErrorNoLine:
.a60d	a9 0d		lda #$0d			lda 	#13							; new line
.a60f	20 97 a2	jsr $a297			jsr 	ExternPrint
.a612	4c 33 a0	jmp $a033			jmp 	WarmStart
.a615					ErrorPrint16:
.a615	da		phx				phx
.a616	e8		inx				inx 								; space on stack
.a617	9d 00 0c	sta $0c00,x			sta 	stack0,x					; save on TOS
.a61a	98		tya				tya
.a61b	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a61e	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a621	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a624	20 3a a6	jsr $a63a			jsr 	IntegerToString 			; convert to string.
.a627	fa		plx				plx
.a628					ErrorPrintIntegerBuffer:
.a628	da		phx				phx
.a629	a2 00		ldx #$00			ldx 	#0
.a62b					_EP16Loop:
.a62b	bd 00 08	lda $0800,x			lda 	SBuffer,x
.a62e	20 97 a2	jsr $a297			jsr 	ExternPrint
.a631	e8		inx				inx
.a632	bd 00 08	lda $0800,x			lda 	SBuffer,x
.a635	d0 f4		bne $a62b			bne 	_EP16Loop
.a637	8a		txa				txa
.a638	fa		plx				plx
.a639	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/inttostr.asm

.a63a					IntegerToString:
.a63a	48		pha				pha
.a63b	5a		phy				phy
.a63c	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a63f	48		pha				pha
.a640	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a643	48		pha				pha
.a644	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a647	48		pha				pha
.a648	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a64b	48		pha				pha
.a64c	bd 00 0f	lda $0f00,x			lda 		stack3,x 				; check -ve
.a64f	10 08		bpl $a659			bpl 		_ITSNotMinus
.a651	a9 2d		lda #$2d			lda 		#"-"
.a653	20 fb a6	jsr $a6fb			jsr 		ITSOutputCharacter
.a656	20 96 aa	jsr $aa96			jsr 		Unary_Negate
.a659					_ITSNotMinus:
.a659	9c 20 08	stz $0820			stz 		SBPosition 				; reset string buffer position
.a65c	9c 24 08	stz $0824			stz 		NumSuppress 			; clear zero suppression flag
.a65f	8a		txa				txa 								; use Y for the integer index.
.a660	a8		tay				tay
.a661	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.a663					_ITSNextSubtractor:
.a663	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.a665	8d 21 08	sta $0821			sta 		NumConvCount
.a668					_ITSSubtract:
.a668	38		sec				sec
.a669	b9 00 0c	lda $0c00,y			lda 		stack0,y 			; subtract number and push on stack
.a66c	fd d7 a6	sbc $a6d7,x			sbc 		_ITSSubtractors+0,x 	; only update if actually can subtract it.
.a66f	48		pha				pha
.a670	b9 00 0d	lda $0d00,y			lda 		stack1,y
.a673	fd d8 a6	sbc $a6d8,x			sbc 		_ITSSubtractors+1,x
.a676	48		pha				pha
.a677	b9 00 0e	lda $0e00,y			lda 		stack2,y
.a67a	fd d9 a6	sbc $a6d9,x			sbc 		_ITSSubtractors+2,x
.a67d	48		pha				pha
.a67e	b9 00 0f	lda $0f00,y			lda 		stack3,y
.a681	fd da a6	sbc $a6da,x			sbc 		_ITSSubtractors+3,x
.a684	90 14		bcc $a69a			bcc 		_ITSCantSubtract 		; if CC, then gone too far, can't subtract
.a686	99 00 0f	sta $0f00,y			sta 		stack3,y 		; save subtract off stack as it's okay
.a689	68		pla				pla
.a68a	99 00 0e	sta $0e00,y			sta 		stack2,y
.a68d	68		pla				pla
.a68e	99 00 0d	sta $0d00,y			sta 		stack1,y
.a691	68		pla				pla
.a692	99 00 0c	sta $0c00,y			sta 		stack0,y
.a695	ee 21 08	inc $0821			inc 		NumConvCount 			; bump count.
.a698	80 ce		bra $a668			bra 		_ITSSubtract 			; go round again.
.a69a					_ITSCantSubtract:
.a69a	68		pla				pla 								; throw away interim answers
.a69b	68		pla				pla 								; (the subtraction that failed)
.a69c	68		pla				pla
.a69d	ad 21 08	lda $0821			lda 		NumConvCount 			; if not zero then no suppression check
.a6a0	c9 30		cmp #$30			cmp 		#"0"
.a6a2	d0 05		bne $a6a9			bne 		_ITSOutputDigit
.a6a4	ad 24 08	lda $0824			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.a6a7	f0 09		beq $a6b2			beq	 		_ITSGoNextSubtractor
.a6a9					_ITSOutputDigit:
.a6a9	ce 24 08	dec $0824			dec 		NumSuppress 			; suppression check will be non-zero from now on.
.a6ac	ad 21 08	lda $0821			lda 		NumConvCount 			; count of subtractions
.a6af	20 fb a6	jsr $a6fb			jsr 		ITSOutputCharacter 		; output it.
.a6b2					_ITSGoNextSubtractor:
.a6b2	e8		inx				inx 								; next dword in subtractor table.
.a6b3	e8		inx				inx
.a6b4	e8		inx				inx
.a6b5	e8		inx				inx
.a6b6	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.a6b8	d0 a9		bne $a663			bne 		_ITSNextSubtractor 		; do all the subtractors.
.a6ba	98		tya				tya 								; X is back as the mantissa index
.a6bb	aa		tax				tax
.a6bc	bd 00 0c	lda $0c00,x			lda 		stack0,x 		; and the last digit is left.
.a6bf	09 30		ora #$30			ora 		#"0"
.a6c1	20 fb a6	jsr $a6fb			jsr 		ITSOutputCharacter
.a6c4	68		pla				pla
.a6c5	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a6c8	68		pla				pla
.a6c9	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a6cc	68		pla				pla
.a6cd	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a6d0	68		pla				pla
.a6d1	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a6d4	7a		ply				ply 								; and exit
.a6d5	68		pla				pla
.a6d6	60		rts				rts
.a6d7					_ITSSubtractors:
>a6d7	00 ca 9a 3b					.dword 		1000000000
>a6db	00 e1 f5 05					.dword 		100000000
>a6df	80 96 98 00					.dword 		10000000
>a6e3	40 42 0f 00					.dword 		1000000
>a6e7	a0 86 01 00					.dword 		100000
>a6eb	10 27 00 00					.dword 		10000
>a6ef	e8 03 00 00					.dword 		1000
>a6f3	64 00 00 00					.dword 		100
>a6f7	0a 00 00 00					.dword 		10
.a6fb					_ITSSubtractorsEnd:
.a6fb					ITSOutputCharacter:
.a6fb	48		pha				pha
.a6fc	da		phx				phx
.a6fd	ae 20 08	ldx $0820			ldx 	SBPosition 					; save digit
.a700	9d 00 08	sta $0800,x			sta 	SBuffer,x
.a703	9e 01 08	stz $0801,x			stz 	SBuffer+1,x
.a706	ee 20 08	inc $0820			inc 	SBPosition					; bump pointer.
.a709	fa		plx				plx
.a70a	68		pla				pla
.a70b	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/intfromstr.asm

.a70c					IntFromString:
.a70c	a0 00		ldy #$00			ldy 	#0 							; from (zTemp0)
.a70e	8c 25 08	sty $0825			sty 	IFSHexFlag
.a711	b2 14		lda ($14)			lda 	(zTemp0)					; check &
.a713	c9 26		cmp #$26			cmp 	#"&"
.a715	d0 04		bne $a71b			bne 	_IFSNotHex
.a717	ce 25 08	dec $0825			dec 	IFSHexFlag 					; hex flag = $FF
.a71a	c8		iny				iny 								; skip
.a71b					_IFSNotHex:
.a71b	e8		inx				inx 								; space on stack
.a71c	20 78 a7	jsr $a778			jsr 	IFSClearTOS
.a71f					_IFSLoop:
.a71f	ad 25 08	lda $0825			lda 	IFSHexFlag 					; check in hex mode ?
.a722	f0 0a		beq $a72e			beq 	_IFSDecOnly
.a724	b1 14		lda ($14),y			lda 	(zTemp0),y 					; get next
.a726	c9 41		cmp #$41			cmp 	#"A"
.a728	90 04		bcc $a72e			bcc 	_IFSDecOnly
.a72a	c9 47		cmp #$47			cmp 	#"F"+1
.a72c	90 0a		bcc $a738			bcc 	_IFSOkDigit
.a72e					_IFSDecOnly:
.a72e	b1 14		lda ($14),y			lda 	(zTemp0),y 					; get next
.a730	c9 30		cmp #$30			cmp 	#"0"						; validate it as range 0-9
.a732	90 3e		bcc $a772			bcc 	_IFSExit
.a734	c9 3a		cmp #$3a			cmp 	#"9"+1
.a736	b0 3a		bcs $a772			bcs 	_IFSExit
.a738					_IFSOkDigit:
.a738	ad 25 08	lda $0825			lda 	IFSHexFlag
.a73b	d0 11		bne $a74e			bne 	_IFSHexShift
.a73d	20 07 aa	jsr $aa07			jsr 	Stack_Dup 					; duplicate tos
.a740	20 0e ab	jsr $ab0e			jsr 	Unary_Shl	 				; x 2
.a743	20 0e ab	jsr $ab0e			jsr 	Unary_Shl 					; x 4
.a746	20 d9 ab	jsr $abd9			jsr 	Stack_Add 					; x 5
.a749	20 0e ab	jsr $ab0e			jsr 	Unary_Shl 					; x 10
.a74c	80 0c		bra $a75a			bra 	_IFSAddIn
.a74e					_IFSHexShift:
.a74e	20 0e ab	jsr $ab0e			jsr 	Unary_Shl	 				; x 2
.a751	20 0e ab	jsr $ab0e			jsr 	Unary_Shl	 				; x 4
.a754	20 0e ab	jsr $ab0e			jsr 	Unary_Shl	 				; x 8
.a757	20 0e ab	jsr $ab0e			jsr 	Unary_Shl	 				; x 16
.a75a					_IFSAddIn:
.a75a	e8		inx				inx  								; create space next up
.a75b	20 78 a7	jsr $a778			jsr 	IFSClearTOS
.a75e	b1 14		lda ($14),y			lda 	(zTemp0),y 					; add digit
.a760	c9 41		cmp #$41			cmp 	#"A"
.a762	90 03		bcc $a767			bcc 	_IFSDec
.a764	38		sec				sec 								; hex fixup.
.a765	e9 07		sbc #$07			sbc 	#7
.a767					_IFSDec:
.a767	29 0f		and #$0f			and 	#15
.a769	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; tos is new add
.a76c	20 d9 ab	jsr $abd9			jsr 	Stack_Add 					; add to tos
.a76f	c8		iny				iny
.a770	80 ad		bra $a71f			bra 	_IFSLoop
.a772					_IFSExit:
.a772	98		tya				tya
.a773	38		sec				sec
.a774	f0 01		beq $a777			beq 	_IFSSkipFail
.a776	18		clc				clc
.a777					_IFSSkipFail:
.a777	60		rts				rts
.a778					IFSClearTOS:
.a778	9e 00 0c	stz $0c00,x			stz		stack0,x
.a77b	9e 00 0d	stz $0d00,x			stz		stack1,x
.a77e	9e 00 0e	stz $0e00,x			stz		stack2,x
.a781	9e 00 0f	stz $0f00,x			stz		stack3,x
.a784	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/tokeniser.asm

.a785					Tokenise:
.a785	da		phx				phx
.a786	a0 ff		ldy #$ff			ldy 	#255 						; predecrement
.a788					_TKSkip:
.a788	c8		iny				iny
.a789					_TKMainLoop:
.a789	b1 10		lda ($10),y			lda 	(codePtr),y 				; get and check end.
.a78b	f0 06		beq $a793			beq 	_TKExit
.a78d	c9 20		cmp #$20			cmp 	#" "
.a78f	f0 f7		beq $a788			beq 	_TKSkip
.a791	80 04		bra $a797			bra 	_TKNotEnd
.a793	92 16		sta ($16)	_TKExit:sta 	(zTemp1) 					; and ending $00
.a795	fa		plx				plx
.a796	60		rts				rts
.a797					_TKNotEnd:
.a797	c9 22		cmp #$22			cmp 	#'"'
.a799	f0 04		beq $a79f			beq 	_TKIsQuote
.a79b	c9 27		cmp #$27			cmp 	#"'"
.a79d	d0 05		bne $a7a4			bne 	_TKNotQuote
.a79f					_TKIsQuote:
.a79f	20 c3 a8	jsr $a8c3			jsr		TOKQuotedString
.a7a2	80 e5		bra $a789			bra 	_TKMainLoop
.a7a4					_TKNotQuote:
.a7a4	98		tya				tya 								; current pos -> zTemp0
.a7a5	18		clc				clc
.a7a6	65 10		adc $10				adc 	codePtr
.a7a8	85 14		sta $14				sta 	zTemp0
.a7aa	85 10		sta $10				sta 	codePtr
.a7ac	a5 11		lda $11				lda 	codePtr+1
.a7ae	69 00		adc #$00			adc 	#0
.a7b0	85 15		sta $15				sta 	zTemp0+1
.a7b2	85 11		sta $11				sta 	codePtr+1
.a7b4	a0 00		ldy #$00			ldy 	#0 							; reset and get character
.a7b6	b1 10		lda ($10),y			lda 	(codePtr),y
.a7b8	c9 26		cmp #$26			cmp 	#"&"						; hex marker
.a7ba	f0 08		beq $a7c4			beq 	_TKIsNumber
.a7bc	c9 30		cmp #$30			cmp 	#"0"						; check for decimal.
.a7be	90 23		bcc $a7e3			bcc 	_TKNotNumber
.a7c0	c9 3a		cmp #$3a			cmp 	#"9"+1
.a7c2	b0 1f		bcs $a7e3			bcs 	_TKNotNumber
.a7c4					_TKIsNumber:
.a7c4	e8		inx				inx
.a7c5	20 0c a7	jsr $a70c			jsr 	IntFromString 				; convert to integer
.a7c8	48		pha				pha
.a7c9	20 9b a8	jsr $a89b			jsr 	TokWriteConstant 			; do constant recursively.
.a7cc	7a		ply				ply
.a7cd	ca		dex				dex
.a7ce	b1 10		lda ($10),y			lda 	(codePtr),y
.a7d0	c9 2d		cmp #$2d			cmp 	#"-"						; followed by minus
.a7d2	d0 08		bne $a7dc			bne 	_TKIsPositive
.a7d4	c8		iny				iny									; skip it
.a7d5	a9 4f		lda #$4f			lda 	#KWD_CONSTANT_MINUS
.a7d7	20 92 a8	jsr $a892			jsr 	TokWriteToken 				; write token out
.a7da	80 ad		bra $a789			bra 	_TKMainLoop 				; loop back.
.a7dc					_TKIsPositive:
.a7dc	a9 4e		lda #$4e			lda 	#KWD_CONSTANT_PLUS
.a7de	20 92 a8	jsr $a892			jsr 	TokWriteToken 				; write token out
.a7e1	80 a6		bra $a789			bra 	_TKMainLoop 				; loop back.
.a7e3					_TKNotNumber:
.a7e3	a9 00		lda #$00			lda 	#KeywordText & $FF 			; zTemp2 -> token table
.a7e5	85 18		sta $18				sta 	zTemp2
.a7e7	a9 a1		lda #$a1			lda 	#KeywordText >> 8
.a7e9	85 19		sta $19				sta 	zTemp2+1
.a7eb	64 1a		stz $1a				stz 	zTemp3 						; clear 'best'
.a7ed	a9 10		lda #$10			lda 	#$10
.a7ef	85 1b		sta $1b				sta 	zTemp3+1 					; set current token
.a7f1					_TKSearch:
.a7f1	a0 00		ldy #$00			ldy 	#0
.a7f3					_TKCompare:
.a7f3	b1 10		lda ($10),y			lda 	(codePtr),y 	 			; get char from buffer
.a7f5	c8		iny				iny
.a7f6	d1 18		cmp ($18),y			cmp 	(zTemp2),y 					; does it match.
.a7f8	d0 07		bne $a801			bne 	_TKNext
.a7fa	98		tya				tya
.a7fb	d2 18		cmp ($18)			cmp 	(zTemp2) 					; Y = length
.a7fd	d0 f4		bne $a7f3			bne 	_TKCompare 					; found a match.
.a7ff	80 13		bra $a814			bra 	_TKFound
.a801	b2 18		lda ($18)	_TKNext:lda 	(zTemp2)					; get length
.a803	38		sec				sec 								; add length+1 to current
.a804	65 18		adc $18				adc 	zTemp2
.a806	85 18		sta $18				sta 	zTemp2
.a808	90 02		bcc $a80c			bcc 	_TKNNC
.a80a	e6 19		inc $19				inc 	zTemp2+1
.a80c	e6 1b		inc $1b		_TKNNC:	inc 	zTemp3+1 					; increment current token
.a80e	b2 18		lda ($18)			lda 	(zTemp2) 					; reached then end
.a810	d0 df		bne $a7f1			bne 	_TKSearch 					; go try again.
.a812	80 0f		bra $a823			bra 	_TKComplete
.a814					_TKFound:
.a814	98		tya				tya
.a815	c5 1a		cmp $1a				cmp 	zTemp3 						; check best
.a817	90 e8		bcc $a801			bcc 	_TKNext 					; if < best try next
.a819	f0 e6		beq $a801			beq 	_TKNext 					; if equal this is one of the special +- tokens
.a81b	85 1a		sta $1a				sta 	zTemp3 						; update best
.a81d	a5 1b		lda $1b				lda 	zTemp3+1 					; save current token.
.a81f	85 1c		sta $1c				sta 	zTemp4
.a821	80 de		bra $a801			bra 	_TKNext
.a823					_TKComplete:
.a823	a5 1a		lda $1a				lda 	zTemp3 						; get "best score"
.a825	f0 1a		beq $a841			beq		_TKTokenFail 				; if zero no match occurred
.a827	a4 1a		ldy $1a				ldy 	zTemp3 						; length in Y
.a829	88		dey				dey
.a82a	b1 10		lda ($10),y			lda 	(codePtr),y 				; look at last character
.a82c	c8		iny				iny
.a82d	20 82 a8	jsr $a882			jsr 	TOKIsIdentifier 			; identifier character
.a830	90 07		bcc $a839			bcc 	_TKOutput 					; if not, then token is okay
.a832	b1 10		lda ($10),y			lda 	(codePtr),y 				; look at character after
.a834	20 82 a8	jsr $a882			jsr 	TOKIsIdentifier 			; is that an identifier
.a837	b0 08		bcs $a841			bcs 	_TKTokenFail 				; if so it must be something like DEFAULT (DEF-AULT)
.a839					_TKOutput:
.a839	a5 1c		lda $1c				lda 	zTemp4 						; output actual token
.a83b	20 92 a8	jsr $a892			jsr 	TOKWriteToken
.a83e	4c 89 a7	jmp $a789			jmp 	_TKMainLoop					; go round again
.a841					_TKTokenFail:
.a841	a0 00		ldy #$00			ldy 	#0
.a843	b2 10		lda ($10)			lda 	(codePtr) 					; is the first an identifier ?
.a845	20 82 a8	jsr $a882			jsr 	TOKIsIdentifier
.a848	b0 13		bcs $a85d			bcs 	_TKCopyIdent 				; if yes copy it
.a84a	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>a84d	43 41 4e 4e 4f 54 20 54				.text 	"CANNOT TOKENISE",0
>a855	4f 4b 45 4e 49 53 45 00
.a85d					_TKCopyIdent:
.a85d	c8		iny				iny 								; get next
.a85e	b1 10		lda ($10),y			lda 	(codePtr),y
.a860	20 82 a8	jsr $a882			jsr 	TOKIsIdentifier 			; if identifier
.a863	08		php				php 								; save CS on stack
.a864	88		dey				dey 								; back to character
.a865	b1 10		lda ($10),y			lda 	(codePtr),y 				; get it
.a867	c8		iny				iny
.a868	c9 2e		cmp #$2e			cmp 	#"."
.a86a	d0 02		bne $a86e			bne 	_TKNotDot
.a86c	a9 60		lda #$60			lda 	#'A'+31 					; to map . to 31
.a86e					_TKNotDot:
.a86e	38		sec				sec
.a86f	e9 41		sbc #$41			sbc		#'A'
.a871	09 c0		ora #$c0			ora 	#$C0 						; in right range
.a873	28		plp				plp 								; CS if next is identifier
.a874	08		php				php
.a875	b0 02		bcs $a879			bcs 	_TKNotLast					; CC if next is not identifier
.a877	09 e0		ora #$e0			ora 	#$E0 						; range E0-FF
.a879					_TKNotLast:
.a879	20 92 a8	jsr $a892			jsr 	TOKWriteToken 				; write out
.a87c	28		plp				plp 								; get test result
.a87d	b0 de		bcs $a85d			bcs 	_TKCopyIdent 				; get the next identifier.
.a87f	4c 89 a7	jmp $a789			jmp 	_TKMainLoop
.a882					TOKIsIdentifier:
.a882	c9 2e		cmp #$2e			cmp 	#"."
.a884	f0 08		beq $a88e			beq 	_TIIYes
.a886	c9 41		cmp #$41			cmp 	#"A"
.a888	90 06		bcc $a890			bcc 	_TIINo
.a88a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.a88c	b0 02		bcs $a890			bcs 	_TIINo
.a88e					_TIIYes:
.a88e	38		sec				sec
.a88f	60		rts				rts
.a890					_TIINo:
.a890	18		clc				clc
.a891	60		rts				rts
.a892					TokWriteToken:
.a892	92 16		sta ($16)			sta 	(zTemp1)
.a894	e6 16		inc $16				inc 	zTemp1
.a896	d0 02		bne $a89a			bne 	_TWTExit
.a898	e6 17		inc $17				inc 	zTemp1+1
.a89a					_TWTExit:
.a89a	60		rts				rts
.a89b					TokWriteConstant:
.a89b	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; get current
.a89e	29 3f		and #$3f			and		#63
.a8a0	48		pha				pha 								; save on stack
.a8a1	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check if < 64
.a8a4	29 c0		and #$c0			and 	#$C0
.a8a6	1d 00 0d	ora $0d00,x			ora 	stack1,x
.a8a9	1d 00 0e	ora $0e00,x			ora 	stack2,x
.a8ac	1d 00 0f	ora $0f00,x			ora 	stack3,x
.a8af	f0 0d		beq $a8be			beq 	_TWCNoCall 					; no, don't call.
.a8b1	5a		phy				phy
.a8b2	a0 06		ldy #$06			ldy 	#6
.a8b4					_TWCShift:
.a8b4	20 1b ab	jsr $ab1b			jsr 	Unary_Shr
.a8b7	88		dey				dey
.a8b8	d0 fa		bne $a8b4			bne 	_TWCShift
.a8ba	7a		ply				ply
.a8bb	20 9b a8	jsr $a89b			jsr 	TokWriteConstant
.a8be					_TWCNoCall:
.a8be	68		pla				pla
.a8bf	09 80		ora #$80			ora 	#$80						; make digit token
.a8c1	80 cf		bra $a892			bra 	TokWriteToken 				; and write it out.
.a8c3					TokQuotedString:
.a8c3	85 18		sta $18				sta 	zTemp2 						; save quote
.a8c5	49 22		eor #$22			eor 	#'"'						; now zero if double quotes
.a8c7	f0 02		beq $a8cb			beq 	_TQDouble
.a8c9	a9 01		lda #$01			lda 	#1
.a8cb					_TQDouble:
.a8cb	1a		inc a				inc 	a 							; 1 for double, 2 for single
.a8cc	20 92 a8	jsr $a892			jsr 	TOKWriteToken 				; write out
.a8cf	a5 16		lda $16				lda 	zTemp1 						; copy zTemp1 to zTemp3 (byte count addr)
.a8d1	85 1a		sta $1a				sta 	zTemp3
.a8d3	a5 17		lda $17				lda 	zTemp1+1
.a8d5	85 1b		sta $1b				sta 	zTemp3+1
.a8d7	a9 03		lda #$03			lda 	#3 							; 3 is the size if it is empty - type,size,null
.a8d9	20 92 a8	jsr $a892			jsr 	TOKWriteToken
.a8dc					_TQLoop:
.a8dc	c8		iny				iny 								; next character
.a8dd	b1 10		lda ($10),y			lda 	(codePtr),y
.a8df	f0 0f		beq $a8f0			beq 	_TQExit 					; if zero exit
.a8e1	c5 18		cmp $18				cmp 	zTemp2 						; matching quote
.a8e3	f0 0a		beq $a8ef			beq 	_TQSkipExit 				; skip it and exit
.a8e5	20 92 a8	jsr $a892			jsr 	TOKWriteToken 				; write out
.a8e8	b2 1a		lda ($1a)			lda 	(zTemp3)					; inc char count
.a8ea	1a		inc a				inc 	a
.a8eb	92 1a		sta ($1a)			sta 	(zTemp3)
.a8ed	80 ed		bra $a8dc			bra 	_TQLoop						; go round
.a8ef					_TQSkipExit:
.a8ef	c8		iny				iny
.a8f0					_TQExit:
.a8f0	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.a8f2	20 92 a8	jsr $a892			jsr 	TOKWriteToken
.a8f5	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/editor.asm

.a8f6					EditProgram:
.a8f6	ad 89 10	lda $1089			lda 	VarMemory+1
.a8f9	1a		inc a				inc 	a
.a8fa	c9 98		cmp #$98			cmp 	#MemoryEnd >> 8
.a8fc	b0 3c		bcs $a93a			bcs 	_EPMemory
.a8fe	a2 00		ldx #$00			ldx 	#0
.a900	a9 03		lda #$03			lda 	#(TokeniseBuffer+3) & $FF
.a902	85 10		sta $10				sta 	codePtr
.a904	a9 0a		lda #$0a			lda 	#(TokeniseBuffer+3) >> 8
.a906	85 11		sta $11				sta 	codePtr+1
.a908	a0 00		ldy #$00			ldy 	#0
.a90a	a2 ff		ldx #$ff			ldx 	#255
.a90c	20 e3 a3	jsr $a3e3			jsr 	ExtractIntegerToTOS
.a90f	98		tya				tya
.a910	18		clc				clc
.a911	65 10		adc $10				adc 	codePtr
.a913	85 10		sta $10				sta 	codePtr
.a915	90 02		bcc $a919			bcc 	_EPNoCarry
.a917	e6 11		inc $11				inc 	codePtr+1
.a919					_EPNoCarry:
.a919	20 3d a9	jsr $a93d			jsr 	EDFindLine
.a91c	90 0f		bcc $a92d			bcc 	_EPNotFound
.a91e	a5 16		lda $16				lda 	zTemp1
.a920	48		pha				pha
.a921	a5 17		lda $17				lda 	zTemp1+1
.a923	48		pha				pha
.a924	20 74 a9	jsr $a974			jsr 	EDDeleteLine
.a927	68		pla				pla
.a928	85 17		sta $17				sta 	zTemp1+1
.a92a	68		pla				pla
.a92b	85 16		sta $16				sta 	zTemp1
.a92d					_EPNotFound:
.a92d	b2 10		lda ($10)			lda 	(codePtr)
.a92f	f0 03		beq $a934			beq 	_EPNoInsert
.a931	20 99 a9	jsr $a999			jsr 	EDInsertLine
.a934					_EPNoInsert:
.a934	20 22 a5	jsr $a522			jsr 	ResetForRun
.a937	4c 47 a0	jmp $a047			jmp 	NewCommand
.a93a					_EPMemory:
.a93a	4c c0 a5	jmp $a5c0			jmp 	OutOfMemoryError
.a93d					EDFindLine:
.a93d	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; set zTemp1 to start of program
.a93f	85 16		sta $16				sta 	zTemp1
.a941	a9 11		lda #$11			lda 	#ProgramStart >> 8
.a943	85 17		sta $17				sta 	zTemp1+1
.a945					_EDFLLoop:
.a945	a0 00		ldy #$00			ldy 	#0 							; reached the end
.a947	b1 16		lda ($16),y			lda 	(zTemp1),y
.a949	f0 25		beq $a970			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.a94b	c8		iny				iny
.a94c	38		sec				sec
.a94d	ad 00 0c	lda $0c00			lda 	stack0						; subtract the current from the target
.a950	f1 16		sbc ($16),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.a952	aa		tax				tax	 								; this will return 10.
.a953	ad 00 0d	lda $0d00			lda 	stack1
.a956	c8		iny				iny
.a957	f1 16		sbc ($16),y			sbc 	(zTemp1),y
.a959	90 15		bcc $a970			bcc 	_EDFLFail					; if target < current then failed.
.a95b	d0 04		bne $a961			bne 	_EDFLNext 					; if non-zero then goto next
.a95d	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.a95f	f0 11		beq $a972			beq 	_EDFLFound
.a961					_EDFLNext:
.a961	a0 00		ldy #$00			ldy 	#0 							; get offset
.a963	18		clc				clc
.a964	b1 16		lda ($16),y			lda 	(zTemp1),y
.a966	65 16		adc $16				adc 	zTemp1 						; add to pointer
.a968	85 16		sta $16				sta 	zTemp1
.a96a	90 d9		bcc $a945			bcc 	_EDFLLoop
.a96c	e6 17		inc $17				inc 	zTemp1+1 					; carry out.
.a96e	80 d5		bra $a945			bra 	_EDFLLoop
.a970					_EDFLFail:
.a970	18		clc				clc
.a971	60		rts				rts
.a972					_EDFLFound:
.a972	38		sec				sec
.a973	60		rts				rts
.a974					EDDeleteLine:
.a974	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.a976	a2 00		ldx #$00			ldx 	#0
.a978	b1 16		lda ($16),y			lda 	(zTemp1),y
.a97a	a8		tay				tay 								; put in Y
.a97b					_EDDelLoop:
.a97b	b1 16		lda ($16),y			lda 	(zTemp1),y 					; get it
.a97d	81 16		sta ($16,x)			sta 	(zTemp1,x) 					; write it.
.a97f	a5 16		lda $16				lda 	zTemp1 						; check if pointer has reached the end of
.a981	cd 88 10	cmp $1088			cmp		VarMemory 					; low memory. We will have copied down an
.a984	d0 07		bne $a98d			bne 	_EDDelNext 					; extra pile of stuff - technically should
.a986	a5 17		lda $17				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.a988	cd 89 10	cmp $1089			cmp 	VarMemory+1					; doesn't really matter.
.a98b	f0 08		beq $a995			beq		_EDDelExit
.a98d					_EDDelNext:
.a98d	e6 16		inc $16				inc 	zTemp1 						; go to next byte.
.a98f	d0 ea		bne $a97b			bne 	_EDDelLoop
.a991	e6 17		inc $17				inc 	zTemp1+1
.a993	80 e6		bra $a97b			bra 	_EDDelLoop
.a995					_EDDelExit:
.a995	20 48 a5	jsr $a548			jsr 	ResetVarMemory
.a998	60		rts				rts
.a999					EDInsertLine:
.a999	ad 88 10	lda $1088			lda 	VarMemory 					; copy high memory to zTemp3
.a99c	85 1a		sta $1a				sta 	zTemp3
.a99e	ad 89 10	lda $1089			lda 	VarMemory+1
.a9a1	85 1b		sta $1b				sta 	zTemp3+1
.a9a3	a0 00		ldy #$00			ldy 	#0 							; work out the line length.
.a9a5					_EDGetLength:
.a9a5	b1 10		lda ($10),y			lda 	(codePtr),y  				; get token
.a9a7	f0 0d		beq $a9b6			beq 	_EDGotLength 				; if 0, Y is the length
.a9a9	c8		iny				iny
.a9aa	c9 03		cmp #$03			cmp 	#3 							; 1 and 2 are ASCIIZ strings so skip them.
.a9ac	b0 f7		bcs $a9a5			bcs 	_EDGetLength
.a9ae	98		tya				tya 								; get original position
.a9af	3a		dec a				dec 	a
.a9b0	18		clc				clc
.a9b1	71 10		adc ($10),y			adc 	(codePtr),y
.a9b3	a8		tay				tay
.a9b4	80 ef		bra $a9a5			bra 	_EDGetLength
.a9b6					_EDGotLength:
.a9b6	98		tya				tya
.a9b7	18		clc				clc
.a9b8	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.a9ba	48		pha				pha 								; save total size (e.g. offset)
.a9bb	85 1c		sta $1c				sta 	zTemp4 						; save for copying
.a9bd	a8		tay				tay 								; in Y
.a9be	a2 00		ldx #$00			ldx 	#0
.a9c0					_EDInsLoop:
.a9c0	a1 1a		lda ($1a,x)			lda 	(zTemp3,x)					; copy it up
.a9c2	91 1a		sta ($1a),y			sta 	(zTemp3),y
.a9c4	a5 1a		lda $1a				lda 	zTemp3 						; reached the insert point (zTemp1)
.a9c6	c5 16		cmp $16				cmp 	zTemp1
.a9c8	d0 06		bne $a9d0			bne 	_EDINextShift
.a9ca	a5 1b		lda $1b				lda 	zTemp3+1
.a9cc	c5 17		cmp $17				cmp 	zTemp1+1
.a9ce	f0 0a		beq $a9da			beq 	_EDIShiftOver
.a9d0					_EDINextShift:
.a9d0	a5 1a		lda $1a				lda 	zTemp3 					; decrement the copy pointer.
.a9d2	d0 02		bne $a9d6			bne 	_EDINoBorrow
.a9d4	c6 1b		dec $1b				dec 	zTemp3+1
.a9d6					_EDINoBorrow:
.a9d6	c6 1a		dec $1a				dec 	zTemp3
.a9d8	80 e6		bra $a9c0			bra 	_EDInsLoop
.a9da					_EDIShiftOver:
.a9da	68		pla				pla 								; this is the size + others, e.g. offset
.a9db	a0 00		ldy #$00			ldy 	#0
.a9dd	91 1a		sta ($1a),y			sta 	(zTemp3),y 					; write that out.
.a9df	ad 00 0c	lda $0c00			lda 	stack0 						; write LIne# out
.a9e2	c8		iny				iny
.a9e3	91 1a		sta ($1a),y			sta 	(zTemp3),y
.a9e5	ad 00 0d	lda $0d00			lda 	stack1
.a9e8	c8		iny				iny
.a9e9	91 1a		sta ($1a),y			sta 	(zTemp3),y
.a9eb	c8		iny				iny 								; where the code goes.
.a9ec	a2 00		ldx #$00			ldx 	#0 							; comes from
.a9ee					_EDICopyCode:
.a9ee	a1 10		lda ($10,x)			lda 	(codePtr,x)					; read from the current line
.a9f0	91 1a		sta ($1a),y			sta 	(zTemp3),y 					; write out
.a9f2	c8		iny				iny 								; bump pointers
.a9f3	e6 10		inc $10				inc 	codePtr
.a9f5	d0 02		bne $a9f9			bne 	_EDINoCarry
.a9f7	e6 11		inc $11				inc 	codePtr+1
.a9f9					_EDINoCarry:
.a9f9	c6 1c		dec $1c				dec 	zTemp4 						; copy data in
.a9fb	a5 1c		lda $1c				lda 	zTemp4 						; this is the total count - first 3 bytes seperate
.a9fd	c9 03		cmp #$03			cmp 	#3 							; so exit on 3
.a9ff	d0 ed		bne $a9ee			bne 	_EDICopyCode
.aa01	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/stack.asm

.aa02					Stack_Empty:
.aa02	a2 00		ldx #$00			ldx 	#0
.aa04	60		rts				rts
.aa05					Stack_Drop:
.aa05	ca		dex				dex
.aa06	60		rts				rts
.aa07					Stack_Dup:
.aa07	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy to next up
.aa0a	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.aa0d	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa10	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.aa13	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aa16	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.aa19	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aa1c	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.aa1f	e8		inx				inx 								; bump stack pointer
.aa20	60		rts				rts
.aa21					Stack_Nip:
.aa21	bd 00 0c	lda $0c00,x			lda 	stack0,x	 				; copy top to 2nd
.aa24	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.aa27	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa2a	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.aa2d	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aa30	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.aa33	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aa36	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.aa39	ca		dex				dex 								; drop tos
.aa3a	60		rts				rts
.aa3b					Stack_Over:
.aa3b	bd ff 0b	lda $0bff,x			lda 	stack0-1,x				; copy to next up
.aa3e	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.aa41	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.aa44	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.aa47	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.aa4a	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.aa4d	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.aa50	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.aa53	e8		inx				inx 							; bump stack pointer
.aa54	60		rts				rts
.aa55					Stack_Swap:
.aa55	5a		phy				phy
.aa56	bd 00 0c	lda $0c00,x			lda 	stack0,x
.aa59	a8		tay				tay
.aa5a	bd ff 0b	lda $0bff,x			lda 	stack0-1,x
.aa5d	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aa60	98		tya				tya
.aa61	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.aa64	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa67	a8		tay				tay
.aa68	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.aa6b	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aa6e	98		tya				tya
.aa6f	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.aa72	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aa75	a8		tay				tay
.aa76	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.aa79	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aa7c	98		tya				tya
.aa7d	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.aa80	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aa83	a8		tay				tay
.aa84	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.aa87	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aa8a	98		tya				tya
.aa8b	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.aa8e	7a		ply				ply
.aa8f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/unary.asm

.aa90					Unary_Absolute:
.aa90	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aa93	30 01		bmi $aa96			bmi 	Unary_Negate
.aa95	60		rts				rts
.aa96					Unary_Negate:
.aa96	38		sec				sec
.aa97	a9 00		lda #$00			lda		#0
.aa99	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.aa9c	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aa9f	a9 00		lda #$00			lda		#0
.aaa1	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.aaa4	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aaa7	a9 00		lda #$00			lda		#0
.aaa9	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.aaac	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aaaf	a9 00		lda #$00			lda		#0
.aab1	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.aab4	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aab7	60		rts				rts
.aab8					Unary_Not:
.aab8	bd 00 0c	lda $0c00,x			lda 	stack0,x
.aabb	49 ff		eor #$ff			eor 	#$FF
.aabd	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aac0	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aac3	49 ff		eor #$ff			eor 	#$FF
.aac5	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aac8	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aacb	49 ff		eor #$ff			eor 	#$FF
.aacd	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aad0	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aad3	49 ff		eor #$ff			eor 	#$FF
.aad5	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aad8	60		rts				rts
.aad9					Unary_Increment:
.aad9	fe 00 0c	inc $0c00,x			inc 	stack0,x
.aadc	d0 0d		bne $aaeb			bne 	_UIExit
.aade	fe 00 0d	inc $0d00,x			inc 	stack1,x
.aae1	d0 08		bne $aaeb			bne 	_UIExit
.aae3	fe 00 0e	inc $0e00,x			inc 	stack2,x
.aae6	d0 03		bne $aaeb			bne 	_UIExit
.aae8	fe 00 0f	inc $0f00,x			inc 	stack3,x
.aaeb					_UIExit:
.aaeb	60		rts				rts
.aaec					Unary_Decrement:
.aaec	38		sec				sec
.aaed	bd 00 0c	lda $0c00,x			lda 	stack0,x
.aaf0	e9 01		sbc #$01			sbc 	#1
.aaf2	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aaf5	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aaf8	e9 00		sbc #$00			sbc 	#0
.aafa	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aafd	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ab00	e9 00		sbc #$00			sbc 	#0
.ab02	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ab05	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ab08	e9 00		sbc #$00			sbc 	#0
.ab0a	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ab0d	60		rts				rts
.ab0e					Unary_Shl:
.ab0e	1e 00 0c	asl $0c00,x			asl 	stack0,x
.ab11	3e 00 0d	rol $0d00,x			rol 	stack1,x
.ab14	3e 00 0e	rol $0e00,x			rol 	stack2,x
.ab17	3e 00 0f	rol $0f00,x			rol 	stack3,x
.ab1a	60		rts				rts
.ab1b					Unary_Shr:
.ab1b	5e 00 0f	lsr $0f00,x			lsr 	stack3,x
.ab1e	7e 00 0e	ror $0e00,x			ror 	stack2,x
.ab21	7e 00 0d	ror $0d00,x			ror 	stack1,x
.ab24	7e 00 0c	ror $0c00,x			ror 	stack0,x
.ab27	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/memory.asm

.ab28					Mem_Peek:
.ab28	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.ab2b	85 14		sta $14				sta 	zTemp0
.ab2d	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab30	85 15		sta $15				sta 	zTemp0+1
.ab32	b2 14		lda ($14)			lda 	(zTemp0)					; read byte
.ab34	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.ab37	9e 00 0d	stz $0d00,x			stz 	stack1,x
.ab3a	9e 00 0e	stz $0e00,x			stz 	stack2,x
.ab3d	9e 00 0f	stz $0f00,x			stz 	stack3,x
.ab40	60		rts				rts
.ab41					Mem_WPeek:
.ab41	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.ab44	85 14		sta $14				sta 	zTemp0
.ab46	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab49	85 15		sta $15				sta 	zTemp0+1
.ab4b	b2 14		lda ($14)			lda 	(zTemp0)					; read byte
.ab4d	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.ab50	5a		phy				phy 								; read msb
.ab51	a0 01		ldy #$01			ldy 	#1
.ab53	b1 14		lda ($14),y			lda 	(zTemp0),y
.ab55	7a		ply				ply
.ab56	9d 00 0d	sta $0d00,x			sta 	stack1,x 				; write to stack
.ab59	9e 00 0e	stz $0e00,x			stz 	stack2,x
.ab5c	9e 00 0f	stz $0f00,x			stz 	stack3,x
.ab5f	60		rts				rts
.ab60					Mem_DPeek:
.ab60	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.ab63	85 14		sta $14				sta 	zTemp0
.ab65	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab68	85 15		sta $15				sta 	zTemp0+1
.ab6a	b2 14		lda ($14)			lda 	(zTemp0)					; read byte
.ab6c	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.ab6f	5a		phy				phy 								; read msb
.ab70	a0 01		ldy #$01			ldy 	#1
.ab72	b1 14		lda ($14),y			lda 	(zTemp0),y
.ab74	9d 00 0d	sta $0d00,x			sta 	stack1,x 					; write to stack
.ab77	c8		iny				iny
.ab78	b1 14		lda ($14),y			lda 	(zTemp0),y
.ab7a	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ab7d	c8		iny				iny
.ab7e	b1 14		lda ($14),y			lda 	(zTemp0),y
.ab80	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ab83	7a		ply				ply
.ab84	60		rts				rts
.ab85					Mem_Poke:
.ab85	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.ab88	85 14		sta $14				sta 	zTemp0
.ab8a	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab8d	85 15		sta $15				sta 	zTemp0+1
.ab8f	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.ab92	92 14		sta ($14)			sta 	(zTemp0)
.ab94	ca		dex				dex
.ab95	ca		dex				dex
.ab96	60		rts				rts
.ab97					Mem_WPoke:
.ab97	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.ab9a	85 14		sta $14				sta 	zTemp0
.ab9c	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab9f	85 15		sta $15				sta 	zTemp0+1
.aba1	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.aba4	92 14		sta ($14)			sta 	(zTemp0)
.aba6	5a		phy				phy
.aba7	a0 01		ldy #$01			ldy 	#1
.aba9	bd ff 0e	lda $0eff,x			lda 	stack3-1,x 				; byte to write
.abac	91 14		sta ($14),y			sta 	(zTemp0),y
.abae	7a		ply				ply
.abaf	ca		dex				dex
.abb0	ca		dex				dex
.abb1	60		rts				rts
.abb2					Mem_DPoke:
.abb2	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.abb5	85 14		sta $14				sta 	zTemp0
.abb7	bd 00 0d	lda $0d00,x			lda 	stack1,x
.abba	85 15		sta $15				sta 	zTemp0+1
.abbc	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 					; byte to write
.abbf	92 14		sta ($14)			sta 	(zTemp0)
.abc1	5a		phy				phy
.abc2	a0 01		ldy #$01			ldy 	#1
.abc4	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.abc7	91 14		sta ($14),y			sta 	(zTemp0),y
.abc9	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.abcc	c8		iny				iny
.abcd	91 14		sta ($14),y			sta 	(zTemp0),y
.abcf	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.abd2	c8		iny				iny
.abd3	91 14		sta ($14),y			sta 	(zTemp0),y
.abd5	7a		ply				ply
.abd6	ca		dex				dex
.abd7	ca		dex				dex
.abd8	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/binary.asm

.abd9					Stack_Add:
.abd9	ca		dex				dex
.abda					Stack_Add_No_Dex:
.abda	18		clc				clc
.abdb	bd 00 0c	lda $0c00,x			lda		stack0,x
.abde	7d 01 0c	adc $0c01,x			adc 	stack0+1,x
.abe1	9d 00 0c	sta $0c00,x			sta 	stack0,x
.abe4	bd 00 0d	lda $0d00,x			lda		stack1,x
.abe7	7d 01 0d	adc $0d01,x			adc 	stack1+1,x
.abea	9d 00 0d	sta $0d00,x			sta 	stack1,x
.abed	bd 00 0e	lda $0e00,x			lda		stack2,x
.abf0	7d 01 0e	adc $0e01,x			adc 	stack2+1,x
.abf3	9d 00 0e	sta $0e00,x			sta 	stack2,x
.abf6	bd 00 0f	lda $0f00,x			lda		stack3,x
.abf9	7d 01 0f	adc $0f01,x			adc 	stack3+1,x
.abfc	9d 00 0f	sta $0f00,x			sta 	stack3,x
.abff	60		rts				rts
.ac00					Stack_Sub:
.ac00	ca		dex				dex
.ac01	38		sec				sec
.ac02	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac05	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.ac08	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac0b	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac0e	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.ac11	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac14	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac17	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ac1a	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac1d	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac20	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ac23	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac26	60		rts				rts
.ac27					Stack_And:
.ac27	ca		dex				dex
.ac28	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac2b	3d 01 0c	and $0c01,x			and		stack0+1,x
.ac2e	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac31	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac34	3d 01 0d	and $0d01,x			and 	stack1+1,x
.ac37	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac3a	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac3d	3d 01 0e	and $0e01,x			and 	stack2+1,x
.ac40	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac43	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac46	3d 01 0f	and $0f01,x			and 	stack3+1,x
.ac49	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac4c	60		rts				rts
.ac4d					Stack_Xor:
.ac4d	ca		dex				dex
.ac4e	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac51	5d 01 0c	eor $0c01,x			eor		stack0+1,x
.ac54	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac57	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac5a	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.ac5d	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac60	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac63	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.ac66	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac69	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac6c	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.ac6f	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac72	60		rts				rts
.ac73					Stack_Or:
.ac73	ca		dex				dex
.ac74	bd 00 0c	lda $0c00,x			lda		stack0,x
.ac77	1d 01 0c	ora $0c01,x			ora		stack0+1,x
.ac7a	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac7d	bd 00 0d	lda $0d00,x			lda		stack1,x
.ac80	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.ac83	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac86	bd 00 0e	lda $0e00,x			lda		stack2,x
.ac89	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.ac8c	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac8f	bd 00 0f	lda $0f00,x			lda		stack3,x
.ac92	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.ac95	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ac98	60		rts				rts
.ac99					Stack_Shl:
.ac99	38		sec				sec
.ac9a	80 01		bra $ac9d			bra 	StackShift
.ac9c					Stack_Shr:
.ac9c	18		clc				clc
.ac9d					StackShift:
.ac9d	08		php				php
.ac9e	ca		dex				dex
.ac9f	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; if the shift >= 32
.aca2	29 e0		and #$e0			and 	#$E0 						; going to be zero.
.aca4	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.aca7	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.acaa	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.acad	d0 13		bne $acc2			bne 	_SSZero
.acaf					_SSLoop:
.acaf	de 01 0c	dec $0c01,x			dec 	stack0+1,x 					; dec check count
.acb2	30 1a		bmi $acce			bmi 	_SSDone 					; completed ?
.acb4	28		plp				plp 								; restore flag
.acb5	08		php				php
.acb6	b0 05		bcs $acbd			bcs 	_SSLeft 					; do either shift.
.acb8	20 1b ab	jsr $ab1b			jsr 	Unary_Shr
.acbb	80 f2		bra $acaf			bra 	_SSLoop
.acbd					_SSLeft:
.acbd	20 0e ab	jsr $ab0e			jsr 	Unary_Shl
.acc0	80 ed		bra $acaf			bra 	_SSLoop
.acc2					_SSZero:
.acc2	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; too many shifts.
.acc5	9e 00 0d	stz $0d00,x			stz 	stack1,x
.acc8	9e 00 0e	stz $0e00,x			stz 	stack2,x
.accb	9e 00 0f	stz $0f00,x			stz 	stack3,x
.acce					_SSDone:
.acce	28		plp				plp 								; throw flag.
.accf	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/multiply.asm

.acd0					MulInteger32:
.acd0	ca		dex				dex
.acd1	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy +0 to workspace
.acd4	85 1e		sta $1e				sta 	zLTemp1
.acd6	bd 00 0d	lda $0d00,x			lda 	stack1,x
.acd9	85 1f		sta $1f				sta 	zLTemp1+1
.acdb	bd 00 0e	lda $0e00,x			lda 	stack2,x
.acde	85 20		sta $20				sta 	zLTemp1+2
.ace0	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ace3	85 21		sta $21				sta 	zLTemp1+3
.ace5	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; zero +0, where the result goes.
.ace8	9e 00 0d	stz $0d00,x			stz 	stack1,x
.aceb	9e 00 0e	stz $0e00,x			stz 	stack2,x
.acee	9e 00 0f	stz $0f00,x			stz 	stack3,x
.acf1					_BFMMultiply:
.acf1	a5 1e		lda $1e				lda 	zLTemp1 					; get LSBit of 8-11
.acf3	29 01		and #$01			and 	#1
.acf5	f0 03		beq $acfa			beq 	_BFMNoAdd
.acf7	20 da ab	jsr $abda			jsr 	Stack_Add_No_Dex 			; co-opt this code
.acfa					_BFMNoAdd:
.acfa	1e 01 0c	asl $0c01,x			asl 	stack0+1,x 					; shift +4 left
.acfd	3e 01 0d	rol $0d01,x			rol 	stack1+1,x
.ad00	3e 01 0e	rol $0e01,x			rol 	stack2+1,x
.ad03	3e 01 0f	rol $0f01,x			rol 	stack3+1,x
.ad06	46 21		lsr $21				lsr 	zLTemp1+3 					; shift +8 right
.ad08	66 20		ror $20				ror 	zLTemp1+2
.ad0a	66 1f		ror $1f				ror 	zLTemp1+1
.ad0c	66 1e		ror $1e				ror 	zLTemp1
.ad0e	a5 1e		lda $1e				lda 	zLTemp1 					; continue if +8 is nonzero
.ad10	05 1f		ora $1f				ora 	zLTemp1+1
.ad12	05 20		ora $20				ora 	zLTemp1+2
.ad14	05 21		ora $21				ora 	zLTemp1+3
.ad16	d0 d9		bne $acf1			bne 	_BFMMultiply
.ad18	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/divide.asm

.ad19					DivInteger32:
.ad19	ca		dex				dex
.ad1a	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check for division by zero.
.ad1d	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.ad20	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.ad23	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.ad26	d0 14		bne $ad3c			bne 	_BFDOkay
.ad28	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>ad2b	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>ad33	20 42 59 20 5a 45 52 4f 00
.ad3c					_BFDOkay:
.ad3c	64 1e		stz $1e				stz 	zLTemp1 					; Q/Dividend/Left in +0
.ad3e	64 1f		stz $1f				stz 	zLTemp1+1 					; M/Divisor/Right in +4
.ad40	64 20		stz $20				stz 	zLTemp1+2
.ad42	64 21		stz $21				stz 	zLTemp1+3
.ad44	9c 23 08	stz $0823			stz 	SignCount 					; Count of signs.
.ad47	20 a2 ad	jsr $ada2			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ad4a	e8		inx				inx
.ad4b	20 a2 ad	jsr $ada2			jsr 	CheckIntegerNegate
.ad4e	ca		dex				dex
.ad4f	5a		phy				phy 								; Y is the counter
.ad50	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.ad52					_BFDLoop:
.ad52	1e 00 0c	asl $0c00,x			asl 	stack0,x 					; shift AQ left.
.ad55	3e 00 0d	rol $0d00,x			rol 	stack1,x
.ad58	3e 00 0e	rol $0e00,x			rol 	stack2,x
.ad5b	3e 00 0f	rol $0f00,x			rol 	stack3,x
.ad5e	26 1e		rol $1e				rol 	zLTemp1
.ad60	26 1f		rol $1f				rol 	zLTemp1+1
.ad62	26 20		rol $20				rol 	zLTemp1+2
.ad64	26 21		rol $21				rol 	zLTemp1+3
.ad66	38		sec				sec
.ad67	a5 1e		lda $1e				lda 	zLTemp1+0 					; Calculate A-M on stack.
.ad69	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.ad6c	48		pha				pha
.ad6d	a5 1f		lda $1f				lda 	zLTemp1+1
.ad6f	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.ad72	48		pha				pha
.ad73	a5 20		lda $20				lda 	zLTemp1+2
.ad75	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ad78	48		pha				pha
.ad79	a5 21		lda $21				lda 	zLTemp1+3
.ad7b	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ad7e	90 15		bcc $ad95			bcc 	_BFDNoAdd
.ad80	85 21		sta $21				sta 	zLTemp1+3 					; update A
.ad82	68		pla				pla
.ad83	85 20		sta $20				sta 	zLTemp1+2
.ad85	68		pla				pla
.ad86	85 1f		sta $1f				sta 	zLTemp1+1
.ad88	68		pla				pla
.ad89	85 1e		sta $1e				sta 	zLTemp1+0
.ad8b	bd 00 0c	lda $0c00,x			lda 	stack0,x 			; set Q bit 1.
.ad8e	09 01		ora #$01			ora 	#1
.ad90	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ad93	80 03		bra $ad98			bra 	_BFDNext
.ad95					_BFDNoAdd:
.ad95	68		pla				pla 								; Throw away the intermediate calculations
.ad96	68		pla				pla
.ad97	68		pla				pla
.ad98					_BFDNext:
.ad98	88		dey				dey
.ad99	d0 b7		bne $ad52			bne 	_BFDLoop
.ad9b	7a		ply				ply 								; restore Y
.ad9c	4e 23 08	lsr $0823			lsr 	SignCount 					; if sign count odd,
.ad9f	b0 07		bcs $ada8			bcs		IntegerNegateAlways 		; negate the result
.ada1	60		rts				rts
.ada2					CheckIntegerNegate:
.ada2	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; is it -ve = MSB set ?
.ada5	30 01		bmi $ada8			bmi 	IntegerNegateAlways 		; if so negate it
.ada7	60		rts				rts
.ada8					IntegerNegateAlways:
.ada8	ee 23 08	inc $0823			inc 	SignCount 					; bump the count of signs
.adab	4c 96 aa	jmp $aa96			jmp 	Unary_Negate
.adae					ModInteger32:
.adae	20 19 ad	jsr $ad19			jsr 	DivInteger32
.adb1	a5 1e		lda $1e				lda 	zLTemp1
.adb3	9d 00 0c	sta $0c00,x			sta 	stack0,x
.adb6	a5 1f		lda $1f				lda 	zLTemp1+1
.adb8	9d 00 0d	sta $0d00,x			sta 	stack1,x
.adbb	a5 20		lda $20				lda 	zLTemp1+2
.adbd	9d 00 0e	sta $0e00,x			sta 	stack2,x
.adc0	a5 21		lda $21				lda 	zLTemp1+3
.adc2	9d 00 0f	sta $0f00,x			sta 	stack3,x
.adc5	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/compare.asm

.adc6					Comp_Equal:
.adc6	38		sec				sec
.adc7	80 01		bra $adca			bra 	Comp_CheckEqual
.adc9					Comp_NotEqual:
.adc9	18		clc				clc
.adca					Comp_CheckEqual:
.adca	08		php				php
.adcb	ca		dex				dex
.adcc	bd 00 0c	lda $0c00,x			lda		stack0,x
.adcf	5d 01 0c	eor $0c01,x			eor 	stack0+1,x
.add2	d0 16		bne $adea			bne 	_CCENonZero
.add4	bd 00 0d	lda $0d00,x			lda		stack1,x
.add7	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.adda	d0 0e		bne $adea			bne 	_CCENonZero
.addc	bd 00 0e	lda $0e00,x			lda		stack2,x
.addf	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.ade2	d0 06		bne $adea			bne 	_CCENonZero
.ade4	bd 00 0f	lda $0f00,x			lda		stack3,x
.ade7	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.adea					_CCENonZero:
.adea	f0 02		beq $adee			beq 	_CCENotSet
.adec	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.adee					_CCENotSet:
.adee					CompCheckFlip:
.adee	28		plp				plp 								; if carry set, we want $FF if equal
.adef	90 02		bcc $adf3			bcc 	CompReturn
.adf1	49 ff		eor #$ff			eor 	#$FF
.adf3					CompReturn:
.adf3	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; save result on stack.
.adf6	9d 00 0d	sta $0d00,x			sta 	stack1,x
.adf9	9d 00 0e	sta $0e00,x			sta 	stack2,x
.adfc	9d 00 0f	sta $0f00,x			sta 	stack3,x
.adff	60		rts				rts
.ae00					Comp_Less:
.ae00	18		clc				clc
.ae01	80 01		bra $ae04			bra 	Comp_LessCont
.ae03					Comp_GreaterEqual:
.ae03	38		sec				sec
.ae04					Comp_LessCont:
.ae04	08		php				php
.ae05	ca		dex				dex
.ae06	38		sec				sec
.ae07	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; do a subtraction w/o storing the result
.ae0a	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.ae0d	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ae10	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.ae13	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ae16	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ae19	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ae1c	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ae1f	50 02		bvc $ae23			bvc 	_CLNoFlip 					; unsigned -> signed
.ae21	49 80		eor #$80			eor 	#$80
.ae23					_CLNoFlip:
.ae23	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.ae25	f0 c7		beq $adee			beq 	CompCheckFlip
.ae27	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.ae29	80 c3		bra $adee			bra 	CompCheckFlip
.ae2b					Comp_LessEqual:
.ae2b	38		sec				sec
.ae2c	80 01		bra $ae2f			bra 	Comp_LessEqualCont
.ae2e					Comp_Greater:
.ae2e	18		clc				clc
.ae2f					Comp_LessEqualCont:
.ae2f	08		php				php
.ae30	ca		dex				dex
.ae31	38		sec				sec
.ae32	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; do a subtraction w/o storing the result, backwards
.ae35	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.ae38	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.ae3b	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.ae3e	bd 01 0e	lda $0e01,x			lda 	stack2+1,x
.ae41	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.ae44	bd 01 0f	lda $0f01,x			lda 	stack3+1,x
.ae47	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.ae4a	50 02		bvc $ae4e			bvc 	_CLENoFlip 					; unsigned -> signed
.ae4c	49 80		eor #$80			eor 	#$80
.ae4e					_CLENoFlip:
.ae4e	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.ae50	f0 9c		beq $adee			beq 	CompCheckFlip
.ae52	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.ae54	80 98		bra $adee			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: miscellany/alloc.asm

.ae56					Allocate:
.ae56	bd 00 0d	lda $0d00,x			lda 	stack1,x					; check 0-32767 allocated.
.ae59	29 80		and #$80			and 	#$80
.ae5b	1d 00 0e	ora $0e00,x			ora 	stack2,x
.ae5e	1d 00 0f	ora $0f00,x			ora 	stack3,x
.ae61	d0 26		bne $ae89			bne 	_ALBad
.ae63	18		clc				clc 								; add to varmemory pointer saving
.ae64	ad 88 10	lda $1088			lda 	VarMemory 					; address
.ae67	48		pha				pha
.ae68	7d 00 0c	adc $0c00,x			adc 	stack0,x
.ae6b	8d 88 10	sta $1088			sta 	VarMemory
.ae6e	ad 89 10	lda $1089			lda 	VarMemory+1
.ae71	48		pha				pha
.ae72	7d 00 0d	adc $0d00,x			adc 	stack1,x
.ae75	8d 89 10	sta $1089			sta 	VarMemory+1
.ae78	68		pla				pla 								; pop and save
.ae79	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ae7c	68		pla				pla
.ae7d	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ae80	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ae83	cd 8b 10	cmp $108b			cmp 	AllocMemory+1 				; check range
.ae86	b0 01		bcs $ae89			bcs 	_ALBad
.ae88	60		rts				rts
.ae89					_ALBad:
.ae89	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>ae8c	42 41 44 20 41 4c 4c 4f				.text 	"BAD ALLOC",0
>ae94	43 00

;******  Return to file: main.asm


;******  Processing file: miscellany/list.asm

.ae96					Cmd_List:
.ae96	20 17 a5	jsr $a517			jsr 	ResetCodePointer 			; back to the beginning
.ae99	64 18		stz $18				stz 	zTemp2						; clear the lowest-number
.ae9b	64 19		stz $19				stz 	zTemp2+1
.ae9d	e0 00		cpx #$00			cpx 	#0 							; stack empty ?
.ae9f	f0 0b		beq $aeac			beq 	_CLINone
.aea1	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; use tos as start line
.aea4	85 18		sta $18				sta 	zTemp2
.aea6	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aea9	95 19		sta $19,x			sta 	zTemp2+1,x
.aeab	ca		dex				dex 								; and pop the tos
.aeac					_CLINone:
.aeac	a9 10		lda #$10			lda 	#16 						; list this many lines
.aeae	85 16		sta $16				sta 	zTemp1
.aeb0					_CLILoop
.aeb0	b2 10		lda ($10)			lda 	(codePtr)					; check end of program
.aeb2	f0 24		beq $aed8			beq 	_CLIEnd
.aeb4	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.aeb6	38		sec				sec
.aeb7	b1 10		lda ($10),y			lda 	(codePtr),y
.aeb9	e5 18		sbc $18				sbc 	zTemp2
.aebb	c8		iny				iny
.aebc	b1 10		lda ($10),y			lda 	(codePtr),y
.aebe	e5 19		sbc $19				sbc 	zTemp2+1
.aec0	90 09		bcc $aecb			bcc 	_CLISkip
.aec2	da		phx				phx
.aec3	20 db ae	jsr $aedb			jsr 	ListCurrent 				; list the line.
.aec6	fa		plx				plx
.aec7	c6 16		dec $16				dec 	zTemp1 						; done all lines
.aec9	f0 0d		beq $aed8			beq 	_CLIEnd
.aecb					_CLISkip:
.aecb	18		clc				clc
.aecc	b2 10		lda ($10)			lda 	(codePtr) 					; go to next
.aece	65 10		adc $10				adc 	codePtr
.aed0	85 10		sta $10				sta 	codePtr
.aed2	90 dc		bcc $aeb0			bcc 	_CLILoop
.aed4	e6 11		inc $11				inc 	codePtr+1
.aed6	80 d8		bra $aeb0			bra 	_CLILoop
.aed8					_CLIEnd:
.aed8	4c 33 a0	jmp $a033			jmp 	WarmStart
.aedb					ListCurrent:
.aedb	a9 05		lda #$05			lda 	#CTH_LINENO
.aedd	20 a1 a2	jsr $a2a1			jsr 	ExternColour 				; set colour
.aee0	a0 01		ldy #$01			ldy 	#1							; print line#
.aee2	b1 10		lda ($10),y			lda 	(codePtr),y
.aee4	48		pha				pha
.aee5	c8		iny				iny
.aee6	b1 10		lda ($10),y			lda 	(codePtr),y
.aee8	a8		tay				tay
.aee9	68		pla				pla
.aeea	20 15 a6	jsr $a615			jsr 	ErrorPrint16
.aeed	a8		tay				tay
.aeee					_LCPadOut:
.aeee	a9 20		lda #$20			lda 	#' '
.aef0	20 97 a2	jsr $a297			jsr 	ExternPrint
.aef3	c8		iny				iny
.aef4	c0 05		cpy #$05			cpy 	#5
.aef6	d0 f6		bne $aeee			bne 	_LCPadOut
.aef8	a0 03		ldy #$03			ldy 	#3 							; start here
.aefa					_LCLoop:
.aefa	a9 20		lda #$20			lda 	#' '						; space
.aefc	20 97 a2	jsr $a297			jsr 	ExternPrint
.aeff					_LCLoopNoSpace:
.aeff	b1 10		lda ($10),y			lda 	(codePtr),y 				; get first
.af01	30 3e		bmi $af41			bmi 	_LCIdentConst 				; identifier or constant
.af03	d0 05		bne $af0a			bne 	_LCStringToken
.af05	a9 0d		lda #$0d			lda 	#13
.af07	4c 97 a2	jmp $a297			jmp 	ExternPrint
.af0a					_LCStringToken:
.af0a	c9 10		cmp #$10			cmp 	#$10 						; if < 10 it's a string.
.af0c	90 0c		bcc $af1a			bcc		_LCString
.af0e	20 82 af	jsr $af82			jsr 	ListPrintToken
.af11	b1 10		lda ($10),y			lda 	(codePtr),y 				; no space if ^
.af13	c8		iny				iny 								; advance pointer
.af14	c9 4d		cmp #$4d			cmp 	#KWD_HAT
.af16	f0 e7		beq $aeff			beq 	_LCLoopNoSpace
.af18	80 e0		bra $aefa			bra 	_LCLoop 					; go round again.
.af1a					_LCString:
.af1a	4a		lsr a				lsr 	a 							; CS if 1 (string) CC if 2 (comment)
.af1b	a9 05		lda #$05			lda 	#CTH_STRING 				; decide on colour.
.af1d	a2 22		ldx #$22			ldx 	#'"'
.af1f	b0 04		bcs $af25			bcs 	_LCSSkip
.af21	a9 07		lda #$07			lda 	#CTH_COMMENT
.af23	a2 27		ldx #$27			ldx 	#"'"
.af25					_LCSSkip:
.af25	20 a1 a2	jsr $a2a1			jsr 	ExternColour 				; set colour
.af28	8a		txa				txa
.af29	48		pha				pha 								; save end quote on stack.
.af2a	20 97 a2	jsr $a297			jsr 	ExternPrint
.af2d	c8		iny				iny 								; skip type size
.af2e	c8		iny				iny
.af2f					_LCSPrint:
.af2f	b1 10		lda ($10),y			lda 	(codePtr),y
.af31	c8		iny				iny
.af32	c9 00		cmp #$00			cmp 	#0 							; 0 is end
.af34	f0 05		beq $af3b			beq 	_LCSExit
.af36	20 97 a2	jsr $a297			jsr 	ExternPrint
.af39	80 f4		bra $af2f			bra 	_LCSPrint
.af3b					_LCSExit:
.af3b	68		pla				pla
.af3c	20 97 a2	jsr $a297			jsr 	ExternPrint
.af3f	80 b9		bra $aefa			bra 	_LCLoop
.af41					_LCIdentConst:
.af41	c9 c0		cmp #$c0			cmp 	#$C0						; check if constant
.af43	90 1e		bcc $af63			bcc 	_LCConstant
.af45	a9 03		lda #$03			lda 	#CTH_IDENT 					; set colour
.af47	20 a1 a2	jsr $a2a1			jsr 	ExternColour
.af4a					_LCCIdLoop:
.af4a	b1 10		lda ($10),y			lda 	(codePtr),y 				; read
.af4c	29 1f		and #$1f			and 	#$1F 						; convert
.af4e	18		clc				clc
.af4f	69 41		adc #$41			adc 	#'A'
.af51	c9 60		cmp #$60			cmp 	#'A'+31 					; handle '.'
.af53	d0 02		bne $af57			bne 	_LCCNotDot
.af55	a9 2e		lda #$2e			lda 	#'.'
.af57					_LCCNotDot:
.af57	20 97 a2	jsr $a297			jsr 	ExternPrint
.af5a	b1 10		lda ($10),y			lda 	(codePtr),y 				; at end ?
.af5c	c8		iny				iny
.af5d	c9 e0		cmp #$e0			cmp 	#$E0
.af5f	b0 99		bcs $aefa			bcs 	_LCLoop
.af61	80 e7		bra $af4a			bra 	_LCCIdLoop
.af63					_LCConstant:
.af63	a9 06		lda #$06			lda 	#CTH_NUMBER 				; number colour
.af65	20 a1 a2	jsr $a2a1			jsr 	ExternColour
.af68	a2 fe		ldx #$fe			ldx 	#254 						; use the topmost stack element
.af6a	20 e3 a3	jsr $a3e3			jsr 	ExtractIntegerToTOS 		; so there is a very rare case
.af6d	bd 00 0f	lda $0f00,x			lda 	stack3+0,x					; save stack top byte
.af70	48		pha				pha
.af71	20 3a a6	jsr $a63a			jsr 	IntegerToString 			; this could corrupt stack if full :)
.af74	20 28 a6	jsr $a628			jsr 	ErrorPrintIntegerBuffer
.af77	68		pla				pla 								; sign back
.af78	10 80		bpl $aefa			bpl 	_LCLoop
.af7a	a9 2d		lda #$2d			lda 	#"-"
.af7c	20 97 a2	jsr $a297			jsr 	ExternPrint
.af7f	4c fa ae	jmp $aefa			jmp 	_LCLoop
.af82					ListPrintToken:
.af82	5a		phy				phy
.af83	48		pha				pha 								; token colour
.af84	a9 02		lda #$02			lda 	#CTH_TOKEN
.af86	20 a1 a2	jsr $a2a1			jsr 	ExternColour
.af89	fa		plx				plx
.af8a	a9 00		lda #$00			lda 	#KeywordText & $FF
.af8c	85 14		sta $14				sta 	zTemp0
.af8e	a9 a1		lda #$a1			lda 	#KeywordText >> 8
.af90	85 15		sta $15				sta 	zTemp0+1
.af92					_LPTLoop:
.af92	e0 10		cpx #$10			cpx 	#$10 						; first token is $10
.af94	f0 0e		beq $afa4			beq 	_LPTFound
.af96	ca		dex				dex
.af97	b2 14		lda ($14)			lda 	(zTemp0)
.af99	38		sec				sec									; add 1, it's length+name
.af9a	65 14		adc $14				adc 	zTemp0
.af9c	85 14		sta $14				sta 	zTemp0
.af9e	90 f2		bcc $af92			bcc 	_LPTLoop
.afa0	e6 15		inc $15				inc 	zTemp0+1
.afa2	80 ee		bra $af92			bra 	_LPTLoop
.afa4					_LPTFound:
.afa4	a0 01		ldy #$01			ldy 	#1 							; start here.
.afa6					_LPTShow:
.afa6	b1 14		lda ($14),y			lda 	(zTemp0),y 					; get character
.afa8	c9 20		cmp #$20			cmp 	#32 						; < 32, length, so exit
.afaa	90 06		bcc $afb2			bcc 	_LPTExit
.afac	c8		iny				iny
.afad	20 97 a2	jsr $a297			jsr 	ExternPrint
.afb0	80 f4		bra $afa6			bra 	_LPTShow
.afb2					_LPTExit:
.afb2	7a		ply				ply
.afb3	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/renumber.asm

.afb4					Cmd_Renumber:
.afb4	a9 00		lda #$00			lda 	#ProgramStart & $FF 		; zTemp1 line number being changed
.afb6	85 16		sta $16				sta 	zTemp1
.afb8	a9 11		lda #$11			lda 	#ProgramStart >> 8
.afba	85 17		sta $17				sta 	zTemp1+1
.afbc	a9 e8		lda #$e8			lda 	#1000 & $FF 				; zTemp2 new number
.afbe	85 18		sta $18				sta 	zTemp2
.afc0	a9 03		lda #$03			lda 	#1000 >> 8
.afc2	85 19		sta $19				sta 	zTemp2+1
.afc4					_CRLoop:
.afc4	b2 16		lda ($16)			lda 	(zTemp1) 					; check end of program
.afc6	f0 23		beq $afeb			beq 	_CRExit
.afc8	a0 01		ldy #$01			ldy 	#1 							; copy new number in
.afca	a5 18		lda $18				lda 	zTemp2
.afcc	91 16		sta ($16),y			sta 	(zTemp1),y
.afce	c8		iny				iny
.afcf	a5 19		lda $19				lda 	zTemp2+1
.afd1	91 16		sta ($16),y			sta 	(zTemp1),y
.afd3	18		clc				clc 								; add 10 to new number
.afd4	a5 18		lda $18				lda 	zTemp2
.afd6	69 0a		adc #$0a			adc 	#10
.afd8	85 18		sta $18				sta 	zTemp2
.afda	90 02		bcc $afde			bcc 	_CRNoCarry
.afdc	e6 19		inc $19				inc 	zTemp2+1
.afde					_CRNoCarry:
.afde	18		clc				clc 								; go to next line
.afdf	b2 16		lda ($16)			lda 	(zTemp1)
.afe1	65 16		adc $16				adc 	zTemp1
.afe3	85 16		sta $16				sta 	zTemp1
.afe5	90 dd		bcc $afc4			bcc 	_CRLoop
.afe7	e6 17		inc $17				inc 	zTemp1+1
.afe9	80 d9		bra $afc4			bra 	_CRLoop
.afeb					_CRExit:
.afeb	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/system.asm

.afec					System_RUN:
.afec	20 22 a5	jsr $a522			jsr		ResetForRun 				; clear vars, stacks etc.
.afef	20 17 a5	jsr $a517			jsr 	ResetCodePointer 			; point to first thing to do.
.aff2	4c 66 a3	jmp $a366			jmp 	Execute						; and run
.aff5					System_END:
.aff5	4c 33 a0	jmp $a033			jmp 	WarmStart
.aff8					System_STOP:
.aff8	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>affb	53 54 4f 50 00					.text 	"STOP",0
.b000					System_Assert:
.b000	ca		dex				dex
.b001	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.b004	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.b007	1d 02 0d	ora $0d02,x			ora 	stack1+2,x
.b00a	1d 03 0d	ora $0d03,x			ora 	stack1+3,x
.b00d	d0 0a		bne $b019			bne 	_SAOkay
.b00f	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b012	41 53 53 45 52 54 00				.text 	"ASSERT",0
.b019	60		rts		_SAOkay:rts
.b01a					System_New:
.b01a	9c 00 11	stz $1100			stz 	ProgramStart 				; zero the first offset, erases.
.b01d	20 22 a5	jsr $a522			jsr		ResetForRun 				; clear vars, stacks etc.
.b020	4c 33 a0	jmp $a033			jmp 	WarmStart
.b023					System_Old:
.b023	20 17 a5	jsr $a517			jsr 	ResetCodePointer 			; start of first line.
.b026					_SOFindZero:
.b026	b1 10		lda ($10),y			lda 	(codePtr),y 				; look for trailing $00
.b028	f0 15		beq $b03f			beq 	_SOFoundEnd
.b02a	c8		iny				iny
.b02b	d0 f9		bne $b026			bne 	_SOFindZero
.b02d	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b030	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER",0
>b038	45 43 4f 56 45 52 00
.b03f					_SOFoundEnd:
.b03f	c8		iny				iny 								; update the offset
.b040	8c 00 11	sty $1100			sty 	ProgramStart
.b043	20 22 a5	jsr $a522			jsr 	ResetForRun 				; redo all stacks etc.
.b046	60		rts				rts
.b047					System_Sys:
.b047	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy and drop call address
.b04a	85 14		sta $14				sta 	zTemp0
.b04c	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b04f	85 15		sta $15				sta 	zTemp0+1
.b051	ca		dex				dex
.b052	da		phx				phx
.b053	5a		phy				phy
.b054	ad 00 10	lda $1000			lda 	AZVariables+('A'-'A')*4		; load AXY
.b057	ae 5c 10	ldx $105c			ldx 	AZVariables+('X'-'A')*4
.b05a	ac 60 10	ldy $1060			ldy 	AZVariables+('Y'-'A')*4
.b05d	20 6c b0	jsr $b06c			jsr 	_SSCall 					; effectively jsr (zTemp)
.b060	8d 00 10	sta $1000			sta 	AZVariables+('A'-'A')*4 	; store AXY
.b063	8e 5c 10	stx $105c			stx 	AZVariables+('X'-'A')*4
.b066	8c 60 10	sty $1060			sty 	AZVariables+('Y'-'A')*4
.b069	7a		ply				ply
.b06a	fa		plx				plx
.b06b	60		rts				rts
.b06c	6c 14 00	jmp ($0014)	_SSCall:jmp 	(zTemp0)
.b06f					System_ShowStack:
.b06f	da		phx				phx 								; save stack
.b070	5a		phy				phy
.b071	86 18		stx $18				stx 	zTemp2 						; save old TOS
.b073	a9 5b		lda #$5b			lda 	#"["
.b075	20 97 a2	jsr $a297			jsr 	ExternPrint
.b078	e0 00		cpx #$00			cpx 	#0 							; empty
.b07a	f0 14		beq $b090			beq 	_SSEnd
.b07c	a2 01		ldx #$01			ldx 	#1 							; start here
.b07e					_SSLoop:
.b07e	20 3a a6	jsr $a63a			jsr 	IntegerToString 			; print TOS
.b081	20 28 a6	jsr $a628			jsr 	ErrorPrintIntegerBuffer
.b084	e4 18		cpx $18				cpx 	zTemp2 						; done TOS exit
.b086	f0 08		beq $b090			beq 	_SSEnd
.b088	e8		inx				inx	 								; advance pointer print ,
.b089	a9 2c		lda #$2c			lda 	#','
.b08b	20 97 a2	jsr $a297			jsr 	ExternPrint
.b08e	80 ee		bra $b07e			bra 	_SSLoop
.b090					_SSEnd:
.b090	a9 5d		lda #$5d			lda 	#"]"						; finish off.
.b092	20 97 a2	jsr $a297			jsr 	ExternPrint
.b095	a9 0d		lda #$0d			lda 	#13
.b097	20 97 a2	jsr $a297			jsr 	ExternPrint
.b09a	7a		ply				ply
.b09b	fa		plx				plx
.b09c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/saveload.asm

.b09d					System_Save:
.b09d	20 48 a5	jsr $a548			jsr 	ResetVarMemory 				; make sure start/end are right
.b0a0	20 b3 b0	jsr $b0b3			jsr 	SLGetFileName 				; get filename -> zTemp0
.b0a3	20 dd a2	jsr $a2dd			jsr 	ExternSave
.b0a6	60		rts				rts
.b0a7					System_Load:
.b0a7	20 b3 b0	jsr $b0b3			jsr 	SLGetFileName 				; get filename -> zTemp0
.b0aa	20 17 a3	jsr $a317			jsr 	ExternLoad
.b0ad	20 22 a5	jsr $a522			jsr 	ResetForRun 				; re-initialise everything
.b0b0	4c 33 a0	jmp $a033			jmp 	WarmStart
.b0b3					SLGetFileName:
.b0b3	e0 00		cpx #$00			cpx 	#0 							; gotta be something on the stack
.b0b5	f0 17		beq $b0ce			beq 	_SLFNFail
.b0b7	bd 00 0e	lda $0e00,x			lda 	stack2,x 					; must be a tokenise buffer address
.b0ba	1d 00 0f	ora $0f00,x			ora 	stack3,x
.b0bd	d0 0f		bne $b0ce			bne 	_SLFNFail
.b0bf	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b0c2	c9 0a		cmp #$0a			cmp 	#TokeniseBuffer >> 8
.b0c4	d0 08		bne $b0ce			bne 	_SLFNFail
.b0c6	85 15		sta $15				sta 	zTemp0+1 					; copy the filename address
.b0c8	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b0cb	85 14		sta $14				sta 	zTemp0
.b0cd	60		rts				rts
.b0ce					_SLFNFail:
.b0ce	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b0d1	42 41 44 20 46 49 4c 45				.text 	"BAD FILENAME",0
>b0d9	4e 41 4d 45 00

;******  Return to file: main.asm


;******  Processing file: miscellany/variables.asm

.b0de					Identifier:
.b0de	88		dey				dey 								; wind back to identifier start
.b0df	20 35 a4	jsr $a435			jsr 	IdentifierSearch 			; try to find it.
.b0e2	90 2f		bcc $b113			bcc 	_IDUnknown 					; not known, give up.
.b0e4	48		pha				pha
.b0e5					_IDSkip:
.b0e5	b1 10		lda ($10),y			lda 	(codePtr),y
.b0e7	c8		iny				iny
.b0e8	c9 e0		cmp #$e0			cmp 	#$E0
.b0ea	90 f9		bcc $b0e5			bcc 	_IDSkip
.b0ec	68		pla				pla
.b0ed	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; check a variable
.b0ef	d0 36		bne $b127			bne 	_IDCall
.b0f1	20 db b1	jsr $b1db			jsr 	IndexCheck 					; check index/subscript
.b0f4	5a		phy				phy
.b0f5	e8		inx				inx 								; make space on stack
.b0f6	a0 00		ldy #$00			ldy 	#0 							; copy it back
.b0f8	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b0fa	9d 00 0c	sta $0c00,x			sta 	stack0,x
.b0fd	c8		iny				iny
.b0fe	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b100	9d 00 0d	sta $0d00,x			sta 	stack1,x
.b103	c8		iny				iny
.b104	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b106	9d 00 0e	sta $0e00,x			sta 	stack2,x
.b109	c8		iny				iny
.b10a	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b10c	9d 00 0f	sta $0f00,x			sta 	stack3,x
.b10f	7a		ply				ply
.b110	4c 66 a3	jmp $a366			jmp 	Execute
.b113					_IDUnknown:
.b113	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b116	55 4e 4b 4e 4f 57 4e 20				.text 	"UNKNOWN VARIABLE",0
>b11e	56 41 52 49 41 42 4c 45 00
.b127					_IDCall:
.b127	c9 50		cmp #$50			cmp 	#IDT_PROCEDURE
.b129	d0 1b		bne $b146			bne 	_IDCode
.b12b	20 97 b3	jsr $b397			jsr 	StructPushCurrent 			; push current on the stack.
.b12e	a9 43		lda #$43			lda 	#STM_CALL 					; push marker
.b130	c6 12		dec $12				dec 	StructSP
.b132	92 12		sta ($12)			sta 	(StructSP)
.b134	a0 01		ldy #$01			ldy 	#1 							; line address
.b136	b2 22		lda ($22)			lda 	(idDataAddr)
.b138	85 10		sta $10				sta 	codePtr
.b13a	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b13c	85 11		sta $11				sta 	codePtr+1
.b13e	a0 03		ldy #$03			ldy 	#3 							; line position
.b140	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b142	a8		tay				tay
.b143	4c 66 a3	jmp $a366			jmp 	Execute
.b146					_IDCode:
.b146	b2 22		lda ($22)			lda 	(idDataAddr) 				; copy the address
.b148	85 14		sta $14				sta 	zTemp0
.b14a	5a		phy				phy
.b14b	a0 01		ldy #$01			ldy 	#1
.b14d	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b14f	85 15		sta $15				sta 	zTemp0+1
.b151	7a		ply				ply
.b152	20 58 b1	jsr $b158			jsr 	_IDCallZTemp0 				; call the routine
.b155	4c 66 a3	jmp $a366			jmp 	Execute
.b158					_IDCallZTemp0:
.b158	6c 14 00	jmp ($0014)			jmp 	(zTemp0)
.b15b					ProcReturn:
.b15b					ProcReturn2:
.b15b	b2 12		lda ($12)			lda 	(StructSP)					; check it's CALL
.b15d	c9 43		cmp #$43			cmp 	#STM_CALL
.b15f	a0 01		ldy #$01			ldy 	#1 							; restore the position
.b161	20 cb b3	jsr $b3cb			jsr 	StructPopCurrent
.b164	a9 05		lda #$05			lda 	#5 							; pop 5 elements off structure stack.
.b166	20 91 b3	jsr $b391			jsr 	StructPopCount
.b169	60		rts				rts
.b16a					WriteVariable:
.b16a	b1 10		lda ($10),y			lda 	(codePtr),y 				; check variable
.b16c	c9 c0		cmp #$c0			cmp 	#$C0
.b16e	90 5d		bcc $b1cd			bcc 	_WVTypeError
.b170	20 35 a4	jsr $a435			jsr 	IdentifierSearch 			; does it exist
.b173	90 06		bcc $b17b			bcc 	_WVNoIdentifier
.b175	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.b177	f0 12		beq $b18b			beq 	_WVWriteTOS 				; if so write TOS to it.
.b179	80 52		bra $b1cd			bra 	_WVTypeError 				; not, then can't do anything.
.b17b					_WVNoIdentifier:
.b17b	5a		phy				phy 								; get current line number
.b17c	a0 01		ldy #$01			ldy 	#1
.b17e	b1 10		lda ($10),y			lda 	(codePtr),y
.b180	c8		iny				iny
.b181	11 10		ora ($10),y			ora 	(codePtr),y
.b183	f0 2e		beq $b1b3			beq 	_WVCantCreate 				; if zero (command line) no new vars
.b185	7a		ply				ply
.b186	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; create identifier
.b188	20 9c a4	jsr $a49c			jsr 	IdentifierCreate 			; try to find it
.b18b					_WVWriteTOS:
.b18b	88		dey				dey 								; skip over identifier.
.b18c					_WVSkipIdentifier:
.b18c	b1 10		lda ($10),y			lda 	(codePtr),y
.b18e	c8		iny				iny
.b18f	c9 e0		cmp #$e0			cmp 	#$E0
.b191	90 f9		bcc $b18c			bcc 	_WVSkipIdentifier
.b193	20 db b1	jsr $b1db			jsr 	IndexCheck 					; check index/subscript
.b196	5a		phy				phy									; copy TOS in
.b197	a0 00		ldy #$00			ldy 	#0
.b199	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b19c	91 22		sta ($22),y			sta 	(idDataAddr),y
.b19e	c8		iny				iny
.b19f	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b1a2	91 22		sta ($22),y			sta 	(idDataAddr),y
.b1a4	c8		iny				iny
.b1a5	bd 00 0e	lda $0e00,x			lda 	stack2,x
.b1a8	91 22		sta ($22),y			sta 	(idDataAddr),y
.b1aa	c8		iny				iny
.b1ab	bd 00 0f	lda $0f00,x			lda 	stack3,x
.b1ae	91 22		sta ($22),y			sta 	(idDataAddr),y
.b1b0	7a		ply				ply
.b1b1	ca		dex				dex 								; drop
.b1b2	60		rts				rts									; go back and execute again.
.b1b3					_WVCantCreate:
.b1b3	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b1b6	43 41 4e 4e 4f 54 20 43				.text 	"CANNOT CREATE VARIABLE",0
>b1be	52 45 41 54 45 20 56 41 52 49 41 42 4c 45 00
.b1cd					_WVTypeError:
.b1cd	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b1d0	57 52 4f 4e 47 20 54 59				.text 	"WRONG TYPE",0
>b1d8	50 45 00

;******  Return to file: main.asm


;******  Processing file: miscellany/indexing.asm

.b1db					IndexCheck:
.b1db	b1 10		lda ($10),y			lda 	(codePtr),y 				; check next character
.b1dd	c9 4b		cmp #$4b			cmp 	#KWD_LSQPAREN 				; is it [ ?
.b1df	d0 10		bne $b1f1			bne 	_ICExit
.b1e1	c8		iny				iny
.b1e2	b1 10		lda ($10),y			lda 	(codePtr),y 				; next is ] ?
.b1e4	c9 4c		cmp #$4c			cmp 	#KWD_RSQPAREN
.b1e6	f0 23		beq $b20b			beq 	_ICArrayAccess
.b1e8	29 c0		and #$c0			and 	#$C0 						; is it a constant
.b1ea	c9 80		cmp #$80			cmp 	#$80
.b1ec	f0 04		beq $b1f2			beq 	_ICConstAccess
.b1ee					_ICSyntax:
.b1ee	4c b0 a5	jmp $a5b0			jmp 	SyntaxError
.b1f1					_ICExit:
.b1f1	60		rts				rts
.b1f2					_ICConstAccess:
.b1f2	b1 10		lda ($10),y			lda 	(codePtr),y 				; get constant, copy in.
.b1f4	29 3f		and #$3f			and 	#$3F 						; to subscript in zTemp1
.b1f6	85 16		sta $16				sta 	zTemp1
.b1f8	64 17		stz $17				stz 	zTemp1+1
.b1fa	c8		iny				iny
.b1fb	b1 10		lda ($10),y			lda 	(codePtr),y 				; get next
.b1fd	c8		iny				iny
.b1fe	c9 4e		cmp #$4e			cmp 	#KWD_CONSTANT_PLUS 			; ok if K+
.b200	d0 ec		bne $b1ee			bne 	_ICSyntax
.b202	b1 10		lda ($10),y			lda 	(codePtr),y 				; get next
.b204	c8		iny				iny
.b205	c9 4c		cmp #$4c			cmp 	#KWD_RSQPAREN 				; ok if ]
.b207	d0 e5		bne $b1ee			bne 	_ICSyntax
.b209	80 0c		bra $b217			bra 	_ICAddSubscript
.b20b					_ICArrayAccess:
.b20b	c8		iny				iny 								; point to next
.b20c	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy TOS to zTemp1
.b20f	85 16		sta $16				sta 	zTemp1 						; no point in the rest !
.b211	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b214	85 17		sta $17				sta 	zTemp1+1
.b216	ca		dex				dex
.b217					_ICAddSubscript:
.b217	06 16		asl $16				asl 	zTemp1 						; subscript x 4
.b219	26 17		rol $17				rol 	zTemp1+1
.b21b	06 16		asl $16				asl 	zTemp1
.b21d	26 17		rol $17				rol 	zTemp1+1
.b21f	5a		phy				phy
.b220	b2 22		lda ($22)			lda 	(idDataAddr)				; check indirecting through 0
.b222	a0 01		ldy #$01			ldy 	#1
.b224	11 22		ora ($22),y			ora 	(idDataAddr),y 				; probably means uninitialised
.b226	c8		iny				iny
.b227	11 22		ora ($22),y			ora 	(idDataAddr),y
.b229	c8		iny				iny
.b22a	11 22		ora ($22),y			ora 	(idDataAddr),y
.b22c	f0 17		beq $b245			beq 	_ICZero
.b22e	18		clc				clc									; add zTemp1 to value at (idDataAddr)
.b22f	b2 22		lda ($22)			lda 	(idDataAddr)
.b231	65 16		adc $16				adc 	zTemp1
.b233	48		pha				pha
.b234	a0 01		ldy #$01			ldy 	#1
.b236	b1 22		lda ($22),y			lda 	(idDataAddr),y
.b238	65 17		adc $17				adc 	zTemp1+1
.b23a	85 23		sta $23				sta 	idDataAddr+1 				; write it out
.b23c	68		pla				pla
.b23d	85 22		sta $22				sta 	idDataAddr
.b23f	64 24		stz $24				stz 	idDataAddr+2 				; extend to 32 bits
.b241	64 25		stz $25				stz 	idDataAddr+3
.b243	7a		ply				ply
.b244	60		rts				rts
.b245					_ICZero:
.b245	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b248	55 4e 49 4e 49 54 49 41				.text 	"UNINITIALISED ARRAY",0
>b250	4c 49 53 45 44 20 41 52 52 41 59 00

;******  Return to file: main.asm


;******  Processing file: structures/if.asm

.b25c					Struct_IF:
.b25c	ca		dex				dex 								; drop TOS
.b25d	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check TOS
.b260	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.b263	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.b266	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.b269	f0 01		beq $b26c			beq 	_SIFSkipForward
.b26b	60		rts				rts
.b26c					_SIFSkipForward:
.b26c	a9 2c		lda #$2c			lda 	#KWD_ELSE
.b26e	4c 77 b2	jmp $b277			jmp 	StructSkipForward
.b271					Struct_ELSE:
.b271	a9 2e		lda #$2e			lda 	#KWD_ENDIF
.b273	4c 77 b2	jmp $b277			jmp 	StructSkipForward
.b276					Struct_ENDIF:
.b276	60		rts				rts
.b277					StructSkipForward:
.b277	85 14		sta $14				sta 	zTemp0 						; 2nd match
.b279					_SSFLoop:
.b279	b1 10		lda ($10),y			lda 	(codePtr),y 				; read it
.b27b	f0 14		beq $b291			beq 	_SSFExit 					; if EOL then exit
.b27d	c8		iny				iny 								; advance past it
.b27e	c9 2e		cmp #$2e			cmp 	#KWD_ENDIF 					; exit if ENDIF or 2nd match
.b280	f0 0f		beq $b291			beq 	_SSFExit
.b282	c5 14		cmp $14				cmp 	zTemp0
.b284	f0 0b		beq $b291			beq 	_SSFExit
.b286	c9 03		cmp #$03			cmp 	#3 							; if not 1,2 go round again
.b288	b0 ef		bcs $b279			bcs 	_SSFLoop
.b28a	98		tya				tya 								; add length offset
.b28b	3a		dec a				dec 	a
.b28c	71 10		adc ($10),y			adc 	(codePtr),y
.b28e	a8		tay				tay
.b28f	80 e8		bra $b279			bra 	_SSFLoop
.b291					_SSFExit:
.b291	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: structures/fornext.asm

.b292					Command_For:
.b292	20 97 b3	jsr $b397			jsr 	StructPushCurrent 			; push current on the stack.
.b295	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check zero
.b298	1d 00 0d	ora $0d00,x			ora 	stack1,x
.b29b	1d 00 0e	ora $0e00,x			ora 	stack2,x
.b29e	1d 00 0f	ora $0f00,x			ora 	stack3,x
.b2a1	f0 34		beq $b2d7			beq 	_CFZero
.b2a3	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; push 1's complement of index on
.b2a6	49 ff		eor #$ff			eor 	#$FF 						; structure stack.
.b2a8	c6 12		dec $12				dec 	StructSP
.b2aa	92 12		sta ($12)			sta 	(StructSP)
.b2ac	bd 00 0e	lda $0e00,x			lda 	stack2,x
.b2af	49 ff		eor #$ff			eor 	#$FF
.b2b1	c6 12		dec $12				dec 	StructSP
.b2b3	92 12		sta ($12)			sta 	(StructSP)
.b2b5	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b2b8	49 ff		eor #$ff			eor 	#$FF
.b2ba	c6 12		dec $12				dec 	StructSP
.b2bc	92 12		sta ($12)			sta 	(StructSP)
.b2be	bd 00 0c	lda $0c00,x			lda 	stack0,x
.b2c1	49 ff		eor #$ff			eor 	#$FF
.b2c3	c6 12		dec $12				dec 	StructSP
.b2c5	92 12		sta ($12)			sta 	(StructSP)
.b2c7	ca		dex				dex 								; pop stack value
.b2c8	a9 46		lda #$46			lda 	#STM_FOR 					; push FOR marker
.b2ca	c6 12		dec $12				dec 	StructSP
.b2cc	92 12		sta ($12)			sta 	(StructSP)
.b2ce	a5 12		lda $12				lda 	StructSP 					; copy current so it can access it.
.b2d0	85 24		sta $24				sta 	ForAddr
.b2d2	a5 13		lda $13				lda 	StructSP+1
.b2d4	85 25		sta $25				sta 	ForAddr+1
.b2d6	60		rts				rts
.b2d7					_CFZero:
.b2d7	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b2da	46 4f 52 20 43 4f 55 4e				.text 	"FOR COUNT ZERO",0
>b2e2	54 20 5a 45 52 4f 00
.b2e9					Command_Next:
.b2e9	b2 12		lda ($12)			lda 	(StructSP)					; check it's FOR.
.b2eb	c9 46		cmp #$46			cmp 	#STM_FOR
.b2ed	d0 30		bne $b31f			bne 	_CNNoFor
.b2ef	5a		phy				phy
.b2f0	a0 00		ldy #$00			ldy 	#0
.b2f2					_CNIncrement:
.b2f2	c8		iny				iny
.b2f3	b1 12		lda ($12),y			lda 	(StructSP),y 				; increment the index
.b2f5	1a		inc a				inc 	a
.b2f6	91 12		sta ($12),y			sta 	(StructSP),y
.b2f8	f0 f8		beq $b2f2			beq		_CNIncrement 				; carry out.
.b2fa	a0 01		ldy #$01			ldy 	#1 							; now and all the counts together
.b2fc	b1 12		lda ($12),y			lda 	(StructSP),y 				; on the last time round they
.b2fe	c8		iny				iny 								; will all be $FF
.b2ff	31 12		and ($12),y			and 	(StructSP),y
.b301	c8		iny				iny
.b302	31 12		and ($12),y			and 	(StructSP),y
.b304	c8		iny				iny
.b305	31 12		and ($12),y			and 	(StructSP),y
.b307	7a		ply				ply 								; restore Y
.b308	1a		inc a				inc 	a 							; so this will be zero last time round
.b309	d0 06		bne $b311			bne 	_CNLoop 					; loop back if non-zero
.b30b	a9 09		lda #$09			lda 	#9 							; pop 9 elements off structure stack.
.b30d	20 91 b3	jsr $b391			jsr 	StructPopCount
.b310	60		rts				rts
.b311					_CNLoop:
.b311	a5 12		lda $12				lda 	StructSP 					; copy current so it can access it.
.b313	85 24		sta $24				sta 	ForAddr
.b315	a5 13		lda $13				lda 	StructSP+1
.b317	85 25		sta $25				sta 	ForAddr+1
.b319	a0 05		ldy #$05			ldy 	#5 							; restore the position
.b31b	20 cb b3	jsr $b3cb			jsr 	StructPopCurrent
.b31e	60		rts				rts
.b31f					_CNNoFor:
.b31f	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b322	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>b32a	46 4f 52 00
.b32e					Command_Index:
.b32e	5a		phy				phy
.b32f	a0 01		ldy #$01			ldy 	#1 							; get the stack position of
.b331	e8		inx				inx
.b332	38		sec				sec
.b333	a9 fe		lda #$fe			lda 	#$FE
.b335	f1 24		sbc ($24),y			sbc 	(ForAddr),y
.b337	9d 00 0c	sta $0c00,x			sta 	stack0,x
.b33a	c8		iny				iny
.b33b	a9 ff		lda #$ff			lda 	#$FF
.b33d	f1 24		sbc ($24),y			sbc 	(ForAddr),y
.b33f	9d 00 0d	sta $0d00,x			sta 	stack1,x
.b342	c8		iny				iny
.b343	a9 ff		lda #$ff			lda 	#$FF
.b345	f1 24		sbc ($24),y			sbc 	(ForAddr),y
.b347	9d 00 0e	sta $0e00,x			sta 	stack2,x
.b34a	c8		iny				iny
.b34b	a9 ff		lda #$ff			lda 	#$FF
.b34d	f1 24		sbc ($24),y			sbc 	(ForAddr),y
.b34f	9d 00 0f	sta $0f00,x			sta 	stack3,x
.b352	7a		ply				ply
.b353	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: structures/repeat.asm

.b354					Command_Repeat:
.b354	20 97 b3	jsr $b397			jsr 	StructPushCurrent 			; push current on the stack.
.b357	a9 52		lda #$52			lda 	#STM_REPEAT 				; push marker
.b359	c6 12		dec $12				dec 	StructSP
.b35b	92 12		sta ($12)			sta 	(StructSP)
.b35d	60		rts				rts
.b35e					Command_Until:
.b35e	b2 12		lda ($12)			lda 	(StructSP)					; check it's REPEAT
.b360	c9 52		cmp #$52			cmp 	#STM_REPEAT
.b362	d0 1b		bne $b37f			bne 	_CUNoRepeat
.b364	ca		dex				dex 								; pop
.b365	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check old TOS zero
.b368	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.b36b	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.b36e	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.b371	f0 06		beq $b379			beq 	_CULoop
.b373	a9 05		lda #$05			lda 	#5 							; pop 5 elements off structure stack.
.b375	20 91 b3	jsr $b391			jsr 	StructPopCount
.b378	60		rts				rts
.b379					_CULoop:
.b379	a0 01		ldy #$01			ldy 	#1 							; restore the position
.b37b	20 cb b3	jsr $b3cb			jsr 	StructPopCurrent
.b37e	60		rts				rts
.b37f					_CUNoRepeat:
.b37f	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b382	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>b38a	52 45 50 45 41 54 00

;******  Return to file: main.asm


;******  Processing file: structures/structures.asm

.b391					StructPopCount:
.b391	18		clc				clc
.b392	65 12		adc $12				adc 	StructSP
.b394	85 12		sta $12				sta 	StructSP
.b396	60		rts				rts
.b397					StructPushCurrent:
.b397	a5 12		lda $12				lda 	StructSP 					; check space for more
.b399	c9 0a		cmp #$0a			cmp 	#10
.b39b	90 18		bcc $b3b5			bcc 	_SPCSpace
.b39d	a9 00		lda #$00			lda 	#0							; push bank
.b39f	c6 12		dec $12				dec 	StructSP
.b3a1	92 12		sta ($12)			sta 	(StructSP)
.b3a3	98		tya				tya									; y Offset
.b3a4	c6 12		dec $12				dec 	StructSP
.b3a6	92 12		sta ($12)			sta 	(StructSP)
.b3a8	a5 11		lda $11				lda 	codePtr+1 					; codeptr high
.b3aa	c6 12		dec $12				dec 	StructSP
.b3ac	92 12		sta ($12)			sta 	(StructSP)
.b3ae	a5 10		lda $10				lda 	codePtr 					; codeptr low
.b3b0	c6 12		dec $12				dec 	StructSP
.b3b2	92 12		sta ($12)			sta 	(StructSP)
.b3b4	60		rts				rts
.b3b5					_SPCSpace:
.b3b5	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b3b8	52 45 54 55 52 4e 20 53				.text 	"RETURN STACK SPACE",0
>b3c0	54 41 43 4b 20 53 50 41 43 45 00
.b3cb					StructPopCurrent:
.b3cb	b1 12		lda ($12),y			lda 	(StructSP),y 				; codeptr low
.b3cd	85 10		sta $10				sta 	codePtr
.b3cf	c8		iny				iny
.b3d0	b1 12		lda ($12),y			lda 	(StructSP),y 				; codeptr high
.b3d2	85 11		sta $11				sta 	codePtr+1
.b3d4	c8		iny				iny
.b3d5	b1 12		lda ($12),y			lda 	(StructSP),y				; y offset
.b3d7	a8		tay				tay
.b3d8	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/hashes.inc

.b3d9					libfunc_1000:
>b3d9	00 00					.word 0
>b3db	0a b4 00 00				.dword String_Len
>b3df	e3 b3					.word libfunc_1000_name
>b3e1	00 43					.byte 0,'C'
.b3e3					libfunc_1000_name:
>b3e3	d2 d3 d1 df cb c4 ed			.byte $d2,$d3,$d1,$df,$cb,$c4,$ed
.b3ea					DefaultHashTable:
>b3ea	00 00					.word 0
>b3ec	00 00					.word 0
>b3ee	d9 b3					.word libfunc_1000
>b3f0	00 00					.word 0
>b3f2	00 00					.word 0
>b3f4	00 00					.word 0
>b3f6	00 00					.word 0
>b3f8	00 00					.word 0
>b3fa	00 00					.word 0
>b3fc	00 00					.word 0
>b3fe	00 00					.word 0
>b400	00 00					.word 0
>b402	00 00					.word 0
>b404	00 00					.word 0
>b406	00 00					.word 0
>b408	00 00					.word 0

;******  Return to file: main.asm


;******  Processing file: generated/library.inc

.b40a					String_Len:
.b40a	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy string address
.b40d	85 14		sta $14				sta 	zTemp0
.b40f	bd 00 0d	lda $0d00,x			lda 	stack1,x
.b412	85 15		sta $15				sta 	zTemp0+1
.b414	5a		phy				phy
.b415	a0 ff		ldy #$ff			ldy 	#255 						; find string length
.b417	c8		iny		_SLLoop:iny
.b418	c0 ff		cpy #$ff			cpy 	#255 						; cant find EOS.
.b41a	f0 13		beq $b42f			beq 	_SLFail
.b41c	b1 14		lda ($14),y			lda 	(zTemp0),y
.b41e	d0 f7		bne $b417			bne 	_SLLoop
.b420	98		tya				tya
.b421	7a		ply				ply
.b422	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; return string
.b425	9e 00 0d	stz $0d00,x			stz 	stack1,x
.b428	9e 00 0e	stz $0e00,x			stz 	stack2,x
.b42b	9e 00 0f	stz $0f00,x			stz 	stack3,x
.b42e	60		rts				rts
.b42f					_SLFail:
.b42f	20 d1 a5	jsr $a5d1			jsr 	ErrorHandler
>b432	4e 4f 54 20 53 54 52 49				.text 	"NOT STRING",0
>b43a	4e 47 00

;******  Return to file: main.asm


;******  Processing file: generated/testcode.inc

>1100	08 64 00 83 80 b9 4e 00			.byte $08,$64,$00,$83,$80,$b9,$4e,$00,$1c,$6e,$00,$01,$11,$68,$65,$6c,$6c,$6f,$2c,$20,$77,$6f,$72,$6c,$64,$20,$21,$00,$d2,$d3,$d1,$df,$cb,$c4,$ed,$00,$08,$78,$00,$8d,$90,$b1,$4e,$00,$06,$82,$00,$16,$2d,$00,$1f,$8c,$00,$29,$d2,$cf,$d1,$c8,$cd,$f3,$2b,$80,$4e,$19,$30,$ad,$4e,$c4,$cc,$c8,$f3,$35,$2e,$d4,$cf,$d1,$c8,$cd,$f3,$18,$00,$26,$96,$00,$29,$d4,$cf,$d1,$c8,$cd,$f3,$2b,$8a,$4e,$1f,$30,$2b,$8a,$4e,$17,$d4,$cf,$d1,$c8,$cd,$f3,$8a,$4e,$34,$2e,$b0,$4e,$12,$c4,$cc,$c8,$f3,$18,$00,$11,$a0,$00,$29,$c4,$cc,$c8,$f3,$4d,$e0,$8f,$bf,$92,$4e,$46,$18,$00
>1108	1c 6e 00 01 11 68 65 6c 6c 6f 2c 20 77 6f 72 6c
>1118	64 20 21 00 d2 d3 d1 df cb c4 ed 00 08 78 00 8d
>1128	90 b1 4e 00 06 82 00 16 2d 00 1f 8c 00 29 d2 cf
>1138	d1 c8 cd f3 2b 80 4e 19 30 ad 4e c4 cc c8 f3 35
>1148	2e d4 cf d1 c8 cd f3 18 00 26 96 00 29 d4 cf d1
>1158	c8 cd f3 2b 8a 4e 1f 30 2b 8a 4e 17 d4 cf d1 c8
>1168	cd f3 8a 4e 34 2e b0 4e 12 c4 cc c8 f3 18 00 11
>1178	a0 00 29 c4 cc c8 f3 4d e0 8f bf 92 4e 46 18 00

;******  Return to file: main.asm

>1188	00						.byte 	0

;******  End of listing
