
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -D debug=0 -q -c -o rpl32.prg -L rpl32.lst main.asm
; Mon Oct  7 13:05:20 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					debug=0

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; build the interpreter here
=$0c00					StackAddress = $0C00 						; 1k of stack space (256 x 32 bits)
=$1000					MemoryStart = $1000 						; system memory starts here
=$6000					MemoryEnd = $6000 							; and ends here.
=$0bff					StructureStack = $0BFF 						; structure stack (works down to $xx00)
=$0800					ExtDataArea = $0800 						; space where non zp data goes
=$0900					InputBuffer = $0900 						; Input Buffer
=$0a00					TokeniseBuffer = $0A00						; Tokenising buffer
=16					HashTableSize = 16 							; hash tables to search.
>0000					CodePtr: 		.word ? 					; code pointer
>0002					StructSP: 		.word ?						; structure stack pointer
>0004					zTemp0:			.word ?						; temporary words
>0006					zTemp1: 		.word ?
>0008					zTemp2: 		.word ?
>000a					zTemp3: 		.word ?
>000c					zTemp4:			.word ?
>000e					zLTemp1:		.dword ?					; temporary longs
>0012					idDataAddr:		.word ? 					; data address.
>0014					ForAddr:		.byte ? 					; points to current FOR structure
>0800					SBuffer:		.fill 32 					; string buffer
>0820					SBPosition:		.byte ? 					; position in String Buffer
>0821					NumConvCount:	.byte ? 					; used in int to string
>0822					breakCount:		.byte ? 					; used to stop break firing every execution.
>0823					SignCount:		.byte ?						; sign count for divide
>0824					NumSuppress:	.byte ? 					; zero suppression flag
>1000					AZVariables:	.fill	26*4 				; 26 x 4 byte variables, which are A-Z
>1068					HashTable: 		.fill 	HashTableSize * 2 	; n x 2 links for the hash tables.
>1088	00 00				VarMemory:		.word 	0 					; next free byte available for VARIABLES (going up)
>108a	00 00				AllocMemory: 	.word 	0 					; last free byte availabel for ALLOC (going down)
=4352					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0c00					stack0 = StackAddress
=3328					stack1 = StackAddress+256
=3584					stack2 = StackAddress+512
=3840					stack3 = StackAddress+768
="V"					IDT_VARIABLE = 'V'							; type markers for the information store.
="P"					IDT_PROCEDURE = 'P'							; standard procedure (e.g. in code)
="C"					IDT_CODEPROC = 'C'							; machine language procedure.
="F"					STM_FOR = 'F'								; structure markers (for/next)
="C"					STM_CALL = 'C'								; call & return  (& ;)
="R"					STM_REPEAT = 'R'							; repeat & until
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=5					CTH_ERROR = COL_MAGENTA
=2					CTH_TOKEN = COL_GREEN
=3					CTH_IDENT = COL_YELLOW
=7					CTH_COMMENT = COL_WHITE
=5					CTH_STRING = COL_MAGENTA
=6					CTH_NUMBER = COL_CYAN

;******  Return to file: main.asm


;******  Processing file: macro.asm


;******  Return to file: main.asm

.0f00	4c 00 a0	jmp $a000			jmp 	Start
.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 e8 a1	jsr $a1e8			jsr 	ExternInitialise 			; interface setup
.a006	a2 00		ldx #$00			ldx 	#0 							; display boot message
.a008					_Display:
.a008	bd 56 a0	lda $a056,x			lda 	BootMessage,x
.a00b	20 09 a2	jsr $a209			jsr 	ExternPrint
.a00e	e8		inx				inx
.a00f	bd 56 a0	lda $a056,x			lda 	BootMessage,x
.a012	d0 f4		bne $a008			bne 	_Display
.a014	20 fe a3	jsr $a3fe			jsr 	ResetForRun
.a017	20 f3 a3	jsr $a3f3			jsr 	ResetCodePointer
.a01a					WarmStart:
.a01a	8a		txa				txa
.a01b	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack colour
.a01d	9a		txs				txs
.a01e	aa		tax				tax
.a01f	a9 0d		lda #$0d			lda 	#13
.a021	20 09 a2	jsr $a209			jsr 	ExternPrint
.a024	a9 07		lda #$07			lda 	#COL_WHITE
.a026	20 13 a2	jsr $a213			jsr 	ExternColour
.a029	20 27 a2	jsr $a227			jsr 	ExternInput 				; input text
.a02c	a9 00		lda #$00			lda 	#InputBuffer & $FF 			; codePtr = input buffer
.a02e	85 00		sta $00				sta 	codePtr
.a030	a9 09		lda #$09			lda 	#InputBuffer >> 8
.a032	85 01		sta $01				sta 	codePtr+1
.a034	a9 03		lda #$03			lda 	#(TokeniseBuffer+3) & $FF 	; zTemp1 is set up as a fake line
.a036	85 06		sta $06				sta 	zTemp1 						; with line number 0 by being
.a038	a9 0a		lda #$0a			lda 	#(TokeniseBuffer+3) >> 8 	; prefixed with three zeros
.a03a	85 07		sta $07				sta 	zTemp1+1
.a03c	9c 00 0a	stz $0a00			stz 	TokeniseBuffer+0			; put in those three zeroes
.a03f	9c 01 0a	stz $0a01			stz		TokeniseBuffer+1
.a042	9c 02 0a	stz $0a02			stz 	TokeniseBuffer+2
.a045	20 77 a7	jsr $a777			jsr 	Tokenise
.a048	a9 00		lda #$00			lda 	#TokeniseBuffer & 255 		; set tokenise buffer as faux line
.a04a	85 00		sta $00				sta 	codePtr
.a04c	a9 0a		lda #$0a			lda 	#TokeniseBuffer >> 8
.a04e	85 01		sta $01				sta 	codePtr+1
.a050	a0 03		ldy #$03			ldy 	#3
>a052	ff						.byte 	$FF
.a053	4c 60 a2	jmp $a260			jmp 	Execute 					; and run it
.a056					BootMessage:

;******  Processing file: generated/bootmessage.inc

>a056	2a 2a 2a 2a 20 52 50 4c			.byte $2a,$2a,$2a,$2a,$20,$52,$50,$4c,$2f,$33,$32,$20,$49,$4e,$54,$45,$52,$50,$52,$45,$54,$45,$52,$20,$2a,$2a,$2a,$2a,$0d,$0d,$42,$55,$49,$4c,$44,$3a,$44,$45,$56,$20,$44,$41,$54,$45,$3a,$30,$37,$2d,$4f,$43,$54,$2d,$32,$30,$31,$39,$0d,$0d,$00
>a05e	2f 33 32 20 49 4e 54 45 52 50 52 45 54 45 52 20
>a06e	2a 2a 2a 2a 0d 0d 42 55 49 4c 44 3a 44 45 56 20
>a07e	44 41 54 45 3a 30 37 2d 4f 43 54 2d 32 30 31 39
>a08e	0d 0d 00

;******  Return to file: main.asm


;******  Processing file: generated/tables.inc

.a091					KeywordText:
>a091	01 21					.byte $01,$21                          ; $10 !
>a093	01 26					.byte $01,$26                          ; $11 &
>a095	01 2a					.byte $01,$2a                          ; $12 *
>a097	01 2b					.byte $01,$2b                          ; $13 +
>a099	02 2b 2b				.byte $02,$2b,$2b                      ; $14 ++
>a09c	01 2d					.byte $01,$2d                          ; $15 -
>a09e	02 2d 2d				.byte $02,$2d,$2d                      ; $16 --
>a0a1	01 2e					.byte $01,$2e                          ; $17 .
>a0a3	01 2f					.byte $01,$2f                          ; $18 /
>a0a5	01 3b					.byte $01,$3b                          ; $19 ;
>a0a7	01 3c					.byte $01,$3c                          ; $1a <
>a0a9	02 3c 3c				.byte $02,$3c,$3c                      ; $1b <<
>a0ac	02 3c 3d				.byte $02,$3c,$3d                      ; $1c <=
>a0af	02 3c 3e				.byte $02,$3c,$3e                      ; $1d <>
>a0b2	01 3d					.byte $01,$3d                          ; $1e =
>a0b4	01 3e					.byte $01,$3e                          ; $1f >
>a0b6	02 3e 3d				.byte $02,$3e,$3d                      ; $20 >=
>a0b9	02 3e 3e				.byte $02,$3e,$3e                      ; $21 >>
>a0bc	01 40					.byte $01,$40                          ; $22 @
>a0be	03 41 42 53				.byte $03,$41,$42,$53                  ; $23 ABS
>a0c2	05 41 4c 4c 4f 43			.byte $05,$41,$4c,$4c,$4f,$43          ; $24 ALLOC
>a0c8	03 41 4e 44				.byte $03,$41,$4e,$44                  ; $25 AND
>a0cc	06 41 53 53 45 52 54			.byte $06,$41,$53,$53,$45,$52,$54      ; $26 ASSERT
>a0d3	02 43 21				.byte $02,$43,$21                      ; $27 C!
>a0d6	02 43 40				.byte $02,$43,$40                      ; $28 C@
>a0d9	03 44 45 46				.byte $03,$44,$45,$46                  ; $29 DEF
>a0dd	04 44 52 4f 50				.byte $04,$44,$52,$4f,$50              ; $2a DROP
>a0e2	03 44 55 50				.byte $03,$44,$55,$50                  ; $2b DUP
>a0e6	04 45 4c 53 45				.byte $04,$45,$4c,$53,$45              ; $2c ELSE
>a0eb	05 45 4d 50 54 59			.byte $05,$45,$4d,$50,$54,$59          ; $2d EMPTY
>a0f1	03 45 4e 44				.byte $03,$45,$4e,$44                  ; $2e END
>a0f5	05 45 4e 44 49 46			.byte $05,$45,$4e,$44,$49,$46          ; $2f ENDIF
>a0fb	03 46 4f 52				.byte $03,$46,$4f,$52                  ; $30 FOR
>a0ff	02 49 46				.byte $02,$49,$46                      ; $31 IF
>a102	05 49 4e 44 45 58			.byte $05,$49,$4e,$44,$45,$58          ; $32 INDEX
>a108	04 4c 49 53 54				.byte $04,$4c,$49,$53,$54              ; $33 LIST
>a10d	03 4d 4f 44				.byte $03,$4d,$4f,$44                  ; $34 MOD
>a111	06 4e 45 47 41 54 45			.byte $06,$4e,$45,$47,$41,$54,$45      ; $35 NEGATE
>a118	03 4e 45 57				.byte $03,$4e,$45,$57                  ; $36 NEW
>a11c	04 4e 45 58 54				.byte $04,$4e,$45,$58,$54              ; $37 NEXT
>a121	03 4e 49 50				.byte $03,$4e,$49,$50                  ; $38 NIP
>a125	03 4e 4f 54				.byte $03,$4e,$4f,$54                  ; $39 NOT
>a129	03 4f 4c 44				.byte $03,$4f,$4c,$44                  ; $3a OLD
>a12d	02 4f 52				.byte $02,$4f,$52                      ; $3b OR
>a130	04 4f 56 45 52				.byte $04,$4f,$56,$45,$52              ; $3c OVER
>a135	06 52 45 50 45 41 54			.byte $06,$52,$45,$50,$45,$41,$54      ; $3d REPEAT
>a13c	03 52 55 4e				.byte $03,$52,$55,$4e                  ; $3e RUN
>a140	03 53 48 4c				.byte $03,$53,$48,$4c                  ; $3f SHL
>a144	03 53 48 52				.byte $03,$53,$48,$52                  ; $40 SHR
>a148	04 53 54 4f 50				.byte $04,$53,$54,$4f,$50              ; $41 STOP
>a14d	04 53 57 41 50				.byte $04,$53,$57,$41,$50              ; $42 SWAP
>a152	03 53 59 53				.byte $03,$53,$59,$53                  ; $43 SYS
>a156	05 55 4e 54 49 4c			.byte $05,$55,$4e,$54,$49,$4c          ; $44 UNTIL
>a15c	02 57 21				.byte $02,$57,$21                      ; $45 W!
>a15f	02 57 40				.byte $02,$57,$40                      ; $46 W@
>a162	03 58 4f 52				.byte $03,$58,$4f,$52                  ; $47 XOR
>a166	02 5b 5d				.byte $02,$5b,$5d                      ; $48 []
>a169	01 5e					.byte $01,$5e                          ; $49 ^
>a16b	01 2b					.byte $01,$2b                          ; $4a {+}
>a16d	01 2d					.byte $01,$2d                          ; $4b {-}
>a16f	00					.byte $00
.a170					KeywordVectorTable:
>a170	90 aa					.word Mem_DPoke                        ; $10 !
>a172	eb a4					.word SyntaxError                      ; $11 &
>a174	ae ab					.word MulInteger32                     ; $12 *
>a176	b7 aa					.word Stack_Add                        ; $13 +
>a178	b7 a9					.word Unary_Increment                  ; $14 ++
>a17a	de aa					.word Stack_Sub                        ; $15 -
>a17c	ca a9					.word Unary_Decrement                  ; $16 --
>a17e	b5 ad					.word System_ShowStack                 ; $17 .
>a180	f7 ab					.word DivInteger32                     ; $18 /
>a182	eb a4					.word SyntaxError                      ; $19 ;
>a184	de ac					.word Comp_Less                        ; $1a <
>a186	ec a9					.word Unary_Shl                        ; $1b <<
>a188	09 ad					.word Comp_LessEqual                   ; $1c <=
>a18a	a7 ac					.word Comp_NotEqual                    ; $1d <>
>a18c	a4 ac					.word Comp_Equal                       ; $1e =
>a18e	0c ad					.word Comp_Greater                     ; $1f >
>a190	e1 ac					.word Comp_GreaterEqual                ; $20 >=
>a192	f9 a9					.word Unary_Shr                        ; $21 >>
>a194	3e aa					.word Mem_DPeek                        ; $22 @
>a196	6e a9					.word Unary_Absolute                   ; $23 ABS
>a198	eb a4					.word SyntaxError                      ; $24 ALLOC
>a19a	05 ab					.word Stack_And                        ; $25 AND
>a19c	48 ad					.word System_Assert                    ; $26 ASSERT
>a19e	63 aa					.word Mem_Poke                         ; $27 C!
>a1a0	06 aa					.word Mem_Peek                         ; $28 C@
>a1a2	eb a4					.word SyntaxError                      ; $29 DEF
>a1a4	e3 a8					.word Stack_Drop                       ; $2a DROP
>a1a6	e5 a8					.word Stack_Dup                        ; $2b DUP
>a1a8	eb a4					.word SyntaxError                      ; $2c ELSE
>a1aa	e0 a8					.word Stack_Empty                      ; $2d EMPTY
>a1ac	3d ad					.word System_END                       ; $2e END
>a1ae	eb a4					.word SyntaxError                      ; $2f ENDIF
>a1b0	a1 ae					.word Command_For                      ; $30 FOR
>a1b2	eb a4					.word SyntaxError                      ; $31 IF
>a1b4	3d af					.word Command_Index                    ; $32 INDEX
>a1b6	59 a6					.word Cmd_List                         ; $33 LIST
>a1b8	8c ac					.word ModInteger32                     ; $34 MOD
>a1ba	74 a9					.word Unary_Negate                     ; $35 NEGATE
>a1bc	62 ad					.word System_New                       ; $36 NEW
>a1be	f8 ae					.word Command_Next                     ; $37 NEXT
>a1c0	ff a8					.word Stack_Nip                        ; $38 NIP
>a1c2	96 a9					.word Unary_Not                        ; $39 NOT
>a1c4	69 ad					.word System_Old                       ; $3a OLD
>a1c6	51 ab					.word Stack_Or                         ; $3b OR
>a1c8	19 a9					.word Stack_Over                       ; $3c OVER
>a1ca	63 af					.word Command_Repeat                   ; $3d REPEAT
>a1cc	34 ad					.word System_RUN                       ; $3e RUN
>a1ce	77 ab					.word Stack_Shl                        ; $3f SHL
>a1d0	7a ab					.word Stack_Shr                        ; $40 SHR
>a1d2	40 ad					.word System_STOP                      ; $41 STOP
>a1d4	33 a9					.word Stack_Swap                       ; $42 SWAP
>a1d6	8d ad					.word System_Sys                       ; $43 SYS
>a1d8	6d af					.word Command_Until                    ; $44 UNTIL
>a1da	75 aa					.word Mem_WPoke                        ; $45 W!
>a1dc	1f aa					.word Mem_WPeek                        ; $46 W@
>a1de	2b ab					.word Stack_Xor                        ; $47 XOR
>a1e0	eb a4					.word SyntaxError                      ; $48 []
>a1e2	3e ae					.word WriteVariable                    ; $49 ^
>a1e4	eb a4					.word SyntaxError                      ; $4a {+}
>a1e6	eb a4					.word SyntaxError                      ; $4b {-}
=$10					KWD_PLING = $10                  ; $10 !
=$11					KWD_AMPERSAND = $11              ; $11 &
=$12					KWD_ASTERISK = $12               ; $12 *
=$13					KWD_PLUS = $13                   ; $13 +
=$14					KWD_PLUSPLUS = $14               ; $14 ++
=$15					KWD_MINUS = $15                  ; $15 -
=$16					KWD_MINUSMINUS = $16             ; $16 --
=$17					KWD_DOT = $17                    ; $17 .
=$18					KWD_SLASH = $18                  ; $18 /
=$19					KWD_SEMICOLON = $19              ; $19 ;
=$1a					KWD_LESS = $1a                   ; $1a <
=$1b					KWD_LESSLESS = $1b               ; $1b <<
=$1c					KWD_LESSEQUAL = $1c              ; $1c <=
=$1d					KWD_LESSGREATER = $1d            ; $1d <>
=$1e					KWD_EQUAL = $1e                  ; $1e =
=$1f					KWD_GREATER = $1f                ; $1f >
=$20					KWD_GREATEREQUAL = $20           ; $20 >=
=$21					KWD_GREATERGREATER = $21         ; $21 >>
=$22					KWD_AT = $22                     ; $22 @
=$23					KWD_ABS = $23                    ; $23 ABS
=$24					KWD_ALLOC = $24                  ; $24 ALLOC
=$25					KWD_AND = $25                    ; $25 AND
=$26					KWD_ASSERT = $26                 ; $26 ASSERT
=$27					KWD_CPLING = $27                 ; $27 C!
=$28					KWD_CAT = $28                    ; $28 C@
=$29					KWD_DEF = $29                    ; $29 DEF
=$2a					KWD_DROP = $2a                   ; $2a DROP
=$2b					KWD_DUP = $2b                    ; $2b DUP
=$2c					KWD_ELSE = $2c                   ; $2c ELSE
=$2d					KWD_EMPTY = $2d                  ; $2d EMPTY
=$2e					KWD_END = $2e                    ; $2e END
=$2f					KWD_ENDIF = $2f                  ; $2f ENDIF
=$30					KWD_FOR = $30                    ; $30 FOR
=$31					KWD_IF = $31                     ; $31 IF
=$32					KWD_INDEX = $32                  ; $32 INDEX
=$33					KWD_LIST = $33                   ; $33 LIST
=$34					KWD_MOD = $34                    ; $34 MOD
=$35					KWD_NEGATE = $35                 ; $35 NEGATE
=$36					KWD_NEW = $36                    ; $36 NEW
=$37					KWD_NEXT = $37                   ; $37 NEXT
=$38					KWD_NIP = $38                    ; $38 NIP
=$39					KWD_NOT = $39                    ; $39 NOT
=$3a					KWD_OLD = $3a                    ; $3a OLD
=$3b					KWD_OR = $3b                     ; $3b OR
=$3c					KWD_OVER = $3c                   ; $3c OVER
=$3d					KWD_REPEAT = $3d                 ; $3d REPEAT
=$3e					KWD_RUN = $3e                    ; $3e RUN
=$3f					KWD_SHL = $3f                    ; $3f SHL
=$40					KWD_SHR = $40                    ; $40 SHR
=$41					KWD_STOP = $41                   ; $41 STOP
=$42					KWD_SWAP = $42                   ; $42 SWAP
=$43					KWD_SYS = $43                    ; $43 SYS
=$44					KWD_UNTIL = $44                  ; $44 UNTIL
=$45					KWD_WPLING = $45                 ; $45 W!
=$46					KWD_WAT = $46                    ; $46 W@
=$47					KWD_XOR = $47                    ; $47 XOR
=$48					KWD_LSQPARENRSQPAREN = $48       ; $48 []
=$49					KWD_HAT = $49                    ; $49 ^
=$4a					KWD_CONSTANT_PLUS = $4a          ; $4a {+}
=$4b					KWD_CONSTANT_MINUS = $4b         ; $4b {-}

;******  Return to file: main.asm


;******  Processing file: system/extern.asm

.a1e8					ExternInitialise:
.a1e8	a9 07		lda #$07			lda 	#$07 						; set colour
.a1ea	8d 86 02	sta $0286			sta 	646
.a1ed	a9 0e		lda #$0e			lda 	#14							; lower case
.a1ef	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1f2	a9 93		lda #$93			lda 	#147 						; clear screen
.a1f4	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1f7	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a1f9	4c 13 a2	jmp $a213			jmp 	ExternColour
.a1fc					ExternCheckBreak:
.a1fc	da		phx				phx 								; make sure we keep XY
.a1fd	5a		phy				phy
.a1fe	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a201	f0 03		beq $a206			beq		_ECBExit 					; stopped
.a203	7a		ply				ply 								; restore and exit.
.a204	fa		plx				plx
.a205	60		rts				rts
.a206					_ECBExit:
.a206	4c 1a a0	jmp $a01a			jmp 	WarmStart
.a209					ExternPrint:
.a209	48		pha				pha
.a20a	da		phx				phx
.a20b	5a		phy				phy
.a20c	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a20f	7a		ply				ply
.a210	fa		plx				plx
.a211	68		pla				pla
.a212	60		rts				rts
.a213					ExternColour:
.a213	48		pha				pha
.a214	da		phx				phx
.a215	aa		tax				tax
.a216	bd 1f a2	lda $a21f,x			lda 	_ECTable,x
.a219	20 09 a2	jsr $a209			jsr 	ExternPrint
.a21c	fa		plx				plx
.a21d	68		pla				pla
.a21e	60		rts				rts
.a21f					_ECTable:
>a21f	90						.byte 	144
>a220	1c						.byte 	28
>a221	1e						.byte 	30
>a222	9e						.byte 	158
>a223	1f						.byte 	31
>a224	9c						.byte 	156
>a225	9f						.byte 	159
>a226	05						.byte 	5
.a227					ExternInput:
.a227	a9 00		lda #$00			lda 	#(InputBuffer & $FF)
.a229	85 04		sta $04				sta 	zTemp0
.a22b	a9 09		lda #$09			lda 	#(InputBuffer >> 8)
.a22d	85 05		sta $05				sta 	zTemp0+1
.a22f	a9 07		lda #$07			lda 	#COL_WHITE
.a231	20 13 a2	jsr $a213			jsr 	ExternColour
.a234	20 cf ff	jsr $ffcf	_EIRead:jsr 	$FFCF
.a237	c9 0d		cmp #$0d			cmp 	#13
.a239	f0 0a		beq $a245			beq 	_EIExit
.a23b	92 04		sta ($04)			sta 	(zTemp0)
.a23d	e6 04		inc $04				inc 	zTemp0
.a23f	d0 f3		bne $a234			bne 	_EIRead
.a241	e6 05		inc $05				inc 	zTemp0+1
.a243	80 ef		bra $a234			bra 	_EIRead
.a245	a9 00		lda #$00	_EIExit:lda 	#0
.a247	92 04		sta ($04)			sta 	(zTemp0)
.a249	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/execute.asm

.a24a					EXNextLine:
.a24a	b2 00		lda ($00)			lda 	(codePtr) 					; is it run from the buffer (offset 0)
.a24c	f0 0f		beq $a25d			beq 	_EXNLWarmStart
.a24e	18		clc				clc 								; advance code pointer to next line
.a24f	65 00		adc $00				adc 	codePtr
.a251	85 00		sta $00				sta 	codePtr
.a253	90 02		bcc $a257			bcc 	_EXNLNoBump
.a255	e6 01		inc $01				inc 	codePtr+1
.a257					_EXNLNoBump:
.a257	a0 03		ldy #$03			ldy 	#3 							; position in that line
.a259	b2 00		lda ($00)			lda 	(codePtr) 					; read offset
.a25b	d0 03		bne $a260			bne 	Execute 					; not end of program
.a25d					_EXNLWarmStart:
.a25d	4c 3d ad	jmp $ad3d			jmp 	System_END
.a260					Execute:
.a260	ee 22 08	inc $0822			inc 	BreakCount 					; break occasionally. too slow otherwise.
.a263	d0 03		bne $a268			bne 	_EXNoBreak
.a265	20 fc a1	jsr $a1fc			jsr 	ExternCheckBreak
.a268					_EXNoBreak:
.a268	b1 00		lda ($00),y			lda 	(codePtr),y 				; load the character
.a26a	f0 de		beq $a24a			beq 	EXNextLine 					; reached end of the line.
.a26c	c8		iny				iny 								; advance pointer.
.a26d	c9 10		cmp #$10			cmp 	#$10 						; is it 01-0F, which means a string/comment ?
.a26f	90 27		bcc $a298			bcc 	EXStringComment
.a271	c9 80		cmp #$80			cmp 	#$80 						; if it 10-7F, token
.a273	90 0d		bcc $a282			bcc 	EXTokenExecute
.a275	c9 c0		cmp #$c0			cmp 	#$C0 						; is it a numeric constant 80-BF
.a277	90 03		bcc $a27c			bcc 	EXPushConstant
.a279	4c e3 ad	jmp $ade3			jmp 	Identifier 					; it's an identifier C0-FF
.a27c					EXPushConstant:
.a27c	88		dey				dey
.a27d	20 c7 a2	jsr $a2c7			jsr 	ExtractIntegerToTOS 		; extract integer
.a280	80 de		bra $a260			bra 	Execute
.a282					EXTokenExecute:
.a282	0a		asl a				asl 	a 							; double token, also clears carry
.a283	da		phx				phx 								; save X, put token x 2 in X
.a284	aa		tax				tax
.a285	bd 50 a1	lda $a150,x			lda 	KeywordVectorTable-$20,x 	; copy vector. The -$20 is because the tokens
.a288	85 04		sta $04				sta 	zTemp0 						; start at $10.
.a28a	bd 51 a1	lda $a151,x			lda 	KeywordVectorTable-$20+1,x
.a28d	85 05		sta $05				sta 	zTemp0+1
.a28f	fa		plx				plx 								; restore X
.a290	20 95 a2	jsr $a295			jsr 	_EXTCall 					; call the routine
.a293	80 cb		bra $a260			bra 	Execute
.a295					_EXTCall:
.a295	6c 04 00	jmp ($0004)			jmp 	(zTemp0)
.a298					EXStringComment:
.a298	c9 02		cmp #$02			cmp 	#$02 						; 02 is the token for single quoted string
.a29a	f0 15		beq $a2b1			beq 	EXStringSkip 				; (comment), so just skip it.
.a29c	e8		inx				inx 								; push Y + 1 + codePtr on the stack
.a29d	98		tya				tya
.a29e	38		sec				sec
.a29f	65 00		adc $00				adc 	codePtr
.a2a1	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a2a4	a5 01		lda $01				lda 	codePtr+1
.a2a6	69 00		adc #$00			adc 	#0
.a2a8	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a2ab	9e 00 0e	stz $0e00,x			stz 	stack2,x 					; clear the upper 2 bytes.
.a2ae	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a2b1					EXStringSkip:
.a2b1	98		tya				tya 								; the current position in A
.a2b2	18		clc				clc
.a2b3	71 00		adc ($00),y			adc 	(codePtr),y					; add the total length
.a2b5	a8		tay				tay 			 					; and make that the current position.
.a2b6	88		dey				dey 								; back one because of the initial skip
.a2b7	80 a7		bra $a260			bra 	Execute
.a2b9					EXShiftTOSRight:
.a2b9	4a		lsr a				lsr 	a
.a2ba	7e 00 0f	ror $0f00,x			ror 	stack3,x
.a2bd	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a2c0	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a2c3	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a2c6	60		rts				rts
.a2c7					ExtractIntegerToTOS:
.a2c7	b1 00		lda ($00),y			lda 	(codePtr),y
.a2c9	c8		iny				iny
.a2ca	e8		inx				inx 								; make stack space
.a2cb	29 3f		and #$3f			and 	#$3F 						; to start with, it's just that value
.a2cd	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a2d0	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a2d3	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a2d6	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a2d9					_EXConstantLoop:
.a2d9	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next ?
.a2db	29 c0		and #$c0			and 	#$C0 						; in range 80-FF e.g. 10xx xxxx
.a2dd	c9 80		cmp #$80			cmp 	#$80
.a2df	d0 2d		bne $a30e			bne		_EXDone 					; no then exit
.a2e1	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; put the MSB in A
.a2e4	48		pha				pha
.a2e5	bd 00 0e	lda $0e00,x			lda 	stack2,x 					; shift every byte up one, e.g. x 256
.a2e8	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a2eb	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a2ee	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a2f1	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a2f4	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a2f7	9e 00 0c	stz $0c00,x			stz 	stack0,x
.a2fa	68		pla				pla
.a2fb	20 b9 a2	jsr $a2b9			jsr 	EXShiftTOSRight 				; shift the whole A:Top of Stack right twice
.a2fe	20 b9 a2	jsr $a2b9			jsr 	EXShiftTOSRight				; which will be x64
.a301	b1 00		lda ($00),y			lda 	(codePtr),y 				; get and skip constant shift
.a303	c8		iny				iny
.a304	29 3f		and #$3f			and 	#$3F
.a306	1d 00 0c	ora $0c00,x			ora 	stack0,x 					; or into low byte
.a309	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a30c	80 cb		bra $a2d9			bra 	_EXConstantLoop
.a30e	b1 00		lda ($00),y	_EXDone:lda 	(codePtr),y
.a310	c8		iny				iny 								; skip over unary constant + -
.a311	c9 4b		cmp #$4b			cmp 	#KWD_CONSTANT_MINUS
.a313	d0 03		bne $a318			bne 	_EXPositive
.a315	4c 74 a9	jmp $a974			jmp 	Unary_Negate
.a318					_EXPositive:
.a318	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/identifier.asm

.a319					IdentifierSearch:
.a319	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.a31b	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a fast var ?
.a31d	90 12		bcc $a331			bcc 	_ISSlow
.a31f	c9 fa		cmp #$fa			cmp 	#$F9+1
.a321	b0 0e		bcs $a331			bcs 	_ISSlow
.a323	29 1f		and #$1f			and 	#$1F 						; index, then x 4
.a325	0a		asl a				asl 	a
.a326	0a		asl a				asl		a
.a327	85 12		sta $12				sta 	idDataAddr					; set up addres
.a329	a9 10		lda #$10			lda 	#AZVariables >> 8
.a32b	85 13		sta $13				sta 	idDataAddr+1
.a32d	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; type
.a32f	38		sec				sec 								; return with CS.
.a330	60		rts				rts
.a331					_ISSlow:
.a331	20 e5 a3	jsr $a3e5			jsr 	IdentifierSetupHashPtr 		; set up hash table.
.a334	98		tya				tya 								; set (zTemp1) to point to the
.a335	18		clc				clc 	 							; identifier to be searched.
.a336	65 00		adc $00				adc 	codePtr
.a338	85 06		sta $06				sta 	zTemp1
.a33a	a5 01		lda $01				lda 	codePtr+1
.a33c	69 00		adc #$00			adc 	#0
.a33e	85 07		sta $07				sta 	zTemp1+1
.a340	5a		phy				phy 								; save Y
.a341	b2 04		lda ($04)	_ISLoop:lda 	(zTemp0)					; follow link
.a343	48		pha				pha
.a344	a0 01		ldy #$01			ldy 	#1
.a346	b1 04		lda ($04),y			lda 	(zTemp0),y
.a348	85 05		sta $05				sta 	zTemp0+1
.a34a	68		pla				pla
.a34b	85 04		sta $04				sta 	zTemp0
.a34d	05 05		ora $05				ora 	zTemp0+1 					; if zero, then fail.
.a34f	f0 2c		beq $a37d			beq 	_ISFail
.a351	a0 06		ldy #$06			ldy 	#6 							; copy name into zTemp2
.a353	b1 04		lda ($04),y			lda 	(zTemp0),y
.a355	85 08		sta $08				sta 	zTemp2
.a357	c8		iny				iny
.a358	b1 04		lda ($04),y			lda 	(zTemp0),y
.a35a	85 09		sta $09				sta 	zTemp2+1
.a35c	a0 00		ldy #$00			ldy 	#0 							; compare names at zTemp1/zTemp2
.a35e					_ISCompare:
.a35e	b1 06		lda ($06),y			lda 	(zTemp1),y
.a360	d1 08		cmp ($08),y			cmp 	(zTemp2),y
.a362	d0 dd		bne $a341			bne		_ISLoop 					; different ?
.a364	c8		iny				iny
.a365	c9 e0		cmp #$e0			cmp 	#$E0 						; until end identifiers matched.
.a367	90 f5		bcc $a35e			bcc 	_ISCompare
.a369	18		clc				clc 								; set up the data pointer
.a36a	a5 04		lda $04				lda 	zTemp0
.a36c	69 02		adc #$02			adc 	#2
.a36e	85 12		sta $12				sta 	idDataAddr
.a370	a5 05		lda $05				lda 	zTemp0+1
.a372	69 00		adc #$00			adc		#0
.a374	85 13		sta $13				sta 	idDataAddr+1
.a376	a0 09		ldy #$09			ldy 	#9 							; get the type
.a378	b1 04		lda ($04),y			lda 	(zTemp0),y
.a37a	7a		ply				ply
.a37b	38		sec				sec
.a37c	60		rts				rts
.a37d					_ISFail:
.a37d	7a		ply				ply
.a37e	18		clc				clc
.a37f	60		rts				rts
.a380					IdentifierCreate:
.a380	5a		phy				phy 								; save Y
.a381	48		pha				pha 								; save type on stack
.a382	20 e5 a3	jsr $a3e5			jsr 	IdentifierSetUpHashPtr 		; zTemp0 = address of table.
.a385	ad 88 10	lda $1088			lda 	VarMemory 					; copy VarMemory to zTemp1
.a388	85 06		sta $06				sta 	zTemp1
.a38a	ad 89 10	lda $1089			lda 	VarMemory+1
.a38d	85 07		sta $07				sta 	zTemp1+1
.a38f	5a		phy				phy 								; save Y (code offset)
.a390	a0 00		ldy #$00			ldy 	#0 							; copy next link in.
.a392	b1 04		lda ($04),y			lda 	(zTemp0),y 					; +0,+1 is the link.
.a394	91 06		sta ($06),y			sta 	(zTemp1),y
.a396	c8		iny				iny
.a397	b1 04		lda ($04),y			lda 	(zTemp0),y
.a399	91 06		sta ($06),y			sta 	(zTemp1),y
.a39b	c8		iny				iny
.a39c					_IDCErase:
.a39c	a9 00		lda #$00			lda 	#0
.a39e	91 06		sta ($06),y			sta 	(zTemp1),y
.a3a0	c8		iny				iny
.a3a1	c0 06		cpy #$06			cpy 	#6
.a3a3	d0 f7		bne $a39c			bne 	_IDCErase
.a3a5	68		pla				pla 								; original Y
.a3a6	18		clc				clc
.a3a7	65 00		adc $00				adc		codePtr 					; address of identifier +6,+7
.a3a9	91 06		sta ($06),y			sta 	(zTemp1),y
.a3ab	c8		iny				iny
.a3ac	a5 01		lda $01				lda 	codePtr+1
.a3ae	69 00		adc #$00			adc 	#0
.a3b0	91 06		sta ($06),y			sta 	(zTemp1),y
.a3b2	c8		iny				iny
.a3b3	a9 00		lda #$00			lda 	#0 							; +8 bank (0)
.a3b5	91 06		sta ($06),y			sta 	(zTemp1),y
.a3b7	68		pla				pla 								; restore type
.a3b8	c8		iny				iny
.a3b9	91 06		sta ($06),y			sta 	(zTemp1),y 					; store at +9
.a3bb	c8		iny				iny
.a3bc	98		tya				tya									; add offset to VarMemory
.a3bd	18		clc				clc
.a3be	6d 88 10	adc $1088			adc 	VarMemory
.a3c1	8d 88 10	sta $1088			sta 	VarMemory
.a3c4	ad 89 10	lda $1089			lda 	VarMemory+1
.a3c7	69 00		adc #$00			adc 	#0
.a3c9	8d 89 10	sta $1089			sta 	VarMemory+1
.a3cc	a5 06		lda $06				lda 	zTemp1 						; overwrite hash table entry
.a3ce	92 04		sta ($04)			sta 	(zTemp0)
.a3d0	a0 01		ldy #$01			ldy 	#1
.a3d2	a5 07		lda $07				lda 	zTemp1+1
.a3d4	91 04		sta ($04),y			sta 	(zTemp0),y
.a3d6	a5 06		lda $06				lda 	zTemp1 						; set up idDataAddr
.a3d8	18		clc				clc
.a3d9	69 02		adc #$02			adc 	#2
.a3db	85 12		sta $12				sta 	idDataAddr
.a3dd	a5 07		lda $07				lda 	zTemp1+1
.a3df	69 00		adc #$00			adc 	#0
.a3e1	85 13		sta $13				sta 	idDataAddr+1
.a3e3	7a		ply				ply 								; restore Y and exit
.a3e4	60		rts				rts
.a3e5					IdentifierSetUpHashPtr:
.a3e5	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first operator
.a3e7	29 0f		and #$0f			and 	#(HashTableSize-1)			; convert to a hash index
.a3e9	0a		asl a				asl 	a 							; convert to an offset, clc
.a3ea	69 68		adc #$68			adc 	#(HashTable & $FF)			; set zTemp0 to point to hashTable entry
.a3ec	85 04		sta $04				sta 	zTemp0
.a3ee	a9 10		lda #$10			lda 	#(HashTable >> 8) 			; assumes table in one page
.a3f0	85 05		sta $05				sta 	zTemp0+1
.a3f2	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/reset.asm

.a3f3					ResetCodePointer:
.a3f3	48		pha				pha
.a3f4	a9 11		lda #$11			lda 	#ProgramStart >> 8 			; set up line pointer
.a3f6	85 01		sta $01				sta 	codePtr+1
.a3f8	64 00		stz $00				stz 	codePtr
.a3fa	a0 03		ldy #$03			ldy 	#3 							; point to first piece of code
.a3fc	68		pla				pla
.a3fd	60		rts				rts
.a3fe					ResetForRun:
.a3fe	48		pha				pha
.a3ff	5a		phy				phy
.a400	a2 00		ldx #$00			ldx 	#0 							; erase the hash table
.a402					_RRErase:
.a402	9e 68 10	stz $1068,x			stz		HashTable,x
.a405	e8		inx				inx
.a406	e0 20		cpx #$20			cpx 	#HashTableSize * 2
.a408	d0 f8		bne $a402			bne 	_RRErase
.a40a	20 f3 a3	jsr $a3f3			jsr 	ResetCodePointer 			; code Pointer to start of program
.a40d					_RRFindEnd:
.a40d	b2 00		lda ($00)			lda 	(codePtr)					; at end ?
.a40f	f0 0b		beq $a41c			beq 	_RRFoundEnd
.a411	18		clc				clc 								; no, add offset to pointer.
.a412	65 00		adc $00				adc 	codePtr
.a414	85 00		sta $00				sta 	codePtr
.a416	90 f5		bcc $a40d			bcc 	_RRFindEnd
.a418	e6 01		inc $01				inc 	codePtr+1
.a41a	80 f1		bra $a40d			bra 	_RRFindEnd
.a41c					_RRFoundEnd:
.a41c	18		clc				clc 								; add 1 to this, as it points to the last
.a41d	a5 00		lda $00				lda 	codePtr 					; offset, and store in Variable Memory pointer
.a41f	69 01		adc #$01			adc 	#1
.a421	8d 88 10	sta $1088			sta 	VarMemory
.a424	a5 01		lda $01				lda 	codePtr+1
.a426	69 00		adc #$00			adc 	#0
.a428	8d 89 10	sta $1089			sta 	VarMemory+1
.a42b	a9 60		lda #$60			lda 	#MemoryEnd >> 8
.a42d	8d 8b 10	sta $108b			sta 	AllocMemory+1
.a430	9c 8a 10	stz $108a			stz 	AllocMemory
.a433	a9 ff		lda #$ff			lda 	#StructureStack & $FF
.a435	85 02		sta $02				sta 	StructSP
.a437	a9 0b		lda #$0b			lda 	#StructureStack >> 8
.a439	85 03		sta $03				sta 	StructSP+1
.a43b	a9 ff		lda #$ff			lda 	#$FF 						; put a value that will fail structure tests
.a43d	92 02		sta ($02)			sta 	(StructSP)
.a43f	20 47 a4	jsr $a447			jsr 	ProcedureScan
.a442	a2 00		ldx #$00			ldx 	#0 							; empty the stack
.a444	7a		ply				ply
.a445	68		pla				pla
.a446	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/scan.asm

.a447					ProcedureScan:
.a447	20 f3 a3	jsr $a3f3			jsr 	ResetCodePointer 			; reset the code pointer.
.a44a	b2 00		lda ($00)	_PSMain:lda 	(codePtr)					; check if end
.a44c	f0 33		beq $a481			beq 	_PSExit
.a44e	a0 03		ldy #$03			ldy 	#3 							; start of line
.a450	b1 00		lda ($00),y			lda 	(codePtr),y 				; skip over spaces
.a452	c9 29		cmp #$29			cmp 	#KWD_DEF 					; first thing is DEF ?
.a454	d0 1e		bne $a474			bne 	_PSNext
.a456	c8		iny				iny 								; skip over def first, any following spaces
.a457	b1 00		lda ($00),y			lda 	(codePtr),y
.a459	a9 50		lda #$50			lda 	#IDT_PROCEDURE 				; create a procedure
.a45b	20 80 a3	jsr $a380			jsr 	IdentifierCreate
.a45e					_PSSkipIdentifier:
.a45e	b1 00		lda ($00),y			lda 	(codePtr),y
.a460	c8		iny				iny
.a461	c9 c0		cmp #$c0			cmp 	#$C0
.a463	b0 f9		bcs $a45e			bcs 	_PSSkipIdentifier
.a465	88		dey				dey 								; undo last, points at first non ID
.a466	98		tya				tya  								; save the address in the data slot.
.a467	18		clc				clc 								; changing Y doesn't matter.
.a468	65 00		adc $00				adc 	codePtr
.a46a	92 12		sta ($12)			sta 	(idDataAddr)
.a46c	a5 01		lda $01				lda 	codePtr+1
.a46e	69 00		adc #$00			adc 	#0
.a470	a0 01		ldy #$01			ldy 	#1
.a472	91 12		sta ($12),y			sta 	(idDataAddr),y
.a474					_PSNext:
.a474	18		clc				clc 								; go to next
.a475	b2 00		lda ($00)			lda 	(codePtr)
.a477	65 00		adc $00				adc 	codePtr
.a479	85 00		sta $00				sta 	codeptr
.a47b	90 cd		bcc $a44a			bcc 	_PSMain
.a47d	e6 01		inc $01				inc 	codePtr+1
.a47f	80 c9		bra $a44a			bra 	_PSMain
.a481					_PSExit:
.a481	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/indexing.asm

.a482					IndexCheck:
.a482	b1 00		lda ($00),y			lda 	(codePtr),y 				; check next character
.a484	c9 48		cmp #$48			cmp 	#KWD_LSQPARENRSQPAREN 		; left/right square bracket ?
.a486	f0 12		beq $a49a			beq 	_ICArrayAccess
.a488	29 c0		and #$c0			and 	#$C0 						; constant (e.g. 10xx xxxx)
.a48a	c9 80		cmp #$80			cmp 	#$80
.a48c	b0 01		bcs $a48f			bcs 	_ICSubscript
.a48e					_ICExit:
.a48e	60		rts				rts
.a48f					_ICSubscript:
.a48f	b1 00		lda ($00),y			lda 	(codePtr),y
.a491	c8		iny				iny 								; skip over subscript
.a492	29 3f		and #$3f			and 	#$3F 						; lower 6 bits only.
.a494	85 06		sta $06				sta 	zTemp1 						; save in zTemp1
.a496	64 07		stz $07				stz 	zTemp1+1
.a498	80 0c		bra $a4a6			bra 	_ICAddSubscript 			; double and add to value.
.a49a					_ICArrayAccess:
.a49a	c8		iny				iny 								; point to next
.a49b	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy TOS to zTemp1
.a49e	85 07		sta $07				sta 	zTemp1+1 					; no point in the rest !
.a4a0	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a4a3	85 06		sta $06				sta 	zTemp1
.a4a5	ca		dex				dex
.a4a6					_ICAddSubscript:
.a4a6	06 06		asl $06				asl 	zTemp1 						; subscript x 4
.a4a8	26 07		rol $07				rol 	zTemp1+1
.a4aa	06 06		asl $06				asl 	zTemp1
.a4ac	26 07		rol $07				rol 	zTemp1+1
.a4ae	5a		phy				phy
.a4af	b2 12		lda ($12)			lda 	(idDataAddr)				; check indirecting through 0
.a4b1	a0 01		ldy #$01			ldy 	#1
.a4b3	11 12		ora ($12),y			ora 	(idDataAddr),y 				; probably means uninitialised
.a4b5	c8		iny				iny
.a4b6	11 12		ora ($12),y			ora 	(idDataAddr),y
.a4b8	c8		iny				iny
.a4b9	11 12		ora ($12),y			ora 	(idDataAddr),y
.a4bb	f0 17		beq $a4d4			beq 	_ICZero
.a4bd	18		clc				clc									; add zTemp1 to value at (idDataAddr)
.a4be	b2 12		lda ($12)			lda 	(idDataAddr)
.a4c0	65 06		adc $06				adc 	zTemp1
.a4c2	48		pha				pha
.a4c3	a0 01		ldy #$01			ldy 	#1
.a4c5	b1 12		lda ($12),y			lda 	(idDataAddr),y
.a4c7	65 07		adc $07				adc 	zTemp1+1
.a4c9	85 13		sta $13				sta 	idDataAddr+1 				; write it out
.a4cb	68		pla				pla
.a4cc	85 12		sta $12				sta 	idDataAddr
.a4ce	64 14		stz $14				stz 	idDataAddr+2 				; extend to 32 bits
.a4d0	64 15		stz $15				stz 	idDataAddr+3
.a4d2	7a		ply				ply
.a4d3	60		rts				rts
.a4d4					_ICZero:
.a4d4	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>a4d7	55 4e 49 4e 49 54 49 41				.text 	"UNINITIALISED ARRAY",0
>a4df	4c 49 53 45 44 20 41 52 52 41 59 00

;******  Return to file: main.asm


;******  Processing file: system/error.asm

.a4eb					SyntaxError:
.a4eb	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>a4ee	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>a4f6	52 52 4f 52 00
.a4fb					ErrorHandler:
.a4fb	68		pla				pla 								; pop message address
.a4fc	85 04		sta $04				sta 	zTemp0
.a4fe	68		pla				pla
.a4ff	85 05		sta $05				sta 	zTemp0+1
.a501	a9 05		lda #$05			lda 	#CTH_ERROR
.a503	20 13 a2	jsr $a213			jsr 	ExternColour
.a506	a0 01		ldy #$01			ldy 	#1 							; print it
.a508					_ErrorPrint:
.a508	b1 04		lda ($04),y			lda 	(zTemp0),y
.a50a	20 09 a2	jsr $a209			jsr		ExternPrint
.a50d	c8		iny				iny
.a50e	b1 04		lda ($04),y			lda 	(zTemp0),y
.a510	d0 f6		bne $a508			bne 	_ErrorPrint
.a512	a0 01		ldy #$01			ldy 	#1 							; check if line# 0
.a514	b1 00		lda ($00),y			lda		(codePtr),y
.a516	c8		iny				iny
.a517	12 00		ora ($00)			ora 	(codePtr)
.a519	f0 1c		beq $a537			beq 	_ErrorNoLine 				; if so, skip
.a51b	a9 20		lda #$20			lda 	#32
.a51d	20 09 a2	jsr $a209			jsr 	ExternPrint
.a520	a9 40		lda #$40			lda 	#'@'
.a522	20 09 a2	jsr $a209			jsr 	ExternPrint
.a525	a9 20		lda #$20			lda 	#32
.a527	20 09 a2	jsr $a209			jsr 	ExternPrint
.a52a	a0 01		ldy #$01			ldy 	#1 							; load current line into YA
.a52c	b1 00		lda ($00),y			lda 	(codePtr),y
.a52e	48		pha				pha
.a52f	c8		iny				iny
.a530	b1 00		lda ($00),y			lda 	(codePtr),y
.a532	a8		tay				tay
.a533	68		pla				pla
.a534	20 3f a5	jsr $a53f			jsr 	ErrorPrint16 				; print YA as unsigned 16 bit integer.
.a537					_ErrorNoLine:
.a537	a9 0d		lda #$0d			lda 	#13							; new line
.a539	20 09 a2	jsr $a209			jsr 	ExternPrint
.a53c	4c 1a a0	jmp $a01a			jmp 	WarmStart
.a53f					ErrorPrint16:
.a53f	da		phx				phx
.a540	e8		inx				inx 								; space on stack
.a541	9d 00 0c	sta $0c00,x			sta 	stack0,x					; save on TOS
.a544	98		tya				tya
.a545	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a548	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a54b	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a54e	20 64 a5	jsr $a564			jsr 	IntegerToString 			; convert to string.
.a551	fa		plx				plx
.a552					ErrorPrintIntegerBuffer:
.a552	da		phx				phx
.a553	a2 00		ldx #$00			ldx 	#0
.a555					_EP16Loop:
.a555	bd 00 08	lda $0800,x			lda 	SBuffer,x
.a558	20 09 a2	jsr $a209			jsr 	ExternPrint
.a55b	e8		inx				inx
.a55c	bd 00 08	lda $0800,x			lda 	SBuffer,x
.a55f	d0 f4		bne $a555			bne 	_EP16Loop
.a561	8a		txa				txa
.a562	fa		plx				plx
.a563	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/inttostr.asm

.a564					IntegerToString:
.a564	48		pha				pha
.a565	5a		phy				phy
.a566	bd 00 0f	lda $0f00,x			lda 		stack3,x 				; check -ve
.a569	10 08		bpl $a573			bpl 		_ITSNotMinus
.a56b	a9 2d		lda #$2d			lda 		#"-"
.a56d	20 05 a6	jsr $a605			jsr 		ITSOutputCharacter
.a570	20 74 a9	jsr $a974			jsr 		Unary_Negate
.a573					_ITSNotMinus:
.a573	9c 20 08	stz $0820			stz 		SBPosition 				; reset string buffer position
.a576	9c 24 08	stz $0824			stz 		NumSuppress 			; clear zero suppression flag
.a579	8a		txa				txa 								; use Y for the integer index.
.a57a	a8		tay				tay
.a57b	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.a57d					_ITSNextSubtractor:
.a57d	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.a57f	8d 21 08	sta $0821			sta 		NumConvCount
.a582					_ITSSubtract:
.a582	38		sec				sec
.a583	b9 00 0c	lda $0c00,y			lda 		stack0,y 			; subtract number and push on stack
.a586	fd e1 a5	sbc $a5e1,x			sbc 		_ITSSubtractors+0,x 	; only update if actually can subtract it.
.a589	48		pha				pha
.a58a	b9 00 0d	lda $0d00,y			lda 		stack1,y
.a58d	fd e2 a5	sbc $a5e2,x			sbc 		_ITSSubtractors+1,x
.a590	48		pha				pha
.a591	b9 00 0e	lda $0e00,y			lda 		stack2,y
.a594	fd e3 a5	sbc $a5e3,x			sbc 		_ITSSubtractors+2,x
.a597	48		pha				pha
.a598	b9 00 0f	lda $0f00,y			lda 		stack3,y
.a59b	fd e4 a5	sbc $a5e4,x			sbc 		_ITSSubtractors+3,x
.a59e	90 14		bcc $a5b4			bcc 		_ITSCantSubtract 		; if CC, then gone too far, can't subtract
.a5a0	99 00 0f	sta $0f00,y			sta 		stack3,y 		; save subtract off stack as it's okay
.a5a3	68		pla				pla
.a5a4	99 00 0e	sta $0e00,y			sta 		stack2,y
.a5a7	68		pla				pla
.a5a8	99 00 0d	sta $0d00,y			sta 		stack1,y
.a5ab	68		pla				pla
.a5ac	99 00 0c	sta $0c00,y			sta 		stack0,y
.a5af	ee 21 08	inc $0821			inc 		NumConvCount 			; bump count.
.a5b2	80 ce		bra $a582			bra 		_ITSSubtract 			; go round again.
.a5b4					_ITSCantSubtract:
.a5b4	68		pla				pla 								; throw away interim answers
.a5b5	68		pla				pla 								; (the subtraction that failed)
.a5b6	68		pla				pla
.a5b7	ad 21 08	lda $0821			lda 		NumConvCount 			; if not zero then no suppression check
.a5ba	c9 30		cmp #$30			cmp 		#"0"
.a5bc	d0 05		bne $a5c3			bne 		_ITSOutputDigit
.a5be	ad 24 08	lda $0824			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.a5c1	f0 09		beq $a5cc			beq	 		_ITSGoNextSubtractor
.a5c3					_ITSOutputDigit:
.a5c3	ce 24 08	dec $0824			dec 		NumSuppress 			; suppression check will be non-zero from now on.
.a5c6	ad 21 08	lda $0821			lda 		NumConvCount 			; count of subtractions
.a5c9	20 05 a6	jsr $a605			jsr 		ITSOutputCharacter 		; output it.
.a5cc					_ITSGoNextSubtractor:
.a5cc	e8		inx				inx 								; next dword in subtractor table.
.a5cd	e8		inx				inx
.a5ce	e8		inx				inx
.a5cf	e8		inx				inx
.a5d0	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.a5d2	d0 a9		bne $a57d			bne 		_ITSNextSubtractor 		; do all the subtractors.
.a5d4	98		tya				tya 								; X is back as the mantissa index
.a5d5	aa		tax				tax
.a5d6	bd 00 0c	lda $0c00,x			lda 		stack0,x 		; and the last digit is left.
.a5d9	09 30		ora #$30			ora 		#"0"
.a5db	20 05 a6	jsr $a605			jsr 		ITSOutputCharacter
.a5de	7a		ply				ply 								; and exit
.a5df	68		pla				pla
.a5e0	60		rts				rts
.a5e1					_ITSSubtractors:
>a5e1	00 ca 9a 3b					.dword 		1000000000
>a5e5	00 e1 f5 05					.dword 		100000000
>a5e9	80 96 98 00					.dword 		10000000
>a5ed	40 42 0f 00					.dword 		1000000
>a5f1	a0 86 01 00					.dword 		100000
>a5f5	10 27 00 00					.dword 		10000
>a5f9	e8 03 00 00					.dword 		1000
>a5fd	64 00 00 00					.dword 		100
>a601	0a 00 00 00					.dword 		10
.a605					_ITSSubtractorsEnd:
.a605					ITSOutputCharacter:
.a605	48		pha				pha
.a606	da		phx				phx
.a607	ae 20 08	ldx $0820			ldx 	SBPosition 					; save digit
.a60a	9d 00 08	sta $0800,x			sta 	SBuffer,x
.a60d	9e 01 08	stz $0801,x			stz 	SBuffer+1,x
.a610	ee 20 08	inc $0820			inc 	SBPosition					; bump pointer.
.a613	fa		plx				plx
.a614	68		pla				pla
.a615	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/intfromstr.asm

.a616					IntFromString:
.a616	a0 00		ldy #$00			ldy 	#0 							; from (zTemp0)
.a618	e8		inx				inx 								; space on stack
.a619	20 4c a6	jsr $a64c			jsr 	IFSClearTOS
.a61c					_IFSLoop:
.a61c	b1 04		lda ($04),y			lda 	(zTemp0),y 					; get next
.a61e	c9 30		cmp #$30			cmp 	#"0"						; validate it as range 0-9
.a620	90 24		bcc $a646			bcc 	_IFSExit
.a622	c9 3a		cmp #$3a			cmp 	#"9"+1
.a624	b0 20		bcs $a646			bcs 	_IFSExit
.a626	20 e5 a8	jsr $a8e5			jsr 	Stack_Dup 					; duplicate tos
.a629	20 ec a9	jsr $a9ec			jsr 	Unary_Shl	 				; x 2
.a62c	20 ec a9	jsr $a9ec			jsr 	Unary_Shl 					; x 4
.a62f	20 b7 aa	jsr $aab7			jsr 	Stack_Add 					; x 5
.a632	20 ec a9	jsr $a9ec			jsr 	Unary_Shl 					; x 10
.a635	e8		inx				inx  								; create space next up
.a636	20 4c a6	jsr $a64c			jsr 	IFSClearTOS
.a639	b1 04		lda ($04),y			lda 	(zTemp0),y 					; add digit
.a63b	29 0f		and #$0f			and 	#15
.a63d	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; tos is new add
.a640	20 b7 aa	jsr $aab7			jsr 	Stack_Add 					; add to tos
.a643	c8		iny				iny
.a644	80 d6		bra $a61c			bra 	_IFSLoop
.a646					_IFSExit:
.a646	98		tya				tya
.a647	38		sec				sec
.a648	f0 01		beq $a64b			beq 	_IFSSkipFail
.a64a	18		clc				clc
.a64b					_IFSSkipFail:
.a64b	60		rts				rts
.a64c					IFSClearTOS:
.a64c	9e 00 0c	stz $0c00,x			stz		stack0,x
.a64f	9e 00 0d	stz $0d00,x			stz		stack1,x
.a652	9e 00 0e	stz $0e00,x			stz		stack2,x
.a655	9e 00 0f	stz $0f00,x			stz		stack3,x
.a658	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/list.asm

.a659					Cmd_List:
.a659	20 f3 a3	jsr $a3f3			jsr 	ResetCodePointer 			; back to the beginning
.a65c	64 08		stz $08				stz 	zTemp2						; clear the lowest-number
.a65e	64 09		stz $09				stz 	zTemp2+1
.a660	e0 00		cpx #$00			cpx 	#0 							; stack empty ?
.a662	f0 0b		beq $a66f			beq 	_CLINone
.a664	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; use tos as start line
.a667	85 08		sta $08				sta 	zTemp2
.a669	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a66c	95 09		sta $09,x			sta 	zTemp2+1,x
.a66e	ca		dex				dex 								; and pop the tos
.a66f					_CLINone:
.a66f	a9 10		lda #$10			lda 	#16 						; list this many lines
.a671	85 06		sta $06				sta 	zTemp1
.a673					_CLILoop
.a673	b2 00		lda ($00)			lda 	(codePtr)					; check end of program
.a675	f0 24		beq $a69b			beq 	_CLIEnd
.a677	a0 01		ldy #$01			ldy 	#1 							; compare line# vs the minimum
.a679	38		sec				sec
.a67a	b1 00		lda ($00),y			lda 	(codePtr),y
.a67c	e5 08		sbc $08				sbc 	zTemp2
.a67e	c8		iny				iny
.a67f	b1 00		lda ($00),y			lda 	(codePtr),y
.a681	e5 09		sbc $09				sbc 	zTemp2+1
.a683	90 09		bcc $a68e			bcc 	_CLISkip
.a685	da		phx				phx
.a686	20 9e a6	jsr $a69e			jsr 	ListCurrent 				; list the line.
.a689	fa		plx				plx
.a68a	c6 06		dec $06				dec 	zTemp1 						; done all lines
.a68c	f0 0d		beq $a69b			beq 	_CLIEnd
.a68e					_CLISkip:
.a68e	18		clc				clc
.a68f	b2 00		lda ($00)			lda 	(codePtr) 					; go to next
.a691	65 00		adc $00				adc 	codePtr
.a693	85 00		sta $00				sta 	codePtr
.a695	90 dc		bcc $a673			bcc 	_CLILoop
.a697	e6 01		inc $01				inc 	codePtr+1
.a699	80 d8		bra $a673			bra 	_CLILoop
.a69b					_CLIEnd:
.a69b	4c 1a a0	jmp $a01a			jmp 	WarmStart
.a69e					ListCurrent:
.a69e	a9 06		lda #$06			lda 	#CTH_NUMBER
.a6a0	20 13 a2	jsr $a213			jsr 	ExternColour 				; set colour
.a6a3	a0 01		ldy #$01			ldy 	#1							; print line#
.a6a5	b1 00		lda ($00),y			lda 	(codePtr),y
.a6a7	48		pha				pha
.a6a8	c8		iny				iny
.a6a9	b1 00		lda ($00),y			lda 	(codePtr),y
.a6ab	a8		tay				tay
.a6ac	68		pla				pla
.a6ad	20 3f a5	jsr $a53f			jsr 	ErrorPrint16
.a6b0	a8		tay				tay
.a6b1					_LCPadOut:
.a6b1	a9 20		lda #$20			lda 	#' '
.a6b3	20 09 a2	jsr $a209			jsr 	ExternPrint
.a6b6	c8		iny				iny
.a6b7	c0 05		cpy #$05			cpy 	#5
.a6b9	d0 f6		bne $a6b1			bne 	_LCPadOut
.a6bb	a0 03		ldy #$03			ldy 	#3 							; start here
.a6bd					_LCLoop:
.a6bd	a9 20		lda #$20			lda 	#' '						; space
.a6bf	20 09 a2	jsr $a209			jsr 	ExternPrint
.a6c2					_LCLoopNoSpace:
.a6c2	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first
.a6c4	30 3e		bmi $a704			bmi 	_LCIdentConst 				; identifier or constant
.a6c6	d0 05		bne $a6cd			bne 	_LCStringToken
.a6c8	a9 0d		lda #$0d			lda 	#13
.a6ca	4c 09 a2	jmp $a209			jmp 	ExternPrint
.a6cd					_LCStringToken:
.a6cd	c9 10		cmp #$10			cmp 	#$10 						; if < 10 it's a string.
.a6cf	90 0c		bcc $a6dd			bcc		_LCString
.a6d1	20 45 a7	jsr $a745			jsr 	ListPrintToken
.a6d4	b1 00		lda ($00),y			lda 	(codePtr),y 				; no space if ^
.a6d6	c8		iny				iny 								; advance pointer
.a6d7	c9 49		cmp #$49			cmp 	#KWD_HAT
.a6d9	f0 e7		beq $a6c2			beq 	_LCLoopNoSpace
.a6db	80 e0		bra $a6bd			bra 	_LCLoop 					; go round again.
.a6dd					_LCString:
.a6dd	4a		lsr a				lsr 	a 							; CS if 1 (string) CC if 2 (comment)
.a6de	a9 05		lda #$05			lda 	#CTH_STRING 				; decide on colour.
.a6e0	a2 22		ldx #$22			ldx 	#'"'
.a6e2	b0 04		bcs $a6e8			bcs 	_LCSSkip
.a6e4	a9 07		lda #$07			lda 	#CTH_COMMENT
.a6e6	a2 27		ldx #$27			ldx 	#"'"
.a6e8					_LCSSkip:
.a6e8	20 13 a2	jsr $a213			jsr 	ExternColour 				; set colour
.a6eb	8a		txa				txa
.a6ec	48		pha				pha 								; save end quote on stack.
.a6ed	20 09 a2	jsr $a209			jsr 	ExternPrint
.a6f0	c8		iny				iny 								; skip type size
.a6f1	c8		iny				iny
.a6f2					_LCSPrint:
.a6f2	b1 00		lda ($00),y			lda 	(codePtr),y
.a6f4	c8		iny				iny
.a6f5	c9 00		cmp #$00			cmp 	#0 							; 0 is end
.a6f7	f0 05		beq $a6fe			beq 	_LCSExit
.a6f9	20 09 a2	jsr $a209			jsr 	ExternPrint
.a6fc	80 f4		bra $a6f2			bra 	_LCSPrint
.a6fe					_LCSExit:
.a6fe	68		pla				pla
.a6ff	20 09 a2	jsr $a209			jsr 	ExternPrint
.a702	80 b9		bra $a6bd			bra 	_LCLoop
.a704					_LCIdentConst:
.a704	c9 c0		cmp #$c0			cmp 	#$C0						; check if constant
.a706	90 1e		bcc $a726			bcc 	_LCConstant
.a708	a9 03		lda #$03			lda 	#CTH_IDENT 					; set colour
.a70a	20 13 a2	jsr $a213			jsr 	ExternColour
.a70d					_LCCIdLoop:
.a70d	b1 00		lda ($00),y			lda 	(codePtr),y 				; read
.a70f	c8		iny				iny
.a710	29 1f		and #$1f			and 	#$1F 						; convert
.a712	18		clc				clc
.a713	69 41		adc #$41			adc 	#'A'
.a715	c9 60		cmp #$60			cmp 	#'A'+31 					; handle '.'
.a717	d0 02		bne $a71b			bne 	_LCCNotDot
.a719	a9 2e		lda #$2e			lda 	#'.'
.a71b					_LCCNotDot:
.a71b	20 09 a2	jsr $a209			jsr 	ExternPrint
.a71e	b1 00		lda ($00),y			lda 	(codePtr),y 				; another
.a720	c9 c0		cmp #$c0			cmp 	#$C0
.a722	b0 e9		bcs $a70d			bcs 	_LCCIdLoop
.a724	80 97		bra $a6bd			bra 	_LCLoop
.a726					_LCConstant:
.a726	a9 06		lda #$06			lda 	#CTH_NUMBER 				; number colour
.a728	20 13 a2	jsr $a213			jsr 	ExternColour
.a72b	a2 fe		ldx #$fe			ldx 	#254 						; use the topmost stack element
.a72d	20 c7 a2	jsr $a2c7			jsr 	ExtractIntegerToTOS 		; so there is a very rare case
.a730	bd 00 0f	lda $0f00,x			lda 	stack3+0,x					; save stack top byte
.a733	48		pha				pha
.a734	20 64 a5	jsr $a564			jsr 	IntegerToString 			; this could corrupt stack if full :)
.a737	20 52 a5	jsr $a552			jsr 	ErrorPrintIntegerBuffer
.a73a	68		pla				pla 								; sign back
.a73b	10 80		bpl $a6bd			bpl 	_LCLoop
.a73d	a9 2d		lda #$2d			lda 	#"-"
.a73f	20 09 a2	jsr $a209			jsr 	ExternPrint
.a742	4c bd a6	jmp $a6bd			jmp 	_LCLoop
.a745					ListPrintToken:
.a745	5a		phy				phy
.a746	48		pha				pha 								; token colour
.a747	a9 02		lda #$02			lda 	#CTH_TOKEN
.a749	20 13 a2	jsr $a213			jsr 	ExternColour
.a74c	fa		plx				plx
.a74d	a9 91		lda #$91			lda 	#KeywordText & $FF
.a74f	85 04		sta $04				sta 	zTemp0
.a751	a9 a0		lda #$a0			lda 	#KeywordText >> 8
.a753	85 05		sta $05				sta 	zTemp0+1
.a755					_LPTLoop:
.a755	e0 10		cpx #$10			cpx 	#$10 						; first token is $10
.a757	f0 0e		beq $a767			beq 	_LPTFound
.a759	ca		dex				dex
.a75a	b2 04		lda ($04)			lda 	(zTemp0)
.a75c	38		sec				sec									; add 1, it's length+name
.a75d	65 04		adc $04				adc 	zTemp0
.a75f	85 04		sta $04				sta 	zTemp0
.a761	90 f2		bcc $a755			bcc 	_LPTLoop
.a763	e6 05		inc $05				inc 	zTemp0+1
.a765	80 ee		bra $a755			bra 	_LPTLoop
.a767					_LPTFound:
.a767	a0 01		ldy #$01			ldy 	#1 							; start here.
.a769					_LPTShow:
.a769	b1 04		lda ($04),y			lda 	(zTemp0),y 					; get character
.a76b	c9 20		cmp #$20			cmp 	#32 						; < 32, length, so exit
.a76d	90 06		bcc $a775			bcc 	_LPTExit
.a76f	c8		iny				iny
.a770	20 09 a2	jsr $a209			jsr 	ExternPrint
.a773	80 f4		bra $a769			bra 	_LPTShow
.a775					_LPTExit:
.a775	7a		ply				ply
.a776	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/tokeniser.asm

.a777					Tokenise:
.a777	a0 ff		ldy #$ff			ldy 	#255 						; predecrement
.a779					_TKSkip:
.a779	c8		iny				iny
.a77a					_TKMainLoop:
.a77a	b1 00		lda ($00),y			lda 	(codePtr),y 				; get and check end.
.a77c	f0 06		beq $a784			beq 	_TKExit
.a77e	c9 20		cmp #$20			cmp 	#" "
.a780	f0 f7		beq $a779			beq 	_TKSkip
.a782	80 03		bra $a787			bra 	_TKNotEnd
.a784	92 06		sta ($06)	_TKExit:sta 	(zTemp1) 					; and ending $00
.a786	60		rts				rts
.a787					_TKNotEnd:
.a787	c9 22		cmp #$22			cmp 	#'"'
.a789	f0 04		beq $a78f			beq 	_TKIsQuote
.a78b	c9 27		cmp #$27			cmp 	#"'"
.a78d	d0 05		bne $a794			bne 	_TKNotQuote
.a78f					_TKIsQuote:
.a78f	20 ad a8	jsr $a8ad			jsr		TOKQuotedString
.a792	80 e6		bra $a77a			bra 	_TKMainLoop
.a794					_TKNotQuote:
.a794	98		tya				tya 								; current pos -> zTemp0
.a795	18		clc				clc
.a796	65 00		adc $00				adc 	codePtr
.a798	85 04		sta $04				sta 	zTemp0
.a79a	85 00		sta $00				sta 	codePtr
.a79c	a5 01		lda $01				lda 	codePtr+1
.a79e	69 00		adc #$00			adc 	#0
.a7a0	85 05		sta $05				sta 	zTemp0+1
.a7a2	85 01		sta $01				sta 	codePtr+1
.a7a4	a0 00		ldy #$00			ldy 	#0 							; reset and get character
.a7a6	b1 00		lda ($00),y			lda 	(codePtr),y
.a7a8	c9 30		cmp #$30			cmp 	#"0"						; check for decimal.
.a7aa	90 23		bcc $a7cf			bcc 	_TKNotNumber
.a7ac	c9 3a		cmp #$3a			cmp 	#"9"+1
.a7ae	b0 1f		bcs $a7cf			bcs 	_TKNotNumber
.a7b0	e8		inx				inx
.a7b1	20 16 a6	jsr $a616			jsr 	IntFromString 				; convert to integer
.a7b4	48		pha				pha
.a7b5	20 85 a8	jsr $a885			jsr 	TokWriteConstant 			; do constant recursively.
.a7b8	7a		ply				ply
.a7b9	ca		dex				dex
.a7ba	b1 00		lda ($00),y			lda 	(codePtr),y
.a7bc	c9 2d		cmp #$2d			cmp 	#"-"						; followed by minus
.a7be	d0 08		bne $a7c8			bne 	_TKIsPositive
.a7c0	c8		iny				iny									; skip it
.a7c1	a9 4b		lda #$4b			lda 	#KWD_CONSTANT_MINUS
.a7c3	20 7c a8	jsr $a87c			jsr 	TokWriteToken 				; write token out
.a7c6	80 b2		bra $a77a			bra 	_TKMainLoop 				; loop back.
.a7c8					_TKIsPositive:
.a7c8	a9 4a		lda #$4a			lda 	#KWD_CONSTANT_PLUS
.a7ca	20 7c a8	jsr $a87c			jsr 	TokWriteToken 				; write token out
.a7cd	80 ab		bra $a77a			bra 	_TKMainLoop 				; loop back.
.a7cf					_TKNotNumber:
.a7cf	a9 91		lda #$91			lda 	#KeywordText & $FF 			; zTemp2 -> token table
.a7d1	85 08		sta $08				sta 	zTemp2
.a7d3	a9 a0		lda #$a0			lda 	#KeywordText >> 8
.a7d5	85 09		sta $09				sta 	zTemp2+1
.a7d7	64 0a		stz $0a				stz 	zTemp3 						; clear 'best'
.a7d9	a9 10		lda #$10			lda 	#$10
.a7db	85 0b		sta $0b				sta 	zTemp3+1 					; set current token
.a7dd					_TKSearch:
.a7dd	a0 00		ldy #$00			ldy 	#0
.a7df					_TKCompare:
.a7df	b1 00		lda ($00),y			lda 	(codePtr),y 	 			; get char from buffer
.a7e1	c8		iny				iny
.a7e2	d1 08		cmp ($08),y			cmp 	(zTemp2),y 					; does it match.
.a7e4	d0 07		bne $a7ed			bne 	_TKNext
.a7e6	98		tya				tya
.a7e7	d2 08		cmp ($08)			cmp 	(zTemp2) 					; Y = length
.a7e9	d0 f4		bne $a7df			bne 	_TKCompare 					; found a match.
.a7eb	80 13		bra $a800			bra 	_TKFound
.a7ed	b2 08		lda ($08)	_TKNext:lda 	(zTemp2)					; get length
.a7ef	38		sec				sec 								; add length+1 to current
.a7f0	65 08		adc $08				adc 	zTemp2
.a7f2	85 08		sta $08				sta 	zTemp2
.a7f4	90 02		bcc $a7f8			bcc 	_TKNNC
.a7f6	e6 09		inc $09				inc 	zTemp2+1
.a7f8	e6 0b		inc $0b		_TKNNC:	inc 	zTemp3+1 					; increment current token
.a7fa	b2 08		lda ($08)			lda 	(zTemp2) 					; reached then end
.a7fc	d0 df		bne $a7dd			bne 	_TKSearch 					; go try again.
.a7fe	80 0f		bra $a80f			bra 	_TKComplete
.a800					_TKFound:
.a800	98		tya				tya
.a801	c5 0a		cmp $0a				cmp 	zTemp3 						; check best
.a803	90 e8		bcc $a7ed			bcc 	_TKNext 					; if < best try next
.a805	f0 e6		beq $a7ed			beq 	_TKNext 					; if equal this is one of the special +- tokens
.a807	85 0a		sta $0a				sta 	zTemp3 						; update best
.a809	a5 0b		lda $0b				lda 	zTemp3+1 					; save current token.
.a80b	85 0c		sta $0c				sta 	zTemp4
.a80d	80 de		bra $a7ed			bra 	_TKNext
.a80f					_TKComplete:
.a80f	a5 0a		lda $0a				lda 	zTemp3 						; get "best score"
.a811	f0 18		beq $a82b			beq		_TKTokenFail 				; if zero no match occurred
.a813	a4 0a		ldy $0a				ldy 	zTemp3 						; length in Y
.a815	b2 00		lda ($00)			lda 	(codePtr) 					; look at first character
.a817	20 6c a8	jsr $a86c			jsr 	TOKIsIdentifier 			; identifier character
.a81a	90 07		bcc $a823			bcc 	_TKOutput 					; if not, then token is okay
.a81c	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at character after
.a81e	20 6c a8	jsr $a86c			jsr 	TOKIsIdentifier 			; is that an identifier
.a821	b0 08		bcs $a82b			bcs 	_TKTokenFail 				; if so it must be something like DEFAULT (DEF-AULT)
.a823					_TKOutput:
.a823	a5 0c		lda $0c				lda 	zTemp4 						; output actual token
.a825	20 7c a8	jsr $a87c			jsr 	TOKWriteToken
.a828	4c 7a a7	jmp $a77a			jmp 	_TKMainLoop					; go round again
.a82b					_TKTokenFail:
.a82b	a0 00		ldy #$00			ldy 	#0
.a82d	b2 00		lda ($00)			lda 	(codePtr) 					; is the first an identifier ?
.a82f	20 6c a8	jsr $a86c			jsr 	TOKIsIdentifier
.a832	b0 13		bcs $a847			bcs 	_TKCopyIdent 				; if yes copy it
.a834	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>a837	43 41 4e 4e 4f 54 20 54				.text 	"CANNOT TOKENISE",0
>a83f	4f 4b 45 4e 49 53 45 00
.a847					_TKCopyIdent:
.a847	c8		iny				iny 								; get next
.a848	b1 00		lda ($00),y			lda 	(codePtr),y
.a84a	20 6c a8	jsr $a86c			jsr 	TOKIsIdentifier 			; if identifier
.a84d	08		php				php 								; save CS on stack
.a84e	88		dey				dey 								; back to character
.a84f	b1 00		lda ($00),y			lda 	(codePtr),y 				; get it
.a851	c8		iny				iny
.a852	c9 2e		cmp #$2e			cmp 	#"."
.a854	d0 02		bne $a858			bne 	_TKNotDot
.a856	a9 60		lda #$60			lda 	#'A'+31 					; to map . to 31
.a858					_TKNotDot:
.a858	38		sec				sec
.a859	e9 41		sbc #$41			sbc		#'A'
.a85b	09 c0		ora #$c0			ora 	#$C0 						; in right range
.a85d	28		plp				plp 								; CS if next is identifier
.a85e	08		php				php
.a85f	b0 02		bcs $a863			bcs 	_TKNotLast					; CC if next is not identifier
.a861	09 e0		ora #$e0			ora 	#$E0 						; range E0-FF
.a863					_TKNotLast:
.a863	20 7c a8	jsr $a87c			jsr 	TOKWriteToken 				; write out
.a866	28		plp				plp 								; get test result
.a867	b0 de		bcs $a847			bcs 	_TKCopyIdent 				; get the next identifier.
.a869	4c 7a a7	jmp $a77a			jmp 	_TKMainLoop
.a86c					TOKIsIdentifier:
.a86c	c9 2e		cmp #$2e			cmp 	#"."
.a86e	f0 08		beq $a878			beq 	_TIIYes
.a870	c9 41		cmp #$41			cmp 	#"A"
.a872	90 06		bcc $a87a			bcc 	_TIINo
.a874	c9 5b		cmp #$5b			cmp 	#"Z"+1
.a876	b0 02		bcs $a87a			bcs 	_TIINo
.a878					_TIIYes:
.a878	38		sec				sec
.a879	60		rts				rts
.a87a					_TIINo:
.a87a	18		clc				clc
.a87b	60		rts				rts
.a87c					TokWriteToken:
.a87c	92 06		sta ($06)			sta 	(zTemp1)
.a87e	e6 06		inc $06				inc 	zTemp1
.a880	d0 02		bne $a884			bne 	_TWTExit
.a882	e6 07		inc $07				inc 	zTemp1+1
.a884					_TWTExit:
.a884	60		rts				rts
.a885					TokWriteConstant:
.a885	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; get current
.a888	29 3f		and #$3f			and		#63
.a88a	48		pha				pha 								; save on stack
.a88b	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check if < 64
.a88e	29 c0		and #$c0			and 	#$C0
.a890	1d 00 0d	ora $0d00,x			ora 	stack1,x
.a893	1d 00 0e	ora $0e00,x			ora 	stack2,x
.a896	1d 00 0f	ora $0f00,x			ora 	stack3,x
.a899	f0 0d		beq $a8a8			beq 	_TWCNoCall 					; no, don't call.
.a89b	5a		phy				phy
.a89c	a0 06		ldy #$06			ldy 	#6
.a89e					_TWCShift:
.a89e	20 f9 a9	jsr $a9f9			jsr 	Unary_Shr
.a8a1	88		dey				dey
.a8a2	d0 fa		bne $a89e			bne 	_TWCShift
.a8a4	7a		ply				ply
.a8a5	20 85 a8	jsr $a885			jsr 	TokWriteConstant
.a8a8					_TWCNoCall:
.a8a8	68		pla				pla
.a8a9	09 80		ora #$80			ora 	#$80						; make digit token
.a8ab	80 cf		bra $a87c			bra 	TokWriteToken 				; and write it out.
.a8ad					TokQuotedString:
.a8ad	85 08		sta $08				sta 	zTemp2 						; save quote
.a8af	49 22		eor #$22			eor 	#'"'						; now zero if double quotes
.a8b1	f0 02		beq $a8b5			beq 	_TQDouble
.a8b3	a9 01		lda #$01			lda 	#1
.a8b5					_TQDouble:
.a8b5	1a		inc a				inc 	a 							; 1 for double, 2 for single
.a8b6	20 7c a8	jsr $a87c			jsr 	TOKWriteToken 				; write out
.a8b9	a5 06		lda $06				lda 	zTemp1 						; copy zTemp1 to zTemp3 (byte count addr)
.a8bb	85 0a		sta $0a				sta 	zTemp3
.a8bd	a5 07		lda $07				lda 	zTemp1+1
.a8bf	85 0b		sta $0b				sta 	zTemp3+1
.a8c1	a9 03		lda #$03			lda 	#3 							; 3 is the size if it is empty - type,size,null
.a8c3	20 7c a8	jsr $a87c			jsr 	TOKWriteToken
.a8c6					_TQLoop:
.a8c6	c8		iny				iny 								; next character
.a8c7	b1 00		lda ($00),y			lda 	(codePtr),y
.a8c9	f0 0f		beq $a8da			beq 	_TQExit 					; if zero exit
.a8cb	c5 08		cmp $08				cmp 	zTemp2 						; matching quote
.a8cd	f0 0a		beq $a8d9			beq 	_TQSkipExit 				; skip it and exit
.a8cf	20 7c a8	jsr $a87c			jsr 	TOKWriteToken 				; write out
.a8d2	b2 0a		lda ($0a)			lda 	(zTemp3)					; inc char count
.a8d4	1a		inc a				inc 	a
.a8d5	92 0a		sta ($0a)			sta 	(zTemp3)
.a8d7	80 ed		bra $a8c6			bra 	_TQLoop						; go round
.a8d9					_TQSkipExit:
.a8d9	c8		iny				iny
.a8da					_TQExit:
.a8da	a9 00		lda #$00			lda 	#0 							; write out ASCIIZ
.a8dc	20 7c a8	jsr $a87c			jsr 	TOKWriteToken
.a8df	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/stack.asm

.a8e0					Stack_Empty:
.a8e0	a2 00		ldx #$00			ldx 	#0
.a8e2	60		rts				rts
.a8e3					Stack_Drop:
.a8e3	ca		dex				dex
.a8e4	60		rts				rts
.a8e5					Stack_Dup:
.a8e5	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy to next up
.a8e8	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.a8eb	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a8ee	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.a8f1	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a8f4	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.a8f7	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a8fa	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.a8fd	e8		inx				inx 								; bump stack pointer
.a8fe	60		rts				rts
.a8ff					Stack_Nip:
.a8ff	bd 00 0c	lda $0c00,x			lda 	stack0,x	 				; copy top to 2nd
.a902	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.a905	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a908	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.a90b	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a90e	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.a911	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a914	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.a917	ca		dex				dex 								; drop tos
.a918	60		rts				rts
.a919					Stack_Over:
.a919	bd ff 0b	lda $0bff,x			lda 	stack0-1,x				; copy to next up
.a91c	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.a91f	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a922	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.a925	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a928	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.a92b	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a92e	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.a931	e8		inx				inx 							; bump stack pointer
.a932	60		rts				rts
.a933					Stack_Swap:
.a933	5a		phy				phy
.a934	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a937	a8		tay				tay
.a938	bd ff 0b	lda $0bff,x			lda 	stack0-1,x
.a93b	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a93e	98		tya				tya
.a93f	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.a942	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a945	a8		tay				tay
.a946	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a949	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a94c	98		tya				tya
.a94d	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.a950	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a953	a8		tay				tay
.a954	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a957	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a95a	98		tya				tya
.a95b	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.a95e	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a961	a8		tay				tay
.a962	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a965	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a968	98		tya				tya
.a969	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.a96c	7a		ply				ply
.a96d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/unary.asm

.a96e					Unary_Absolute:
.a96e	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a971	30 01		bmi $a974			bmi 	Unary_Negate
.a973	60		rts				rts
.a974					Unary_Negate:
.a974	38		sec				sec
.a975	a9 00		lda #$00			lda		#0
.a977	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.a97a	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a97d	a9 00		lda #$00			lda		#0
.a97f	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.a982	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a985	a9 00		lda #$00			lda		#0
.a987	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.a98a	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a98d	a9 00		lda #$00			lda		#0
.a98f	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.a992	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a995	60		rts				rts
.a996					Unary_Not:
.a996	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a999	49 ff		eor #$ff			eor 	#$FF
.a99b	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a99e	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a9a1	49 ff		eor #$ff			eor 	#$FF
.a9a3	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a9a6	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a9a9	49 ff		eor #$ff			eor 	#$FF
.a9ab	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a9ae	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a9b1	49 ff		eor #$ff			eor 	#$FF
.a9b3	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a9b6	60		rts				rts
.a9b7					Unary_Increment:
.a9b7	fe 00 0c	inc $0c00,x			inc 	stack0,x
.a9ba	d0 0d		bne $a9c9			bne 	_UIExit
.a9bc	fe 00 0d	inc $0d00,x			inc 	stack1,x
.a9bf	d0 08		bne $a9c9			bne 	_UIExit
.a9c1	fe 00 0e	inc $0e00,x			inc 	stack2,x
.a9c4	d0 03		bne $a9c9			bne 	_UIExit
.a9c6	fe 00 0f	inc $0f00,x			inc 	stack3,x
.a9c9					_UIExit:
.a9c9	60		rts				rts
.a9ca					Unary_Decrement:
.a9ca	38		sec				sec
.a9cb	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a9ce	e9 01		sbc #$01			sbc 	#1
.a9d0	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a9d3	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a9d6	e9 00		sbc #$00			sbc 	#0
.a9d8	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a9db	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a9de	e9 00		sbc #$00			sbc 	#0
.a9e0	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a9e3	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a9e6	e9 00		sbc #$00			sbc 	#0
.a9e8	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a9eb	60		rts				rts
.a9ec					Unary_Shl:
.a9ec	1e 00 0c	asl $0c00,x			asl 	stack0,x
.a9ef	3e 00 0d	rol $0d00,x			rol 	stack1,x
.a9f2	3e 00 0e	rol $0e00,x			rol 	stack2,x
.a9f5	3e 00 0f	rol $0f00,x			rol 	stack3,x
.a9f8	60		rts				rts
.a9f9					Unary_Shr:
.a9f9	5e 00 0f	lsr $0f00,x			lsr 	stack3,x
.a9fc	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a9ff	7e 00 0d	ror $0d00,x			ror 	stack1,x
.aa02	7e 00 0c	ror $0c00,x			ror 	stack0,x
.aa05	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/memory.asm

.aa06					Mem_Peek:
.aa06	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.aa09	85 04		sta $04				sta 	zTemp0
.aa0b	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa0e	85 05		sta $05				sta 	zTemp0+1
.aa10	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.aa12	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.aa15	9e 00 0d	stz $0d00,x			stz 	stack1,x
.aa18	9e 00 0e	stz $0e00,x			stz 	stack2,x
.aa1b	9e 00 0f	stz $0f00,x			stz 	stack3,x
.aa1e	60		rts				rts
.aa1f					Mem_WPeek:
.aa1f	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.aa22	85 04		sta $04				sta 	zTemp0
.aa24	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa27	85 05		sta $05				sta 	zTemp0+1
.aa29	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.aa2b	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.aa2e	5a		phy				phy 								; read msb
.aa2f	a0 01		ldy #$01			ldy 	#1
.aa31	b1 04		lda ($04),y			lda 	(zTemp0),y
.aa33	7a		ply				ply
.aa34	9d 00 0d	sta $0d00,x			sta 	stack1,x 				; write to stack
.aa37	9e 00 0e	stz $0e00,x			stz 	stack2,x
.aa3a	9e 00 0f	stz $0f00,x			stz 	stack3,x
.aa3d	60		rts				rts
.aa3e					Mem_DPeek:
.aa3e	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.aa41	85 04		sta $04				sta 	zTemp0
.aa43	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa46	85 05		sta $05				sta 	zTemp0+1
.aa48	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.aa4a	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.aa4d	5a		phy				phy 								; read msb
.aa4e	a0 01		ldy #$01			ldy 	#1
.aa50	b1 04		lda ($04),y			lda 	(zTemp0),y
.aa52	9d 00 0d	sta $0d00,x			sta 	stack1,x 					; write to stack
.aa55	c8		iny				iny
.aa56	b1 04		lda ($04),y			lda 	(zTemp0),y
.aa58	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aa5b	c8		iny				iny
.aa5c	b1 04		lda ($04),y			lda 	(zTemp0),y
.aa5e	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aa61	7a		ply				ply
.aa62	60		rts				rts
.aa63					Mem_Poke:
.aa63	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.aa66	85 04		sta $04				sta 	zTemp0
.aa68	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa6b	85 05		sta $05				sta 	zTemp0+1
.aa6d	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.aa70	92 04		sta ($04)			sta 	(zTemp0)
.aa72	ca		dex				dex
.aa73	ca		dex				dex
.aa74	60		rts				rts
.aa75					Mem_WPoke:
.aa75	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.aa78	85 04		sta $04				sta 	zTemp0
.aa7a	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa7d	85 05		sta $05				sta 	zTemp0+1
.aa7f	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.aa82	92 04		sta ($04)			sta 	(zTemp0)
.aa84	5a		phy				phy
.aa85	a0 01		ldy #$01			ldy 	#1
.aa87	bd ff 0e	lda $0eff,x			lda 	stack3-1,x 				; byte to write
.aa8a	91 04		sta ($04),y			sta 	(zTemp0),y
.aa8c	7a		ply				ply
.aa8d	ca		dex				dex
.aa8e	ca		dex				dex
.aa8f	60		rts				rts
.aa90					Mem_DPoke:
.aa90	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.aa93	85 04		sta $04				sta 	zTemp0
.aa95	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa98	85 05		sta $05				sta 	zTemp0+1
.aa9a	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 					; byte to write
.aa9d	92 04		sta ($04)			sta 	(zTemp0)
.aa9f	5a		phy				phy
.aaa0	a0 01		ldy #$01			ldy 	#1
.aaa2	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.aaa5	91 04		sta ($04),y			sta 	(zTemp0),y
.aaa7	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.aaaa	c8		iny				iny
.aaab	91 04		sta ($04),y			sta 	(zTemp0),y
.aaad	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.aab0	c8		iny				iny
.aab1	91 04		sta ($04),y			sta 	(zTemp0),y
.aab3	7a		ply				ply
.aab4	ca		dex				dex
.aab5	ca		dex				dex
.aab6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/binary.asm

.aab7					Stack_Add:
.aab7	ca		dex				dex
.aab8					Stack_Add_No_Dex:
.aab8	18		clc				clc
.aab9	bd 00 0c	lda $0c00,x			lda		stack0,x
.aabc	7d 01 0c	adc $0c01,x			adc 	stack0+1,x
.aabf	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aac2	bd 00 0d	lda $0d00,x			lda		stack1,x
.aac5	7d 01 0d	adc $0d01,x			adc 	stack1+1,x
.aac8	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aacb	bd 00 0e	lda $0e00,x			lda		stack2,x
.aace	7d 01 0e	adc $0e01,x			adc 	stack2+1,x
.aad1	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aad4	bd 00 0f	lda $0f00,x			lda		stack3,x
.aad7	7d 01 0f	adc $0f01,x			adc 	stack3+1,x
.aada	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aadd	60		rts				rts
.aade					Stack_Sub:
.aade	ca		dex				dex
.aadf	38		sec				sec
.aae0	bd 00 0c	lda $0c00,x			lda		stack0,x
.aae3	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.aae6	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aae9	bd 00 0d	lda $0d00,x			lda		stack1,x
.aaec	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.aaef	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aaf2	bd 00 0e	lda $0e00,x			lda		stack2,x
.aaf5	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.aaf8	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aafb	bd 00 0f	lda $0f00,x			lda		stack3,x
.aafe	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ab01	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ab04	60		rts				rts
.ab05					Stack_And:
.ab05	ca		dex				dex
.ab06	bd 00 0c	lda $0c00,x			lda		stack0,x
.ab09	3d 01 0c	and $0c01,x			and		stack0+1,x
.ab0c	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ab0f	bd 00 0d	lda $0d00,x			lda		stack1,x
.ab12	3d 01 0d	and $0d01,x			and 	stack1+1,x
.ab15	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ab18	bd 00 0e	lda $0e00,x			lda		stack2,x
.ab1b	3d 01 0e	and $0e01,x			and 	stack2+1,x
.ab1e	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ab21	bd 00 0f	lda $0f00,x			lda		stack3,x
.ab24	3d 01 0f	and $0f01,x			and 	stack3+1,x
.ab27	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ab2a	60		rts				rts
.ab2b					Stack_Xor:
.ab2b	ca		dex				dex
.ab2c	bd 00 0c	lda $0c00,x			lda		stack0,x
.ab2f	5d 01 0c	eor $0c01,x			eor		stack0+1,x
.ab32	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ab35	bd 00 0d	lda $0d00,x			lda		stack1,x
.ab38	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.ab3b	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ab3e	bd 00 0e	lda $0e00,x			lda		stack2,x
.ab41	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.ab44	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ab47	bd 00 0f	lda $0f00,x			lda		stack3,x
.ab4a	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.ab4d	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ab50	60		rts				rts
.ab51					Stack_Or:
.ab51	ca		dex				dex
.ab52	bd 00 0c	lda $0c00,x			lda		stack0,x
.ab55	1d 01 0c	ora $0c01,x			ora		stack0+1,x
.ab58	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ab5b	bd 00 0d	lda $0d00,x			lda		stack1,x
.ab5e	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.ab61	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ab64	bd 00 0e	lda $0e00,x			lda		stack2,x
.ab67	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.ab6a	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ab6d	bd 00 0f	lda $0f00,x			lda		stack3,x
.ab70	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.ab73	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ab76	60		rts				rts
.ab77					Stack_Shl:
.ab77	38		sec				sec
.ab78	80 01		bra $ab7b			bra 	StackShift
.ab7a					Stack_Shr:
.ab7a	18		clc				clc
.ab7b					StackShift:
.ab7b	08		php				php
.ab7c	ca		dex				dex
.ab7d	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; if the shift >= 32
.ab80	29 e0		and #$e0			and 	#$E0 						; going to be zero.
.ab82	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.ab85	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.ab88	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.ab8b	d0 13		bne $aba0			bne 	_SSZero
.ab8d					_SSLoop:
.ab8d	de 01 0c	dec $0c01,x			dec 	stack0+1,x 					; dec check count
.ab90	30 1a		bmi $abac			bmi 	_SSDone 					; completed ?
.ab92	28		plp				plp 								; restore flag
.ab93	08		php				php
.ab94	b0 05		bcs $ab9b			bcs 	_SSLeft 					; do either shift.
.ab96	20 f9 a9	jsr $a9f9			jsr 	Unary_Shr
.ab99	80 f2		bra $ab8d			bra 	_SSLoop
.ab9b					_SSLeft:
.ab9b	20 ec a9	jsr $a9ec			jsr 	Unary_Shl
.ab9e	80 ed		bra $ab8d			bra 	_SSLoop
.aba0					_SSZero:
.aba0	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; too many shifts.
.aba3	9e 00 0d	stz $0d00,x			stz 	stack1,x
.aba6	9e 00 0e	stz $0e00,x			stz 	stack2,x
.aba9	9e 00 0f	stz $0f00,x			stz 	stack3,x
.abac					_SSDone:
.abac	28		plp				plp 								; throw flag.
.abad	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/multiply.asm

.abae					MulInteger32:
.abae	ca		dex				dex
.abaf	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy +0 to workspace
.abb2	85 0e		sta $0e				sta 	zLTemp1
.abb4	bd 00 0d	lda $0d00,x			lda 	stack1,x
.abb7	85 0f		sta $0f				sta 	zLTemp1+1
.abb9	bd 00 0e	lda $0e00,x			lda 	stack2,x
.abbc	85 10		sta $10				sta 	zLTemp1+2
.abbe	bd 00 0f	lda $0f00,x			lda 	stack3,x
.abc1	85 11		sta $11				sta 	zLTemp1+3
.abc3	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; zero +0, where the result goes.
.abc6	9e 00 0d	stz $0d00,x			stz 	stack1,x
.abc9	9e 00 0e	stz $0e00,x			stz 	stack2,x
.abcc	9e 00 0f	stz $0f00,x			stz 	stack3,x
.abcf					_BFMMultiply:
.abcf	a5 0e		lda $0e				lda 	zLTemp1 					; get LSBit of 8-11
.abd1	29 01		and #$01			and 	#1
.abd3	f0 03		beq $abd8			beq 	_BFMNoAdd
.abd5	20 b8 aa	jsr $aab8			jsr 	Stack_Add_No_Dex 			; co-opt this code
.abd8					_BFMNoAdd:
.abd8	1e 01 0c	asl $0c01,x			asl 	stack0+1,x 					; shift +4 left
.abdb	3e 01 0d	rol $0d01,x			rol 	stack1+1,x
.abde	3e 01 0e	rol $0e01,x			rol 	stack2+1,x
.abe1	3e 01 0f	rol $0f01,x			rol 	stack3+1,x
.abe4	46 11		lsr $11				lsr 	zLTemp1+3 					; shift +8 right
.abe6	66 10		ror $10				ror 	zLTemp1+2
.abe8	66 0f		ror $0f				ror 	zLTemp1+1
.abea	66 0e		ror $0e				ror 	zLTemp1
.abec	a5 0e		lda $0e				lda 	zLTemp1 					; continue if +8 is nonzero
.abee	05 0f		ora $0f				ora 	zLTemp1+1
.abf0	05 10		ora $10				ora 	zLTemp1+2
.abf2	05 11		ora $11				ora 	zLTemp1+3
.abf4	d0 d9		bne $abcf			bne 	_BFMMultiply
.abf6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/divide.asm

.abf7					DivInteger32:
.abf7	ca		dex				dex
.abf8	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check for division by zero.
.abfb	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.abfe	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.ac01	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.ac04	d0 14		bne $ac1a			bne 	_BFDOkay
.ac06	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>ac09	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>ac11	20 42 59 20 5a 45 52 4f 00
.ac1a					_BFDOkay:
.ac1a	64 0e		stz $0e				stz 	zLTemp1 					; Q/Dividend/Left in +0
.ac1c	64 0f		stz $0f				stz 	zLTemp1+1 					; M/Divisor/Right in +4
.ac1e	64 10		stz $10				stz 	zLTemp1+2
.ac20	64 11		stz $11				stz 	zLTemp1+3
.ac22	9c 23 08	stz $0823			stz 	SignCount 					; Count of signs.
.ac25	20 80 ac	jsr $ac80			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.ac28	e8		inx				inx
.ac29	20 80 ac	jsr $ac80			jsr 	CheckIntegerNegate
.ac2c	ca		dex				dex
.ac2d	5a		phy				phy 								; Y is the counter
.ac2e	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.ac30					_BFDLoop:
.ac30	1e 00 0c	asl $0c00,x			asl 	stack0,x 					; shift AQ left.
.ac33	3e 00 0d	rol $0d00,x			rol 	stack1,x
.ac36	3e 00 0e	rol $0e00,x			rol 	stack2,x
.ac39	3e 00 0f	rol $0f00,x			rol 	stack3,x
.ac3c	26 0e		rol $0e				rol 	zLTemp1
.ac3e	26 0f		rol $0f				rol 	zLTemp1+1
.ac40	26 10		rol $10				rol 	zLTemp1+2
.ac42	26 11		rol $11				rol 	zLTemp1+3
.ac44	38		sec				sec
.ac45	a5 0e		lda $0e				lda 	zLTemp1+0 					; Calculate A-M on stack.
.ac47	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.ac4a	48		pha				pha
.ac4b	a5 0f		lda $0f				lda 	zLTemp1+1
.ac4d	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.ac50	48		pha				pha
.ac51	a5 10		lda $10				lda 	zLTemp1+2
.ac53	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.ac56	48		pha				pha
.ac57	a5 11		lda $11				lda 	zLTemp1+3
.ac59	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.ac5c	90 15		bcc $ac73			bcc 	_BFDNoAdd
.ac5e	85 11		sta $11				sta 	zLTemp1+3 					; update A
.ac60	68		pla				pla
.ac61	85 10		sta $10				sta 	zLTemp1+2
.ac63	68		pla				pla
.ac64	85 0f		sta $0f				sta 	zLTemp1+1
.ac66	68		pla				pla
.ac67	85 0e		sta $0e				sta 	zLTemp1+0
.ac69	bd 00 0c	lda $0c00,x			lda 	stack0,x 			; set Q bit 1.
.ac6c	09 01		ora #$01			ora 	#1
.ac6e	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac71	80 03		bra $ac76			bra 	_BFDNext
.ac73					_BFDNoAdd:
.ac73	68		pla				pla 								; Throw away the intermediate calculations
.ac74	68		pla				pla
.ac75	68		pla				pla
.ac76					_BFDNext:
.ac76	88		dey				dey
.ac77	d0 b7		bne $ac30			bne 	_BFDLoop
.ac79	7a		ply				ply 								; restore Y
.ac7a	4e 23 08	lsr $0823			lsr 	SignCount 					; if sign count odd,
.ac7d	b0 07		bcs $ac86			bcs		IntegerNegateAlways 		; negate the result
.ac7f	60		rts				rts
.ac80					CheckIntegerNegate:
.ac80	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; is it -ve = MSB set ?
.ac83	30 01		bmi $ac86			bmi 	IntegerNegateAlways 		; if so negate it
.ac85	60		rts				rts
.ac86					IntegerNegateAlways:
.ac86	ee 23 08	inc $0823			inc 	SignCount 					; bump the count of signs
.ac89	4c 74 a9	jmp $a974			jmp 	Unary_Negate
.ac8c					ModInteger32:
.ac8c	20 f7 ab	jsr $abf7			jsr 	DivInteger32
.ac8f	a5 0e		lda $0e				lda 	zLTemp1
.ac91	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ac94	a5 0f		lda $0f				lda 	zLTemp1+1
.ac96	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ac99	a5 10		lda $10				lda 	zLTemp1+2
.ac9b	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ac9e	a5 11		lda $11				lda 	zLTemp1+3
.aca0	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aca3	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/compare.asm

.aca4					Comp_Equal:
.aca4	38		sec				sec
.aca5	80 01		bra $aca8			bra 	Comp_CheckEqual
.aca7					Comp_NotEqual:
.aca7	18		clc				clc
.aca8					Comp_CheckEqual:
.aca8	08		php				php
.aca9	ca		dex				dex
.acaa	bd 00 0c	lda $0c00,x			lda		stack0,x
.acad	5d 01 0c	eor $0c01,x			eor 	stack0+1,x
.acb0	d0 16		bne $acc8			bne 	_CCENonZero
.acb2	bd 00 0d	lda $0d00,x			lda		stack1,x
.acb5	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.acb8	d0 0e		bne $acc8			bne 	_CCENonZero
.acba	bd 00 0e	lda $0e00,x			lda		stack2,x
.acbd	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.acc0	d0 06		bne $acc8			bne 	_CCENonZero
.acc2	bd 00 0f	lda $0f00,x			lda		stack3,x
.acc5	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.acc8					_CCENonZero:
.acc8	f0 02		beq $accc			beq 	_CCENotSet
.acca	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.accc					_CCENotSet:
.accc					CompCheckFlip:
.accc	28		plp				plp 								; if carry set, we want $FF if equal
.accd	90 02		bcc $acd1			bcc 	CompReturn
.accf	49 ff		eor #$ff			eor 	#$FF
.acd1					CompReturn:
.acd1	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; save result on stack.
.acd4	9d 00 0d	sta $0d00,x			sta 	stack1,x
.acd7	9d 00 0e	sta $0e00,x			sta 	stack2,x
.acda	9d 00 0f	sta $0f00,x			sta 	stack3,x
.acdd	60		rts				rts
.acde					Comp_Less:
.acde	18		clc				clc
.acdf	80 01		bra $ace2			bra 	Comp_LessCont
.ace1					Comp_GreaterEqual:
.ace1	38		sec				sec
.ace2					Comp_LessCont:
.ace2	08		php				php
.ace3	ca		dex				dex
.ace4	38		sec				sec
.ace5	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; do a subtraction w/o storing the result
.ace8	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.aceb	bd 00 0d	lda $0d00,x			lda 	stack1,x
.acee	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.acf1	bd 00 0e	lda $0e00,x			lda 	stack2,x
.acf4	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.acf7	bd 00 0f	lda $0f00,x			lda 	stack3,x
.acfa	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.acfd	50 02		bvc $ad01			bvc 	_CLNoFlip 					; unsigned -> signed
.acff	49 80		eor #$80			eor 	#$80
.ad01					_CLNoFlip:
.ad01	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.ad03	f0 c7		beq $accc			beq 	CompCheckFlip
.ad05	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.ad07	80 c3		bra $accc			bra 	CompCheckFlip
.ad09					Comp_LessEqual:
.ad09	38		sec				sec
.ad0a	80 01		bra $ad0d			bra 	Comp_LessEqualCont
.ad0c					Comp_Greater:
.ad0c	18		clc				clc
.ad0d					Comp_LessEqualCont:
.ad0d	08		php				php
.ad0e	ca		dex				dex
.ad0f	38		sec				sec
.ad10	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; do a subtraction w/o storing the result, backwards
.ad13	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.ad16	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.ad19	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.ad1c	bd 01 0e	lda $0e01,x			lda 	stack2+1,x
.ad1f	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.ad22	bd 01 0f	lda $0f01,x			lda 	stack3+1,x
.ad25	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.ad28	50 02		bvc $ad2c			bvc 	_CLENoFlip 					; unsigned -> signed
.ad2a	49 80		eor #$80			eor 	#$80
.ad2c					_CLENoFlip:
.ad2c	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.ad2e	f0 9c		beq $accc			beq 	CompCheckFlip
.ad30	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.ad32	80 98		bra $accc			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: miscellany/system.asm

.ad34					System_RUN:
.ad34	20 fe a3	jsr $a3fe			jsr		ResetForRun 				; clear vars, stacks etc.
.ad37	20 f3 a3	jsr $a3f3			jsr 	ResetCodePointer 			; point to first thing to do.
.ad3a	4c 60 a2	jmp $a260			jmp 	Execute						; and run
.ad3d					System_END:
.ad3d	4c 1a a0	jmp $a01a			jmp 	WarmStart
.ad40					System_STOP:
.ad40	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>ad43	53 54 4f 50 00					.text 	"STOP",0
.ad48					System_Assert:
.ad48	ca		dex				dex
.ad49	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.ad4c	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.ad4f	1d 02 0d	ora $0d02,x			ora 	stack1+2,x
.ad52	1d 03 0d	ora $0d03,x			ora 	stack1+3,x
.ad55	d0 0a		bne $ad61			bne 	_SAOkay
.ad57	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>ad5a	41 53 53 45 52 54 00				.text 	"ASSERT",0
.ad61	60		rts		_SAOkay:rts
.ad62					System_New:
.ad62	9c 00 11	stz $1100			stz 	ProgramStart 				; zero the first offset, erases.
.ad65	20 fe a3	jsr $a3fe			jsr		ResetForRun 				; clear vars, stacks etc.
.ad68	60		rts				rts
.ad69					System_Old:
.ad69	20 f3 a3	jsr $a3f3			jsr 	ResetCodePointer 			; start of first line.
.ad6c					_SOFindZero:
.ad6c	b1 00		lda ($00),y			lda 	(codePtr),y 				; look for trailing $00
.ad6e	f0 15		beq $ad85			beq 	_SOFoundEnd
.ad70	c8		iny				iny
.ad71	d0 f9		bne $ad6c			bne 	_SOFindZero
.ad73	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>ad76	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER",0
>ad7e	45 43 4f 56 45 52 00
.ad85					_SOFoundEnd:
.ad85	c8		iny				iny 								; update the offset
.ad86	8c 00 11	sty $1100			sty 	ProgramStart
.ad89	20 fe a3	jsr $a3fe			jsr 	ResetForRun 				; redo all stacks etc.
.ad8c	60		rts				rts
.ad8d					System_Sys:
.ad8d	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy and drop call address
.ad90	85 04		sta $04				sta 	zTemp0
.ad92	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ad95	85 05		sta $05				sta 	zTemp0+1
.ad97	ca		dex				dex
.ad98	da		phx				phx
.ad99	5a		phy				phy
.ad9a	ad 00 10	lda $1000			lda 	AZVariables+('A'-'A')*4		; load AXY
.ad9d	ae 5c 10	ldx $105c			ldx 	AZVariables+('X'-'A')*4
.ada0	ac 60 10	ldy $1060			ldy 	AZVariables+('Y'-'A')*4
.ada3	20 b2 ad	jsr $adb2			jsr 	_SSCall 					; effectively jsr (zTemp)
.ada6	8d 00 10	sta $1000			sta 	AZVariables+('A'-'A')*4 	; store AXY
.ada9	8e 5c 10	stx $105c			stx 	AZVariables+('X'-'A')*4
.adac	8c 60 10	sty $1060			sty 	AZVariables+('Y'-'A')*4
.adaf	7a		ply				ply
.adb0	fa		plx				plx
.adb1	60		rts				rts
.adb2	6c 04 00	jmp ($0004)	_SSCall:jmp 	(zTemp0)
.adb5					System_ShowStack:
.adb5	da		phx				phx 								; save stack
.adb6	5a		phy				phy
.adb7	86 08		stx $08				stx 	zTemp2 						; save old TOS
.adb9	a9 5b		lda #$5b			lda 	#"["
.adbb	20 09 a2	jsr $a209			jsr 	ExternPrint
.adbe	e0 00		cpx #$00			cpx 	#0 							; empty
.adc0	f0 14		beq $add6			beq 	_SSEnd
.adc2	a2 01		ldx #$01			ldx 	#1 							; start here
.adc4					_SSLoop:
.adc4	20 64 a5	jsr $a564			jsr 	IntegerToString 			; print TOS
.adc7	20 52 a5	jsr $a552			jsr 	ErrorPrintIntegerBuffer
.adca	e4 08		cpx $08				cpx 	zTemp2 						; done TOS exit
.adcc	f0 08		beq $add6			beq 	_SSEnd
.adce	e8		inx				inx	 								; advance pointer print ,
.adcf	a9 2c		lda #$2c			lda 	#','
.add1	20 09 a2	jsr $a209			jsr 	ExternPrint
.add4	80 ee		bra $adc4			bra 	_SSLoop
.add6					_SSEnd:
.add6	a9 5d		lda #$5d			lda 	#"]"						; finish off.
.add8	20 09 a2	jsr $a209			jsr 	ExternPrint
.addb	a9 0d		lda #$0d			lda 	#13
.addd	20 09 a2	jsr $a209			jsr 	ExternPrint
.ade0	7a		ply				ply
.ade1	fa		plx				plx
.ade2	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: miscellany/variables.asm

.ade3					Identifier:
.ade3	88		dey				dey 								; wind back to identifier start
.ade4	20 19 a3	jsr $a319			jsr 	IdentifierSearch 			; try to find it.
.ade7	90 2d		bcc $ae16			bcc 	_IDUnknown 					; not known, give up.
.ade9	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.adeb	d0 3d		bne $ae2a			bne 	IDTypeError
.aded	c8		iny		_IDSkip:iny
.adee	b1 00		lda ($00),y			lda 	(codePtr),y
.adf0	c9 c0		cmp #$c0			cmp 	#$C0
.adf2	b0 f9		bcs $aded			bcs 	_IDSkip
.adf4	20 82 a4	jsr $a482			jsr 	IndexCheck 					; check index/subscript
.adf7	5a		phy				phy
.adf8	e8		inx				inx 								; make space on stack
.adf9	a0 00		ldy #$00			ldy 	#0 							; copy it back
.adfb	b1 12		lda ($12),y			lda 	(idDataAddr),y
.adfd	9d 00 0c	sta $0c00,x			sta 	stack0,x
.ae00	c8		iny				iny
.ae01	b1 12		lda ($12),y			lda 	(idDataAddr),y
.ae03	9d 00 0d	sta $0d00,x			sta 	stack1,x
.ae06	c8		iny				iny
.ae07	b1 12		lda ($12),y			lda 	(idDataAddr),y
.ae09	9d 00 0e	sta $0e00,x			sta 	stack2,x
.ae0c	c8		iny				iny
.ae0d	b1 12		lda ($12),y			lda 	(idDataAddr),y
.ae0f	9d 00 0f	sta $0f00,x			sta 	stack3,x
.ae12	7a		ply				ply
.ae13	4c 60 a2	jmp $a260			jmp 	Execute
.ae16					_IDUnknown:
.ae16	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>ae19	55 4e 4b 4e 4f 57 4e 20				.text 	"UNKNOWN VARIABLE",0
>ae21	56 41 52 49 41 42 4c 45 00
.ae2a					IDTypeError:
.ae2a	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>ae2d	4d 49 53 53 49 4e 47 20				.text 	"MISSING VARIABLE",0
>ae35	56 41 52 49 41 42 4c 45 00
.ae3e					WriteVariable:
.ae3e	b1 00		lda ($00),y			lda 	(codePtr),y 				; check variable
.ae40	c9 c0		cmp #$c0			cmp 	#$C0
.ae42	90 e6		bcc $ae2a			bcc 	IDTypeError
.ae44	20 19 a3	jsr $a319			jsr 	IdentifierSearch 			; does it exist
.ae47	90 06		bcc $ae4f			bcc 	_WVNoIdentifier
.ae49	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.ae4b	f0 12		beq $ae5f			beq 	_WVWriteTOS 				; if so write TOS to it.
.ae4d	80 db		bra $ae2a			bra 	IDTypeError 				; not, then can't do anything.
.ae4f					_WVNoIdentifier:
.ae4f	5a		phy				phy 								; get current line number
.ae50	a0 01		ldy #$01			ldy 	#1
.ae52	b1 00		lda ($00),y			lda 	(codePtr),y
.ae54	c8		iny				iny
.ae55	11 00		ora ($00),y			ora 	(codePtr),y
.ae57	7a		ply				ply
.ae58	f0 2d		beq $ae87			beq 	_WVCantCreate 				; if zero (command line) no new vars
.ae5a	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; create identifier
.ae5c	20 80 a3	jsr $a380			jsr 	IdentifierCreate 			; try to find it
.ae5f					_WVWriteTOS:
.ae5f	88		dey				dey 								; skip over identifier.
.ae60					_WVSkipIdentifier:
.ae60	c8		iny				iny
.ae61	b1 00		lda ($00),y			lda 	(codePtr),y
.ae63	c9 c0		cmp #$c0			cmp 	#$C0
.ae65	b0 f9		bcs $ae60			bcs 	_WVSkipIdentifier
.ae67	20 82 a4	jsr $a482			jsr 	IndexCheck 					; check index/subscript
.ae6a	5a		phy				phy									; copy TOS in
.ae6b	a0 00		ldy #$00			ldy 	#0
.ae6d	bd 00 0c	lda $0c00,x			lda 	stack0,x
.ae70	91 12		sta ($12),y			sta 	(idDataAddr),y
.ae72	c8		iny				iny
.ae73	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ae76	91 12		sta ($12),y			sta 	(idDataAddr),y
.ae78	c8		iny				iny
.ae79	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ae7c	91 12		sta ($12),y			sta 	(idDataAddr),y
.ae7e	c8		iny				iny
.ae7f	bd 00 0f	lda $0f00,x			lda 	stack3,x
.ae82	91 12		sta ($12),y			sta 	(idDataAddr),y
.ae84	7a		ply				ply
.ae85	ca		dex				dex 								; drop
.ae86	60		rts				rts									; go back and execute again.
.ae87					_WVCantCreate:
.ae87	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>ae8a	43 41 4e 4e 4f 54 20 43				.text 	"CANNOT CREATE VARIABLE",0
>ae92	52 45 41 54 45 20 56 41 52 49 41 42 4c 45 00

;******  Return to file: main.asm


;******  Processing file: structures/fornext.asm

.aea1					Command_For:
.aea1	20 a6 af	jsr $afa6			jsr 	StructPushCurrent 			; push current on the stack.
.aea4	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check zero
.aea7	1d 00 0d	ora $0d00,x			ora 	stack1,x
.aeaa	1d 00 0e	ora $0e00,x			ora 	stack2,x
.aead	1d 00 0f	ora $0f00,x			ora 	stack3,x
.aeb0	f0 34		beq $aee6			beq 	_CFZero
.aeb2	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; push 1's complement of index on
.aeb5	49 ff		eor #$ff			eor 	#$FF 						; structure stack.
.aeb7	c6 02		dec $02				dec 	StructSP
.aeb9	92 02		sta ($02)			sta 	(StructSP)
.aebb	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aebe	49 ff		eor #$ff			eor 	#$FF
.aec0	c6 02		dec $02				dec 	StructSP
.aec2	92 02		sta ($02)			sta 	(StructSP)
.aec4	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aec7	49 ff		eor #$ff			eor 	#$FF
.aec9	c6 02		dec $02				dec 	StructSP
.aecb	92 02		sta ($02)			sta 	(StructSP)
.aecd	bd 00 0c	lda $0c00,x			lda 	stack0,x
.aed0	49 ff		eor #$ff			eor 	#$FF
.aed2	c6 02		dec $02				dec 	StructSP
.aed4	92 02		sta ($02)			sta 	(StructSP)
.aed6	ca		dex				dex 								; pop stack value
.aed7	a9 46		lda #$46			lda 	#STM_FOR 					; push FOR marker
.aed9	c6 02		dec $02				dec 	StructSP
.aedb	92 02		sta ($02)			sta 	(StructSP)
.aedd	a5 02		lda $02				lda 	StructSP 					; copy current so it can access it.
.aedf	85 14		sta $14				sta 	ForAddr
.aee1	a5 03		lda $03				lda 	StructSP+1
.aee3	85 15		sta $15				sta 	ForAddr+1
.aee5	60		rts				rts
.aee6					_CFZero:
.aee6	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>aee9	46 4f 52 20 43 4f 55 4e				.text 	"FOR COUNT ZERO",0
>aef1	54 20 5a 45 52 4f 00
.aef8					Command_Next:
.aef8	b2 02		lda ($02)			lda 	(StructSP)					; check it's FOR.
.aefa	c9 46		cmp #$46			cmp 	#STM_FOR
.aefc	d0 30		bne $af2e			bne 	_CNNoFor
.aefe	5a		phy				phy
.aeff	a0 00		ldy #$00			ldy 	#0
.af01					_CNIncrement:
.af01	c8		iny				iny
.af02	b1 02		lda ($02),y			lda 	(StructSP),y 				; increment the index
.af04	1a		inc a				inc 	a
.af05	91 02		sta ($02),y			sta 	(StructSP),y
.af07	f0 f8		beq $af01			beq		_CNIncrement 				; carry out.
.af09	a0 01		ldy #$01			ldy 	#1 							; now and all the counts together
.af0b	b1 02		lda ($02),y			lda 	(StructSP),y 				; on the last time round they
.af0d	c8		iny				iny 								; will all be $FF
.af0e	31 02		and ($02),y			and 	(StructSP),y
.af10	c8		iny				iny
.af11	31 02		and ($02),y			and 	(StructSP),y
.af13	c8		iny				iny
.af14	31 02		and ($02),y			and 	(StructSP),y
.af16	7a		ply				ply 								; restore Y
.af17	1a		inc a				inc 	a 							; so this will be zero last time round
.af18	d0 06		bne $af20			bne 	_CNLoop 					; loop back if non-zero
.af1a	a9 09		lda #$09			lda 	#9 							; pop 9 elements off structure stack.
.af1c	20 a0 af	jsr $afa0			jsr 	StructPopCount
.af1f	60		rts				rts
.af20					_CNLoop:
.af20	a5 02		lda $02				lda 	StructSP 					; copy current so it can access it.
.af22	85 14		sta $14				sta 	ForAddr
.af24	a5 03		lda $03				lda 	StructSP+1
.af26	85 15		sta $15				sta 	ForAddr+1
.af28	a0 05		ldy #$05			ldy 	#5 							; restore the position
.af2a	20 be af	jsr $afbe			jsr 	StructPopCurrent
.af2d	60		rts				rts
.af2e					_CNNoFor:
.af2e	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>af31	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>af39	46 4f 52 00
.af3d					Command_Index:
.af3d	5a		phy				phy
.af3e	a0 01		ldy #$01			ldy 	#1 							; get the stack position of
.af40	e8		inx				inx
.af41	38		sec				sec
.af42	a9 fe		lda #$fe			lda 	#$FE
.af44	f1 14		sbc ($14),y			sbc 	(ForAddr),y
.af46	9d 00 0c	sta $0c00,x			sta 	stack0,x
.af49	c8		iny				iny
.af4a	a9 ff		lda #$ff			lda 	#$FF
.af4c	f1 14		sbc ($14),y			sbc 	(ForAddr),y
.af4e	9d 00 0d	sta $0d00,x			sta 	stack1,x
.af51	c8		iny				iny
.af52	a9 ff		lda #$ff			lda 	#$FF
.af54	f1 14		sbc ($14),y			sbc 	(ForAddr),y
.af56	9d 00 0e	sta $0e00,x			sta 	stack2,x
.af59	c8		iny				iny
.af5a	a9 ff		lda #$ff			lda 	#$FF
.af5c	f1 14		sbc ($14),y			sbc 	(ForAddr),y
.af5e	9d 00 0f	sta $0f00,x			sta 	stack3,x
.af61	7a		ply				ply
.af62	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: structures/repeat.asm

.af63					Command_Repeat:
.af63	20 a6 af	jsr $afa6			jsr 	StructPushCurrent 			; push current on the stack.
.af66	a9 52		lda #$52			lda 	#STM_REPEAT 				; push marker
.af68	c6 02		dec $02				dec 	StructSP
.af6a	92 02		sta ($02)			sta 	(StructSP)
.af6c	60		rts				rts
.af6d					Command_Until:
.af6d	b2 02		lda ($02)			lda 	(StructSP)					; check it's REPEAT
.af6f	c9 52		cmp #$52			cmp 	#STM_REPEAT
.af71	d0 1b		bne $af8e			bne 	_CUNoRepeat
.af73	ca		dex				dex 								; pop
.af74	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check old TOS zero
.af77	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.af7a	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.af7d	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.af80	f0 06		beq $af88			beq 	_CULoop
.af82	a9 05		lda #$05			lda 	#5 							; pop 5 elements off structure stack.
.af84	20 a0 af	jsr $afa0			jsr 	StructPopCount
.af87	60		rts				rts
.af88					_CULoop:
.af88	a0 01		ldy #$01			ldy 	#1 							; restore the position
.af8a	20 be af	jsr $afbe			jsr 	StructPopCurrent
.af8d	60		rts				rts
.af8e					_CUNoRepeat:
.af8e	20 fb a4	jsr $a4fb			jsr 	ErrorHandler
>af91	4d 49 53 53 49 4e 47 20				.text 	"MISSING REPEAT",0
>af99	52 45 50 45 41 54 00

;******  Return to file: main.asm


;******  Processing file: structures/structures.asm

.afa0					StructPopCount:
.afa0	18		clc				clc
.afa1	65 02		adc $02				adc 	StructSP
.afa3	85 02		sta $02				sta 	StructSP
.afa5	60		rts				rts
.afa6					StructPushCurrent:
.afa6	a9 00		lda #$00			lda 	#0							; push bank
.afa8	c6 02		dec $02				dec 	StructSP
.afaa	92 02		sta ($02)			sta 	(StructSP)
.afac	98		tya				tya									; y Offset
.afad	c6 02		dec $02				dec 	StructSP
.afaf	92 02		sta ($02)			sta 	(StructSP)
.afb1	a5 01		lda $01				lda 	codePtr+1 					; codeptr high
.afb3	c6 02		dec $02				dec 	StructSP
.afb5	92 02		sta ($02)			sta 	(StructSP)
.afb7	a5 00		lda $00				lda 	codePtr 					; codeptr low
.afb9	c6 02		dec $02				dec 	StructSP
.afbb	92 02		sta ($02)			sta 	(StructSP)
.afbd	60		rts				rts
.afbe					StructPopCurrent:
.afbe	b1 02		lda ($02),y			lda 	(StructSP),y 				; codeptr low
.afc0	85 00		sta $00				sta 	codePtr
.afc2	c8		iny				iny
.afc3	b1 02		lda ($02),y			lda 	(StructSP),y 				; codeptr high
.afc5	85 01		sta $01				sta 	codePtr+1
.afc7	c8		iny				iny
.afc8	b1 02		lda ($02),y			lda 	(StructSP),y				; y offset
.afca	a8		tay				tay
.afcb	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/testcode.inc

>1100	0c 64 00 84 4a 85 4a 86			.byte $0c,$64,$00,$84,$4a,$85,$4a,$86,$4a,$87,$4a,$00,$06,$6e,$00,$33,$41,$00
>1108	4a 87 4a 00 06 6e 00 33 41 00

;******  Return to file: main.asm

>1112	00						.byte 	0

;******  End of listing
