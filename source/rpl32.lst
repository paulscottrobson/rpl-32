
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -o rpl32.prg -L rpl32.lst main.asm
; Sat Oct  5 16:38:20 2019

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: main.asm


;******  Processing file: data.asm

=$a000					BuildAddress = $A000 						; build the interpreter here
=$0c00					StackAddress = $0C00 						; 1k of stack space (256 x 32 bits)
=$1000					MemoryStart = $1000 						; system memory starts here
=$6000					MemoryEnd = $6000 							; and ends here.
=$0bff					StructureStack = $0BFF 						; structure stack (works down to $xx00)
=$0a00					ExtDataArea = $0A00 						; space where non zp data goes
=16					HashTableSize = 16 							; hash tables to search.
>0000					CodePtr: 		.word ? 					; code pointer
>0002					StructSP: 		.word ?						; structure stack pointer
>0004					zTemp0:			.word ?						; temporary words
>0006					zTemp1: 		.word ?
>0008					zTemp2: 		.word ?
>000a					zLTemp1:		.dword ?					; temporary longs
>000e					idDataAddr:		.word ? 					; data address.
>0010					ForAddr:		.byte ? 					; points to current FOR structure
>0a00					SBuffer:		.fill 32 					; string buffer
>0a20					SBPosition:		.byte ? 					; position in String Buffer
>0a21					NumConvCount:	.byte ? 					; used in int to string
>0a22					breakCount:		.byte ? 					; used to stop break firing every execution.
>0a23					SignCount:		.byte ?						; sign count for divide
>0a24					NumSuppress:	.byte ? 					; zero suppression flag
>1000					AZVariables:	.fill	26*4 				; 26 x 4 byte variables, which are A-Z
>1068					HashTable: 		.fill 	HashTableSize * 2 	; n x 2 links for the hash tables.
>1088	00 00				VarMemory:		.word 	0 					; next free byte available for VARIABLES (going up)
>108a	00 00				AllocMemory: 	.word 	0 					; last free byte availabel for ALLOC (going down)
=4352					ProgramStart	= MemoryStart + $100 		; where code actually goes.
=$0c00					stack0 = StackAddress
=3328					stack1 = StackAddress+256
=3584					stack2 = StackAddress+512
=3840					stack3 = StackAddress+768
="V"					IDT_VARIABLE = 'V'							; type markers for the information store.
="P"					IDT_PROCEDURE = 'P'							; standard procedure (e.g. in code)
="C"					IDT_CODEPROC = 'C'							; machine language procedure.
="F"					STM_FOR = 'F'								; structure markers (for/next)
="C"					STM_CALL = 'C'								; call & return  (& ;)
="R"					STM_REPEAT = 'R'							; repeat & until
=0					COL_BLACK = 0
=1					COL_RED = 1
=2					COL_GREEN = 2
=3					COL_YELLOW = 3
=4					COL_BLUE = 4
=5					COL_MAGENTA = 5
=6					COL_CYAN = 6
=7					COL_WHITE = 7
=5					CTH_ERROR = COL_MAGENTA

;******  Return to file: main.asm


;******  Processing file: macro.asm


;******  Return to file: main.asm

.0f00	4c 00 a0	jmp $a000			jmp 	Start
.a000					Start:
.a000	a2 ff		ldx #$ff			ldx 	#$FF 						; reset the stack.
.a002	9a		txs				txs
.a003	20 9f a1	jsr $a19f			jsr 	ExternInitialise 			; interface setup
.a006	a2 00		ldx #$00			ldx 	#0 							; display boot message
.a008					_Display:
.a008	bd 1d a0	lda $a01d,x			lda 	BootMessage,x
.a00b	20 bb a1	jsr $a1bb			jsr 	ExternPrint
.a00e	e8		inx				inx
.a00f	bd 1d a0	lda $a01d,x			lda 	BootMessage,x
.a012	d0 f4		bne $a008			bne 	_Display
.a014	20 7e a3	jsr $a37e			jsr 	ResetForRun
.a017	20 73 a3	jsr $a373			jsr 	ResetCodePointer
.a01a	4c bd a9	jmp $a9bd			jmp 	System_RUN
.a01d					BootMessage:

;******  Processing file: generated/bootmessage.inc

>a01d	2a 2a 2a 2a 20 52 50 4c			.byte $2a,$2a,$2a,$2a,$20,$52,$50,$4c,$2f,$33,$32,$20,$49,$4e,$54,$45,$52,$50,$52,$45,$54,$45,$52,$20,$2a,$2a,$2a,$2a,$0d,$0d,$42,$55,$49,$4c,$44,$3a,$31,$34,$32,$20,$44,$41,$54,$45,$3a,$30,$35,$2d,$4f,$43,$54,$2d,$32,$30,$31,$39,$0d,$0d,$00
>a025	2f 33 32 20 49 4e 54 45 52 50 52 45 54 45 52 20
>a035	2a 2a 2a 2a 0d 0d 42 55 49 4c 44 3a 31 34 32 20
>a045	44 41 54 45 3a 30 35 2d 4f 43 54 2d 32 30 31 39
>a055	0d 0d 00

;******  Return to file: main.asm


;******  Processing file: generated/tables.inc

.a058					KeywordText:
>a058	01 20					.byte $01,$20                          ; $10
>a05a	01 21					.byte $01,$21                          ; $11 !
>a05c	01 26					.byte $01,$26                          ; $12 &
>a05e	01 2a					.byte $01,$2a                          ; $13 *
>a060	01 2b					.byte $01,$2b                          ; $14 +
>a062	02 2b 2b				.byte $02,$2b,$2b                      ; $15 ++
>a065	01 2d					.byte $01,$2d                          ; $16 -
>a067	02 2d 2d				.byte $02,$2d,$2d                      ; $17 --
>a06a	01 2f					.byte $01,$2f                          ; $18 /
>a06c	01 3b					.byte $01,$3b                          ; $19 ;
>a06e	01 3c					.byte $01,$3c                          ; $1a <
>a070	02 3c 3c				.byte $02,$3c,$3c                      ; $1b <<
>a073	02 3c 3d				.byte $02,$3c,$3d                      ; $1c <=
>a076	02 3c 3e				.byte $02,$3c,$3e                      ; $1d <>
>a079	01 3d					.byte $01,$3d                          ; $1e =
>a07b	01 3e					.byte $01,$3e                          ; $1f >
>a07d	02 3e 3d				.byte $02,$3e,$3d                      ; $20 >=
>a080	02 3e 3e				.byte $02,$3e,$3e                      ; $21 >>
>a083	01 00					.byte $01,$00                          ; $22 @
>a085	03 01 02 13				.byte $03,$01,$02,$13                  ; $23 ABS
>a089	05 01 0c 0c 0f 03			.byte $05,$01,$0c,$0c,$0f,$03          ; $24 ALLOC
>a08f	03 01 0e 04				.byte $03,$01,$0e,$04                  ; $25 AND
>a093	06 01 13 13 05 12 14			.byte $06,$01,$13,$13,$05,$12,$14      ; $26 ASSERT
>a09a	02 03 21				.byte $02,$03,$21                      ; $27 C!
>a09d	02 03 00				.byte $02,$03,$00                      ; $28 C@
>a0a0	03 04 05 06				.byte $03,$04,$05,$06                  ; $29 DEF
>a0a4	04 04 12 0f 10				.byte $04,$04,$12,$0f,$10              ; $2a DROP
>a0a9	03 04 15 10				.byte $03,$04,$15,$10                  ; $2b DUP
>a0ad	04 05 0c 13 05				.byte $04,$05,$0c,$13,$05              ; $2c ELSE
>a0b2	05 05 0d 10 14 19			.byte $05,$05,$0d,$10,$14,$19          ; $2d EMPTY
>a0b8	03 05 0e 04				.byte $03,$05,$0e,$04                  ; $2e END
>a0bc	05 05 0e 04 09 06			.byte $05,$05,$0e,$04,$09,$06          ; $2f ENDIF
>a0c2	03 06 0f 12				.byte $03,$06,$0f,$12                  ; $30 FOR
>a0c6	02 09 06				.byte $02,$09,$06                      ; $31 IF
>a0c9	05 09 0e 04 05 18			.byte $05,$09,$0e,$04,$05,$18          ; $32 INDEX
>a0cf	04 0c 09 13 14				.byte $04,$0c,$09,$13,$14              ; $33 LIST
>a0d4	03 0d 0f 04				.byte $03,$0d,$0f,$04                  ; $34 MOD
>a0d8	06 0e 05 07 01 14 05			.byte $06,$0e,$05,$07,$01,$14,$05      ; $35 NEGATE
>a0df	03 0e 05 17				.byte $03,$0e,$05,$17                  ; $36 NEW
>a0e3	04 0e 05 18 14				.byte $04,$0e,$05,$18,$14              ; $37 NEXT
>a0e8	03 0e 09 10				.byte $03,$0e,$09,$10                  ; $38 NIP
>a0ec	03 0e 0f 14				.byte $03,$0e,$0f,$14                  ; $39 NOT
>a0f0	03 0f 0c 04				.byte $03,$0f,$0c,$04                  ; $3a OLD
>a0f4	02 0f 12				.byte $02,$0f,$12                      ; $3b OR
>a0f7	04 0f 16 05 12				.byte $04,$0f,$16,$05,$12              ; $3c OVER
>a0fc	06 12 05 10 05 01 14			.byte $06,$12,$05,$10,$05,$01,$14      ; $3d REPEAT
>a103	03 12 15 0e				.byte $03,$12,$15,$0e                  ; $3e RUN
>a107	04 13 14 0f 10				.byte $04,$13,$14,$0f,$10              ; $3f STOP
>a10c	04 13 17 01 10				.byte $04,$13,$17,$01,$10              ; $40 SWAP
>a111	03 13 19 13				.byte $03,$13,$19,$13                  ; $41 SYS
>a115	05 15 0e 14 09 0c			.byte $05,$15,$0e,$14,$09,$0c          ; $42 UNTIL
>a11b	02 17 21				.byte $02,$17,$21                      ; $43 W!
>a11e	02 17 00				.byte $02,$17,$00                      ; $44 W@
>a121	03 18 0f 12				.byte $03,$18,$0f,$12                  ; $45 XOR
>a125	02 1b 1d				.byte $02,$1b,$1d                      ; $46 []
>a128	01 1e					.byte $01,$1e                          ; $47 ^
>a12a	01 2d					.byte $01,$2d                          ; $48 {-}
>a12c	00					.byte $00
.a12d					KeywordVectorTable:
>a12d	74 a4					.word SyntaxError                      ; $10
>a12f	50 a7					.word Mem_DPoke                        ; $11 !
>a131	74 a4					.word SyntaxError                      ; $12 &
>a133	37 a8					.word MulInteger32                     ; $13 *
>a135	77 a7					.word Stack_Add                        ; $14 +
>a137	77 a6					.word Unary_Increment                  ; $15 ++
>a139	9e a7					.word Stack_Sub                        ; $16 -
>a13b	8a a6					.word Unary_Decrement                  ; $17 --
>a13d	80 a8					.word DivInteger32                     ; $18 /
>a13f	74 a4					.word SyntaxError                      ; $19 ;
>a141	67 a9					.word Comp_Less                        ; $1a <
>a143	ac a6					.word Unary_Shl                        ; $1b <<
>a145	92 a9					.word Comp_LessEqual                   ; $1c <=
>a147	30 a9					.word Comp_NotEqual                    ; $1d <>
>a149	2d a9					.word Comp_Equal                       ; $1e =
>a14b	95 a9					.word Comp_Greater                     ; $1f >
>a14d	6a a9					.word Comp_GreaterEqual                ; $20 >=
>a14f	b9 a6					.word Unary_Shr                        ; $21 >>
>a151	fe a6					.word Mem_DPeek                        ; $22 @
>a153	2e a6					.word Unary_Absolute                   ; $23 ABS
>a155	74 a4					.word SyntaxError                      ; $24 ALLOC
>a157	c5 a7					.word Stack_And                        ; $25 AND
>a159	d5 a9					.word System_Assert                    ; $26 ASSERT
>a15b	23 a7					.word Mem_Poke                         ; $27 C!
>a15d	c6 a6					.word Mem_Peek                         ; $28 C@
>a15f	74 a4					.word SyntaxError                      ; $29 DEF
>a161	a3 a5					.word Stack_Drop                       ; $2a DROP
>a163	a5 a5					.word Stack_Dup                        ; $2b DUP
>a165	74 a4					.word SyntaxError                      ; $2c ELSE
>a167	a0 a5					.word Stack_Empty                      ; $2d EMPTY
>a169	c6 a9					.word System_END                       ; $2e END
>a16b	74 a4					.word SyntaxError                      ; $2f ENDIF
>a16d	00 ab					.word Command_For                      ; $30 FOR
>a16f	74 a4					.word SyntaxError                      ; $31 IF
>a171	9c ab					.word Command_Index                    ; $32 INDEX
>a173	74 a4					.word SyntaxError                      ; $33 LIST
>a175	15 a9					.word ModInteger32                     ; $34 MOD
>a177	34 a6					.word Unary_Negate                     ; $35 NEGATE
>a179	ef a9					.word System_New                       ; $36 NEW
>a17b	57 ab					.word Command_Next                     ; $37 NEXT
>a17d	bf a5					.word Stack_Nip                        ; $38 NIP
>a17f	56 a6					.word Unary_Not                        ; $39 NOT
>a181	f6 a9					.word System_Old                       ; $3a OLD
>a183	11 a8					.word Stack_Or                         ; $3b OR
>a185	d9 a5					.word Stack_Over                       ; $3c OVER
>a187	74 a4					.word SyntaxError                      ; $3d REPEAT
>a189	bd a9					.word System_RUN                       ; $3e RUN
>a18b	ca a9					.word System_STOP                      ; $3f STOP
>a18d	f3 a5					.word Stack_Swap                       ; $40 SWAP
>a18f	1a aa					.word System_Sys                       ; $41 SYS
>a191	74 a4					.word SyntaxError                      ; $42 UNTIL
>a193	35 a7					.word Mem_WPoke                        ; $43 W!
>a195	df a6					.word Mem_WPeek                        ; $44 W@
>a197	eb a7					.word Stack_Xor                        ; $45 XOR
>a199	74 a4					.word SyntaxError                      ; $46 []
>a19b	9d aa					.word WriteVariable                    ; $47 ^
>a19d	34 a6					.word Unary_Const_Minus                ; $48 {-}
=$10					KWD_SPACE = $10                  ; $10
=$11					KWD_PLING = $11                  ; $11 !
=$12					KWD_AMPERSAND = $12              ; $12 &
=$13					KWD_ASTERISK = $13               ; $13 *
=$14					KWD_PLUS = $14                   ; $14 +
=$15					KWD_PLUSPLUS = $15               ; $15 ++
=$16					KWD_MINUS = $16                  ; $16 -
=$17					KWD_MINUSMINUS = $17             ; $17 --
=$18					KWD_SLASH = $18                  ; $18 /
=$19					KWD_SEMICOLON = $19              ; $19 ;
=$1a					KWD_LESS = $1a                   ; $1a <
=$1b					KWD_LESSLESS = $1b               ; $1b <<
=$1c					KWD_LESSEQUAL = $1c              ; $1c <=
=$1d					KWD_LESSGREATER = $1d            ; $1d <>
=$1e					KWD_EQUAL = $1e                  ; $1e =
=$1f					KWD_GREATER = $1f                ; $1f >
=$20					KWD_GREATEREQUAL = $20           ; $20 >=
=$21					KWD_GREATERGREATER = $21         ; $21 >>
=$22					KWD_AT = $22                     ; $22 @
=$23					KWD_ABS = $23                    ; $23 ABS
=$24					KWD_ALLOC = $24                  ; $24 ALLOC
=$25					KWD_AND = $25                    ; $25 AND
=$26					KWD_ASSERT = $26                 ; $26 ASSERT
=$27					KWD_CPLING = $27                 ; $27 C!
=$28					KWD_CAT = $28                    ; $28 C@
=$29					KWD_DEF = $29                    ; $29 DEF
=$2a					KWD_DROP = $2a                   ; $2a DROP
=$2b					KWD_DUP = $2b                    ; $2b DUP
=$2c					KWD_ELSE = $2c                   ; $2c ELSE
=$2d					KWD_EMPTY = $2d                  ; $2d EMPTY
=$2e					KWD_END = $2e                    ; $2e END
=$2f					KWD_ENDIF = $2f                  ; $2f ENDIF
=$30					KWD_FOR = $30                    ; $30 FOR
=$31					KWD_IF = $31                     ; $31 IF
=$32					KWD_INDEX = $32                  ; $32 INDEX
=$33					KWD_LIST = $33                   ; $33 LIST
=$34					KWD_MOD = $34                    ; $34 MOD
=$35					KWD_NEGATE = $35                 ; $35 NEGATE
=$36					KWD_NEW = $36                    ; $36 NEW
=$37					KWD_NEXT = $37                   ; $37 NEXT
=$38					KWD_NIP = $38                    ; $38 NIP
=$39					KWD_NOT = $39                    ; $39 NOT
=$3a					KWD_OLD = $3a                    ; $3a OLD
=$3b					KWD_OR = $3b                     ; $3b OR
=$3c					KWD_OVER = $3c                   ; $3c OVER
=$3d					KWD_REPEAT = $3d                 ; $3d REPEAT
=$3e					KWD_RUN = $3e                    ; $3e RUN
=$3f					KWD_STOP = $3f                   ; $3f STOP
=$40					KWD_SWAP = $40                   ; $40 SWAP
=$41					KWD_SYS = $41                    ; $41 SYS
=$42					KWD_UNTIL = $42                  ; $42 UNTIL
=$43					KWD_WPLING = $43                 ; $43 W!
=$44					KWD_WAT = $44                    ; $44 W@
=$45					KWD_XOR = $45                    ; $45 XOR
=$46					KWD_LSQPARENRSQPAREN = $46       ; $46 []
=$47					KWD_HAT = $47                    ; $47 ^
=$48					KWD_CONSTANT_MINUS = $48         ; $48 {-}

;******  Return to file: main.asm


;******  Processing file: system/extern.asm

.a19f					ExternInitialise:
.a19f	a9 60		lda #$60			lda 	#$60 							; set colour
.a1a1	8d 86 02	sta $0286			sta 	646
.a1a4	a9 93		lda #$93			lda 	#147 						; clear screen
.a1a6	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1a9	a9 07		lda #$07			lda 	#COL_WHITE 					; white text.
.a1ab	4c c5 a1	jmp $a1c5			jmp 	ExternColour
.a1ae					ExternCheckBreak:
.a1ae	da		phx				phx 								; make sure we keep XY
.a1af	5a		phy				phy
.a1b0	20 e1 ff	jsr $ffe1			jsr 	$FFE1						; STOP check on CBM KERNAL
.a1b3	f0 03		beq $a1b8			beq		_ECBExit 					; stopped
.a1b5	7a		ply				ply 								; restore and exit.
.a1b6	fa		plx				plx
.a1b7	60		rts				rts
.a1b8					_ECBExit:
.a1b8	4c c8 a4	jmp $a4c8			jmp 	WarmStart
.a1bb					ExternPrint:
.a1bb	48		pha				pha
.a1bc	da		phx				phx
.a1bd	5a		phy				phy
.a1be	20 d2 ff	jsr $ffd2			jsr 	$FFD2
.a1c1	7a		ply				ply
.a1c2	fa		plx				plx
.a1c3	68		pla				pla
.a1c4	60		rts				rts
.a1c5					ExternColour:
.a1c5	48		pha				pha
.a1c6	da		phx				phx
.a1c7	aa		tax				tax
.a1c8	bd d1 a1	lda $a1d1,x			lda 	_ECTable,x
.a1cb	20 bb a1	jsr $a1bb			jsr 	ExternPrint
.a1ce	fa		plx				plx
.a1cf	68		pla				pla
.a1d0	60		rts				rts
.a1d1					_ECTable:
>a1d1	90						.byte 	144
>a1d2	1c						.byte 	28
>a1d3	1e						.byte 	30
>a1d4	9e						.byte 	158
>a1d5	1f						.byte 	31
>a1d6	9c						.byte 	156
>a1d7	a9						.byte 	169
>a1d8	05						.byte 	5

;******  Return to file: main.asm


;******  Processing file: system/execute.asm

.a1d9					EXNextLine:
.a1d9	b2 00		lda ($00)			lda 	(codePtr) 					; is it run from the buffer (offset 0)
.a1db	f0 0f		beq $a1ec			beq 	_EXNLWarmStart
.a1dd	18		clc				clc 								; advance code pointer to next line
.a1de	65 00		adc $00				adc 	codePtr
.a1e0	85 00		sta $00				sta 	codePtr
.a1e2	90 02		bcc $a1e6			bcc 	_EXNLNoBump
.a1e4	e6 01		inc $01				inc 	codePtr+1
.a1e6					_EXNLNoBump:
.a1e6	a0 03		ldy #$03			ldy 	#3 							; position in that line
.a1e8	b2 00		lda ($00)			lda 	(codePtr) 					; read offset
.a1ea	d0 03		bne $a1ef			bne 	Execute 					; not end of program
.a1ec					_EXNLWarmStart:
.a1ec	4c c6 a9	jmp $a9c6			jmp 	System_END
.a1ef					Execute:
.a1ef	ee 22 0a	inc $0a22			inc 	BreakCount 					; break occasionally. too slow otherwise.
.a1f2	d0 03		bne $a1f7			bne 	_EXNoBreak
.a1f4	20 ae a1	jsr $a1ae			jsr 	ExternCheckBreak
.a1f7					_EXNoBreak:
.a1f7					_EXGetNext:
.a1f7	b1 00		lda ($00),y			lda 	(codePtr),y 				; load the character
.a1f9	f0 de		beq $a1d9			beq 	EXNextLine 					; reached end of the line.
.a1fb	c8		iny				iny 								; advance pointer.
.a1fc	c9 10		cmp #$10			cmp 	#KWD_SPACE 					; skip spaces
.a1fe	f0 f7		beq $a1f7			beq 	_ExGetNext
.a200	c9 10		cmp #$10			cmp 	#$10 						; is it 01-0F, which means a string/comment ?
.a202	90 65		bcc $a269			bcc 	EXStringComment
.a204	c9 80		cmp #$80			cmp 	#$80 						; if it 10-7F, token
.a206	90 4b		bcc $a253			bcc 	EXTokenExecute
.a208	c9 c0		cmp #$c0			cmp 	#$C0 						; is it a numeric constant 80-BF
.a20a	90 03		bcc $a20f			bcc 	EXPushConstant
.a20c	4c 42 aa	jmp $aa42			jmp 	Identifier 					; it's an identifier C0-FF
.a20f					EXPushConstant:
.a20f	e8		inx				inx 								; make stack space
.a210	29 3f		and #$3f			and 	#$3F 						; to start with, it's just that value
.a212	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a215	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a218	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a21b	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a21e					_EXConstantLoop:
.a21e	b1 00		lda ($00),y			lda 	(codePtr),y 				; look at next ?
.a220	29 c0		and #$c0			and 	#$C0 						; in range 80-FF e.g. 10xx xxxx
.a222	c9 80		cmp #$80			cmp 	#$80
.a224	d0 c9		bne $a1ef			bne		Execute 					; no do the next.
.a226	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; put the MSB in A
.a229	48		pha				pha
.a22a	bd 00 0e	lda $0e00,x			lda 	stack2,x 					; shift every byte up one, e.g. x 256
.a22d	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a230	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a233	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a236	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a239	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a23c	9e 00 0c	stz $0c00,x			stz 	stack0,x
.a23f	68		pla				pla
.a240	20 8b a2	jsr $a28b			jsr 	EXShiftTOSRight 				; shift the whole A:Top of Stack right twice
.a243	20 8b a2	jsr $a28b			jsr 	EXShiftTOSRight				; which will be x64
.a246	b1 00		lda ($00),y			lda 	(codePtr),y 				; get and skip constant shift
.a248	c8		iny				iny
.a249	29 3f		and #$3f			and 	#$3F
.a24b	1d 00 0c	ora $0c00,x			ora 	stack0,x 					; or into low byte
.a24e	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a251	80 cb		bra $a21e			bra 	_EXConstantLoop
.a253					EXTokenExecute:
.a253	0a		asl a				asl 	a 							; double token, also clears carry
.a254	da		phx				phx 								; save X, put token x 2 in X
.a255	aa		tax				tax
.a256	bd 0d a1	lda $a10d,x			lda 	KeywordVectorTable-$20,x 	; copy vector. The -$20 is because the tokens
.a259	85 04		sta $04				sta 	zTemp0 						; start at $10.
.a25b	bd 0e a1	lda $a10e,x			lda 	KeywordVectorTable-$20+1,x
.a25e	85 05		sta $05				sta 	zTemp0+1
.a260	fa		plx				plx 								; restore X
.a261	20 66 a2	jsr $a266			jsr 	_EXTCall 					; call the routine
.a264	80 89		bra $a1ef			bra 	Execute
.a266					_EXTCall:
.a266	6c 04 00	jmp ($0004)			jmp 	(zTemp0)
.a269					EXStringComment:
.a269	c9 02		cmp #$02			cmp 	#$02 						; 02 is the token for single quoted string
.a26b	f0 15		beq $a282			beq 	EXStringSkip 				; (comment), so just skip it.
.a26d	e8		inx				inx 								; push Y + 1 + codePtr on the stack
.a26e	98		tya				tya
.a26f	38		sec				sec
.a270	65 00		adc $00				adc 	codePtr
.a272	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a275	a5 01		lda $01				lda 	codePtr+1
.a277	69 00		adc #$00			adc 	#0
.a279	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a27c	9e 00 0e	stz $0e00,x			stz 	stack2,x 					; clear the upper 2 bytes.
.a27f	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a282					EXStringSkip:
.a282	98		tya				tya 								; the current position in A
.a283	18		clc				clc
.a284	71 00		adc ($00),y			adc 	(codePtr),y					; add the total length
.a286	a8		tay				tay 			 					; and make that the current position.
.a287	88		dey				dey 								; back one because of the initial skip
.a288	4c ef a1	jmp $a1ef			jmp 	Execute
.a28b					EXShiftTOSRight:
.a28b	4a		lsr a				lsr 	a
.a28c	7e 00 0f	ror $0f00,x			ror 	stack3,x
.a28f	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a292	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a295	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a298	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/identifier.asm

.a299					IdentifierSearch:
.a299	b1 00		lda ($00),y			lda 	(codePtr),y 				; get first character
.a29b	c9 e0		cmp #$e0			cmp 	#$E0 						; is it a fast var ?
.a29d	90 12		bcc $a2b1			bcc 	_ISSlow
.a29f	c9 fa		cmp #$fa			cmp 	#$F9+1
.a2a1	b0 0e		bcs $a2b1			bcs 	_ISSlow
.a2a3	29 1f		and #$1f			and 	#$1F 						; index, then x 4
.a2a5	0a		asl a				asl 	a
.a2a6	0a		asl a				asl		a
.a2a7	85 0e		sta $0e				sta 	idDataAddr					; set up addres
.a2a9	a9 10		lda #$10			lda 	#AZVariables >> 8
.a2ab	85 0f		sta $0f				sta 	idDataAddr+1
.a2ad	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; type
.a2af	38		sec				sec 								; return with CS.
.a2b0	60		rts				rts
.a2b1					_ISSlow:
.a2b1	20 65 a3	jsr $a365			jsr 	IdentifierSetupHashPtr 		; set up hash table.
.a2b4	98		tya				tya 								; set (zTemp1) to point to the
.a2b5	18		clc				clc 	 							; identifier to be searched.
.a2b6	65 00		adc $00				adc 	codePtr
.a2b8	85 06		sta $06				sta 	zTemp1
.a2ba	a5 01		lda $01				lda 	codePtr+1
.a2bc	69 00		adc #$00			adc 	#0
.a2be	85 07		sta $07				sta 	zTemp1+1
.a2c0	5a		phy				phy 								; save Y
.a2c1	b2 04		lda ($04)	_ISLoop:lda 	(zTemp0)					; follow link
.a2c3	48		pha				pha
.a2c4	a0 01		ldy #$01			ldy 	#1
.a2c6	b1 04		lda ($04),y			lda 	(zTemp0),y
.a2c8	85 05		sta $05				sta 	zTemp0+1
.a2ca	68		pla				pla
.a2cb	85 04		sta $04				sta 	zTemp0
.a2cd	05 05		ora $05				ora 	zTemp0+1 					; if zero, then fail.
.a2cf	f0 2c		beq $a2fd			beq 	_ISFail
.a2d1	a0 06		ldy #$06			ldy 	#6 							; copy name into zTemp2
.a2d3	b1 04		lda ($04),y			lda 	(zTemp0),y
.a2d5	85 08		sta $08				sta 	zTemp2
.a2d7	c8		iny				iny
.a2d8	b1 04		lda ($04),y			lda 	(zTemp0),y
.a2da	85 09		sta $09				sta 	zTemp2+1
.a2dc	a0 00		ldy #$00			ldy 	#0 							; compare names at zTemp1/zTemp2
.a2de					_ISCompare:
.a2de	b1 06		lda ($06),y			lda 	(zTemp1),y
.a2e0	d1 08		cmp ($08),y			cmp 	(zTemp2),y
.a2e2	d0 dd		bne $a2c1			bne		_ISLoop 					; different ?
.a2e4	c8		iny				iny
.a2e5	c9 e0		cmp #$e0			cmp 	#$E0 						; until end identifiers matched.
.a2e7	90 f5		bcc $a2de			bcc 	_ISCompare
.a2e9	18		clc				clc 								; set up the data pointer
.a2ea	a5 04		lda $04				lda 	zTemp0
.a2ec	69 02		adc #$02			adc 	#2
.a2ee	85 0e		sta $0e				sta 	idDataAddr
.a2f0	a5 05		lda $05				lda 	zTemp0+1
.a2f2	69 00		adc #$00			adc		#0
.a2f4	85 0f		sta $0f				sta 	idDataAddr+1
.a2f6	a0 09		ldy #$09			ldy 	#9 							; get the type
.a2f8	b1 04		lda ($04),y			lda 	(zTemp0),y
.a2fa	7a		ply				ply
.a2fb	38		sec				sec
.a2fc	60		rts				rts
.a2fd					_ISFail:
.a2fd	7a		ply				ply
.a2fe	18		clc				clc
.a2ff	60		rts				rts
.a300					IdentifierCreate:
.a300	5a		phy				phy 								; save Y
.a301	48		pha				pha 								; save type on stack
.a302	20 65 a3	jsr $a365			jsr 	IdentifierSetUpHashPtr 		; zTemp0 = address of table.
.a305	ad 88 10	lda $1088			lda 	VarMemory 					; copy VarMemory to zTemp1
.a308	85 06		sta $06				sta 	zTemp1
.a30a	ad 89 10	lda $1089			lda 	VarMemory+1
.a30d	85 07		sta $07				sta 	zTemp1+1
.a30f	5a		phy				phy 								; save Y (code offset)
.a310	a0 00		ldy #$00			ldy 	#0 							; copy next link in.
.a312	b1 04		lda ($04),y			lda 	(zTemp0),y 					; +0,+1 is the link.
.a314	91 06		sta ($06),y			sta 	(zTemp1),y
.a316	c8		iny				iny
.a317	b1 04		lda ($04),y			lda 	(zTemp0),y
.a319	91 06		sta ($06),y			sta 	(zTemp1),y
.a31b	c8		iny				iny
.a31c					_IDCErase:
.a31c	a9 00		lda #$00			lda 	#0
.a31e	91 06		sta ($06),y			sta 	(zTemp1),y
.a320	c8		iny				iny
.a321	c0 06		cpy #$06			cpy 	#6
.a323	d0 f7		bne $a31c			bne 	_IDCErase
.a325	68		pla				pla 								; original Y
.a326	18		clc				clc
.a327	65 00		adc $00				adc		codePtr 					; address of identifier +6,+7
.a329	91 06		sta ($06),y			sta 	(zTemp1),y
.a32b	c8		iny				iny
.a32c	a5 01		lda $01				lda 	codePtr+1
.a32e	69 00		adc #$00			adc 	#0
.a330	91 06		sta ($06),y			sta 	(zTemp1),y
.a332	c8		iny				iny
.a333	a9 00		lda #$00			lda 	#0 							; +8 bank (0)
.a335	91 06		sta ($06),y			sta 	(zTemp1),y
.a337	68		pla				pla 								; restore type
.a338	c8		iny				iny
.a339	91 06		sta ($06),y			sta 	(zTemp1),y 					; store at +9
.a33b	c8		iny				iny
.a33c	98		tya				tya									; add offset to VarMemory
.a33d	18		clc				clc
.a33e	6d 88 10	adc $1088			adc 	VarMemory
.a341	8d 88 10	sta $1088			sta 	VarMemory
.a344	ad 89 10	lda $1089			lda 	VarMemory+1
.a347	69 00		adc #$00			adc 	#0
.a349	8d 89 10	sta $1089			sta 	VarMemory+1
.a34c	a5 06		lda $06				lda 	zTemp1 						; overwrite hash table entry
.a34e	92 04		sta ($04)			sta 	(zTemp0)
.a350	a0 01		ldy #$01			ldy 	#1
.a352	a5 07		lda $07				lda 	zTemp1+1
.a354	91 04		sta ($04),y			sta 	(zTemp0),y
.a356	a5 06		lda $06				lda 	zTemp1 						; set up idDataAddr
.a358	18		clc				clc
.a359	69 02		adc #$02			adc 	#2
.a35b	85 0e		sta $0e				sta 	idDataAddr
.a35d	a5 07		lda $07				lda 	zTemp1+1
.a35f	69 00		adc #$00			adc 	#0
.a361	85 0f		sta $0f				sta 	idDataAddr+1
.a363	7a		ply				ply 								; restore Y and exit
.a364	60		rts				rts
.a365					IdentifierSetUpHashPtr:
.a365	b1 00		lda ($00),y			lda 	(codePtr),y 				; get the first operator
.a367	29 0f		and #$0f			and 	#(HashTableSize-1)			; convert to a hash index
.a369	0a		asl a				asl 	a 							; convert to an offset, clc
.a36a	69 68		adc #$68			adc 	#(HashTable & $FF)			; set zTemp0 to point to hashTable entry
.a36c	85 04		sta $04				sta 	zTemp0
.a36e	a9 10		lda #$10			lda 	#(HashTable >> 8) 			; assumes table in one page
.a370	85 05		sta $05				sta 	zTemp0+1
.a372	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/reset.asm

.a373					ResetCodePointer:
.a373	48		pha				pha
.a374	a9 11		lda #$11			lda 	#ProgramStart >> 8 			; set up line pointer
.a376	85 01		sta $01				sta 	codePtr+1
.a378	64 00		stz $00				stz 	codePtr
.a37a	a0 03		ldy #$03			ldy 	#3 							; point to first piece of code
.a37c	68		pla				pla
.a37d	60		rts				rts
.a37e					ResetForRun:
.a37e	48		pha				pha
.a37f	5a		phy				phy
.a380	a2 00		ldx #$00			ldx 	#0 							; erase the hash table
.a382					_RRErase:
.a382	9e 68 10	stz $1068,x			stz		HashTable,x
.a385	e8		inx				inx
.a386	e0 20		cpx #$20			cpx 	#HashTableSize * 2
.a388	d0 f8		bne $a382			bne 	_RRErase
.a38a	20 73 a3	jsr $a373			jsr 	ResetCodePointer 			; code Pointer to start of program
.a38d					_RRFindEnd:
.a38d	b2 00		lda ($00)			lda 	(codePtr)					; at end ?
.a38f	f0 0b		beq $a39c			beq 	_RRFoundEnd
.a391	18		clc				clc 								; no, add offset to pointer.
.a392	65 00		adc $00				adc 	codePtr
.a394	85 00		sta $00				sta 	codePtr
.a396	90 f5		bcc $a38d			bcc 	_RRFindEnd
.a398	e6 01		inc $01				inc 	codePtr+1
.a39a	80 f1		bra $a38d			bra 	_RRFindEnd
.a39c					_RRFoundEnd:
.a39c	18		clc				clc 								; add 1 to this, as it points to the last
.a39d	a5 00		lda $00				lda 	codePtr 					; offset, and store in Variable Memory pointer
.a39f	69 01		adc #$01			adc 	#1
.a3a1	8d 88 10	sta $1088			sta 	VarMemory
.a3a4	a5 01		lda $01				lda 	codePtr+1
.a3a6	69 00		adc #$00			adc 	#0
.a3a8	8d 89 10	sta $1089			sta 	VarMemory+1
.a3ab	a9 60		lda #$60			lda 	#MemoryEnd >> 8
.a3ad	8d 8b 10	sta $108b			sta 	AllocMemory+1
.a3b0	9c 8a 10	stz $108a			stz 	AllocMemory
.a3b3	a9 ff		lda #$ff			lda 	#StructureStack & $FF
.a3b5	85 02		sta $02				sta 	StructSP
.a3b7	a9 0b		lda #$0b			lda 	#StructureStack >> 8
.a3b9	85 03		sta $03				sta 	StructSP+1
.a3bb	a9 ff		lda #$ff			lda 	#$FF 						; put a value that will fail structure tests
.a3bd	92 02		sta ($02)			sta 	(StructSP)
.a3bf	20 c7 a3	jsr $a3c7			jsr 	ProcedureScan
.a3c2	a2 00		ldx #$00			ldx 	#0 							; empty the stack
.a3c4	7a		ply				ply
.a3c5	68		pla				pla
.a3c6	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/scan.asm

.a3c7					ProcedureScan:
.a3c7	20 73 a3	jsr $a373			jsr 	ResetCodePointer 			; reset the code pointer.
.a3ca	b2 00		lda ($00)	_PSMain:lda 	(codePtr)					; check if end
.a3cc	f0 3c		beq $a40a			beq 	_PSExit
.a3ce	a0 03		ldy #$03			ldy 	#3 							; start of line
.a3d0					_PSSkipSpace:
.a3d0	b1 00		lda ($00),y			lda 	(codePtr),y 				; skip over spaces
.a3d2	c8		iny				iny
.a3d3	c9 10		cmp #$10			cmp 	#KWD_SPACE
.a3d5	f0 f9		beq $a3d0			beq 	_PSSkipSpace
.a3d7	c9 29		cmp #$29			cmp 	#KWD_DEF 					; first thing is DEF ?
.a3d9	d0 22		bne $a3fd			bne 	_PSNext
.a3db					_PSSkipSpace2:
.a3db	c8		iny				iny 								; skip over def first, any following spaces
.a3dc	b1 00		lda ($00),y			lda 	(codePtr),y
.a3de	c9 10		cmp #$10			cmp 	#KWD_SPACE
.a3e0	f0 f9		beq $a3db			beq 	_PSSkipSpace2
.a3e2	a9 50		lda #$50			lda 	#IDT_PROCEDURE 				; create a procedure
.a3e4	20 00 a3	jsr $a300			jsr 	IdentifierCreate
.a3e7					_PSSkipIdentifier:
.a3e7	b1 00		lda ($00),y			lda 	(codePtr),y
.a3e9	c8		iny				iny
.a3ea	c9 c0		cmp #$c0			cmp 	#$C0
.a3ec	b0 f9		bcs $a3e7			bcs 	_PSSkipIdentifier
.a3ee	88		dey				dey 								; undo last, points at first non ID
.a3ef	98		tya				tya  								; save the address in the data slot.
.a3f0	18		clc				clc 								; changing Y doesn't matter.
.a3f1	65 00		adc $00				adc 	codePtr
.a3f3	92 0e		sta ($0e)			sta 	(idDataAddr)
.a3f5	a5 01		lda $01				lda 	codePtr+1
.a3f7	69 00		adc #$00			adc 	#0
.a3f9	a0 01		ldy #$01			ldy 	#1
.a3fb	91 0e		sta ($0e),y			sta 	(idDataAddr),y
.a3fd					_PSNext:
.a3fd	18		clc				clc 								; go to next
.a3fe	b2 00		lda ($00)			lda 	(codePtr)
.a400	65 00		adc $00				adc 	codePtr
.a402	85 00		sta $00				sta 	codeptr
.a404	90 c4		bcc $a3ca			bcc 	_PSMain
.a406	e6 01		inc $01				inc 	codePtr+1
.a408	80 c0		bra $a3ca			bra 	_PSMain
.a40a					_PSExit:
.a40a	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/indexing.asm

.a40b					IndexCheck:
.a40b	b1 00		lda ($00),y			lda 	(codePtr),y 				; check next character
.a40d	c9 46		cmp #$46			cmp 	#KWD_LSQPARENRSQPAREN 		; left/right square bracket ?
.a40f	f0 12		beq $a423			beq 	_ICArrayAccess
.a411	29 c0		and #$c0			and 	#$C0 						; constant (e.g. 10xx xxxx)
.a413	c9 80		cmp #$80			cmp 	#$80
.a415	b0 01		bcs $a418			bcs 	_ICSubscript
.a417					_ICExit:
.a417	60		rts				rts
.a418					_ICSubscript:
.a418	b1 00		lda ($00),y			lda 	(codePtr),y
.a41a	c8		iny				iny 								; skip over subscript
.a41b	29 3f		and #$3f			and 	#$3F 						; lower 6 bits only.
.a41d	85 06		sta $06				sta 	zTemp1 						; save in zTemp1
.a41f	64 07		stz $07				stz 	zTemp1+1
.a421	80 0c		bra $a42f			bra 	_ICAddSubscript 			; double and add to value.
.a423					_ICArrayAccess:
.a423	c8		iny				iny 								; point to next
.a424	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy TOS to zTemp1
.a427	85 07		sta $07				sta 	zTemp1+1 					; no point in the rest !
.a429	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a42c	85 06		sta $06				sta 	zTemp1
.a42e	ca		dex				dex
.a42f					_ICAddSubscript:
.a42f	06 06		asl $06				asl 	zTemp1 						; subscript x 4
.a431	26 07		rol $07				rol 	zTemp1+1
.a433	06 06		asl $06				asl 	zTemp1
.a435	26 07		rol $07				rol 	zTemp1+1
.a437	5a		phy				phy
.a438	b2 0e		lda ($0e)			lda 	(idDataAddr)				; check indirecting through 0
.a43a	a0 01		ldy #$01			ldy 	#1
.a43c	11 0e		ora ($0e),y			ora 	(idDataAddr),y 				; probably means uninitialised
.a43e	c8		iny				iny
.a43f	11 0e		ora ($0e),y			ora 	(idDataAddr),y
.a441	c8		iny				iny
.a442	11 0e		ora ($0e),y			ora 	(idDataAddr),y
.a444	f0 17		beq $a45d			beq 	_ICZero
.a446	18		clc				clc									; add zTemp1 to value at (idDataAddr)
.a447	b2 0e		lda ($0e)			lda 	(idDataAddr)
.a449	65 06		adc $06				adc 	zTemp1
.a44b	48		pha				pha
.a44c	a0 01		ldy #$01			ldy 	#1
.a44e	b1 0e		lda ($0e),y			lda 	(idDataAddr),y
.a450	65 07		adc $07				adc 	zTemp1+1
.a452	85 0f		sta $0f				sta 	idDataAddr+1 				; write it out
.a454	68		pla				pla
.a455	85 0e		sta $0e				sta 	idDataAddr
.a457	64 10		stz $10				stz 	idDataAddr+2 				; extend to 32 bits
.a459	64 11		stz $11				stz 	idDataAddr+3
.a45b	7a		ply				ply
.a45c	60		rts				rts
.a45d					_ICZero:
.a45d	20 84 a4	jsr $a484			jsr 	ErrorHandler
>a460	55 4e 49 4e 49 54 49 41				.text 	"UNINITIALISED ARRAY",0
>a468	4c 49 53 45 44 20 41 52 52 41 59 00

;******  Return to file: main.asm


;******  Processing file: system/error.asm

.a474					SyntaxError:
.a474	20 84 a4	jsr $a484			jsr 	ErrorHandler
>a477	53 59 4e 54 41 58 20 45				.text 	"SYNTAX ERROR",0
>a47f	52 52 4f 52 00
.a484					ErrorHandler:
.a484	68		pla				pla 								; pop message address
.a485	85 04		sta $04				sta 	zTemp0
.a487	68		pla				pla
.a488	85 05		sta $05				sta 	zTemp0+1
.a48a	a9 05		lda #$05			lda 	#CTH_ERROR
.a48c	20 c5 a1	jsr $a1c5			jsr 	ExternColour
.a48f	a0 01		ldy #$01			ldy 	#1 							; print it
.a491					_ErrorPrint:
.a491	b1 04		lda ($04),y			lda 	(zTemp0),y
.a493	20 bb a1	jsr $a1bb			jsr		ExternPrint
.a496	c8		iny				iny
.a497	b1 04		lda ($04),y			lda 	(zTemp0),y
.a499	d0 f6		bne $a491			bne 	_ErrorPrint
.a49b	a0 01		ldy #$01			ldy 	#1 							; check if line# 0
.a49d	b1 00		lda ($00),y			lda		(codePtr),y
.a49f	c8		iny				iny
.a4a0	12 00		ora ($00)			ora 	(codePtr)
.a4a2	f0 1c		beq $a4c0			beq 	_ErrorNoLine 				; if so, skip
.a4a4	a9 20		lda #$20			lda 	#32
.a4a6	20 bb a1	jsr $a1bb			jsr 	ExternPrint
.a4a9	a9 40		lda #$40			lda 	#'@'
.a4ab	20 bb a1	jsr $a1bb			jsr 	ExternPrint
.a4ae	a9 20		lda #$20			lda 	#32
.a4b0	20 bb a1	jsr $a1bb			jsr 	ExternPrint
.a4b3	a0 01		ldy #$01			ldy 	#1 							; load current line into YA
.a4b5	b1 00		lda ($00),y			lda 	(codePtr),y
.a4b7	48		pha				pha
.a4b8	c8		iny				iny
.a4b9	b1 00		lda ($00),y			lda 	(codePtr),y
.a4bb	a8		tay				tay
.a4bc	68		pla				pla
.a4bd	20 cc a4	jsr $a4cc			jsr 	ErrorPrint16 				; print YA as unsigned 16 bit integer.
.a4c0					_ErrorNoLine:
.a4c0	a9 0d		lda #$0d			lda 	#13							; new line
.a4c2	20 bb a1	jsr $a1bb			jsr 	ExternPrint
.a4c5	4c c8 a4	jmp $a4c8			jmp 	WarmStart
.a4c8					WarmStart:
.a4c8	4c c8 a4	jmp $a4c8			jmp		WarmStart
>a4cb	ff						.byte 	$FF
.a4cc					ErrorPrint16:
.a4cc	da		phx				phx
.a4cd	e8		inx				inx 								; space on stack
.a4ce	9d 00 0c	sta $0c00,x			sta 	stack0,x					; save on TOS
.a4d1	98		tya				tya
.a4d2	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a4d5	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a4d8	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a4db	20 ee a4	jsr $a4ee			jsr 	IntegerToString 			; convert to string.
.a4de	a2 00		ldx #$00			ldx 	#0
.a4e0					_EP16Loop:
.a4e0	bd 00 0a	lda $0a00,x			lda 	SBuffer,x
.a4e3	20 bb a1	jsr $a1bb			jsr 	ExternPrint
.a4e6	e8		inx				inx
.a4e7	bd 00 0a	lda $0a00,x			lda 	SBuffer,x
.a4ea	d0 f4		bne $a4e0			bne 	_EP16Loop
.a4ec	fa		plx				plx
.a4ed	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: system/inttostr.asm

.a4ee					IntegerToString:
.a4ee	48		pha				pha
.a4ef	5a		phy				phy
.a4f0	bd 00 0f	lda $0f00,x			lda 		stack3,x 				; check -ve
.a4f3	10 08		bpl $a4fd			bpl 		_ITSNotMinus
.a4f5	a9 2d		lda #$2d			lda 		#"-"
.a4f7	20 8f a5	jsr $a58f			jsr 		ITSOutputCharacter
.a4fa	20 34 a6	jsr $a634			jsr 		Unary_Negate
.a4fd					_ITSNotMinus:
.a4fd	9c 20 0a	stz $0a20			stz 		SBPosition 				; reset string buffer position
.a500	9c 24 0a	stz $0a24			stz 		NumSuppress 			; clear zero suppression flag
.a503	8a		txa				txa 								; use Y for the integer index.
.a504	a8		tay				tay
.a505	a2 00		ldx #$00			ldx 		#0 						; X is index into dword subtraction table.
.a507					_ITSNextSubtractor:
.a507	a9 30		lda #$30			lda 		#"0" 					; count of subtractions count in ASCII.
.a509	8d 21 0a	sta $0a21			sta 		NumConvCount
.a50c					_ITSSubtract:
.a50c	38		sec				sec
.a50d	b9 00 0c	lda $0c00,y			lda 		stack0,y 			; subtract number and push on stack
.a510	fd 6b a5	sbc $a56b,x			sbc 		_ITSSubtractors+0,x 	; only update if actually can subtract it.
.a513	48		pha				pha
.a514	b9 00 0d	lda $0d00,y			lda 		stack1,y
.a517	fd 6c a5	sbc $a56c,x			sbc 		_ITSSubtractors+1,x
.a51a	48		pha				pha
.a51b	b9 00 0e	lda $0e00,y			lda 		stack2,y
.a51e	fd 6d a5	sbc $a56d,x			sbc 		_ITSSubtractors+2,x
.a521	48		pha				pha
.a522	b9 00 0f	lda $0f00,y			lda 		stack3,y
.a525	fd 6e a5	sbc $a56e,x			sbc 		_ITSSubtractors+3,x
.a528	90 14		bcc $a53e			bcc 		_ITSCantSubtract 		; if CC, then gone too far, can't subtract
.a52a	99 00 0f	sta $0f00,y			sta 		stack3,y 		; save subtract off stack as it's okay
.a52d	68		pla				pla
.a52e	99 00 0e	sta $0e00,y			sta 		stack2,y
.a531	68		pla				pla
.a532	99 00 0d	sta $0d00,y			sta 		stack1,y
.a535	68		pla				pla
.a536	99 00 0c	sta $0c00,y			sta 		stack0,y
.a539	ee 21 0a	inc $0a21			inc 		NumConvCount 			; bump count.
.a53c	80 ce		bra $a50c			bra 		_ITSSubtract 			; go round again.
.a53e					_ITSCantSubtract:
.a53e	68		pla				pla 								; throw away interim answers
.a53f	68		pla				pla 								; (the subtraction that failed)
.a540	68		pla				pla
.a541	ad 21 0a	lda $0a21			lda 		NumConvCount 			; if not zero then no suppression check
.a544	c9 30		cmp #$30			cmp 		#"0"
.a546	d0 05		bne $a54d			bne 		_ITSOutputDigit
.a548	ad 24 0a	lda $0a24			lda 		NumSuppress 			; if suppression check zero, then don't print it.
.a54b	f0 09		beq $a556			beq	 		_ITSGoNextSubtractor
.a54d					_ITSOutputDigit:
.a54d	ce 24 0a	dec $0a24			dec 		NumSuppress 			; suppression check will be non-zero from now on.
.a550	ad 21 0a	lda $0a21			lda 		NumConvCount 			; count of subtractions
.a553	20 8f a5	jsr $a58f			jsr 		ITSOutputCharacter 		; output it.
.a556					_ITSGoNextSubtractor:
.a556	e8		inx				inx 								; next dword in subtractor table.
.a557	e8		inx				inx
.a558	e8		inx				inx
.a559	e8		inx				inx
.a55a	e0 24		cpx #$24			cpx 		#_ITSSubtractorsEnd-_ITSSubtractors
.a55c	d0 a9		bne $a507			bne 		_ITSNextSubtractor 		; do all the subtractors.
.a55e	98		tya				tya 								; X is back as the mantissa index
.a55f	aa		tax				tax
.a560	bd 00 0c	lda $0c00,x			lda 		stack0,x 		; and the last digit is left.
.a563	09 30		ora #$30			ora 		#"0"
.a565	20 8f a5	jsr $a58f			jsr 		ITSOutputCharacter
.a568	7a		ply				ply 								; and exit
.a569	68		pla				pla
.a56a	60		rts				rts
.a56b					_ITSSubtractors:
>a56b	00 ca 9a 3b					.dword 		1000000000
>a56f	00 e1 f5 05					.dword 		100000000
>a573	80 96 98 00					.dword 		10000000
>a577	40 42 0f 00					.dword 		1000000
>a57b	a0 86 01 00					.dword 		100000
>a57f	10 27 00 00					.dword 		10000
>a583	e8 03 00 00					.dword 		1000
>a587	64 00 00 00					.dword 		100
>a58b	0a 00 00 00					.dword 		10
.a58f					_ITSSubtractorsEnd:
.a58f					ITSOutputCharacter:
.a58f	48		pha				pha
.a590	da		phx				phx
.a591	ae 20 0a	ldx $0a20			ldx 	SBPosition 					; save digit
.a594	9d 00 0a	sta $0a00,x			sta 	SBuffer,x
.a597	9e 01 0a	stz $0a01,x			stz 	SBuffer+1,x
.a59a	ee 20 0a	inc $0a20			inc 	SBPosition					; bump pointer.
.a59d	fa		plx				plx
.a59e	68		pla				pla
.a59f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/stack.asm

.a5a0					Stack_Empty:
.a5a0	a2 00		ldx #$00			ldx 	#0
.a5a2	60		rts				rts
.a5a3					Stack_Drop:
.a5a3	ca		dex				dex
.a5a4	60		rts				rts
.a5a5					Stack_Dup:
.a5a5	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy to next up
.a5a8	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.a5ab	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a5ae	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.a5b1	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a5b4	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.a5b7	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a5ba	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.a5bd	e8		inx				inx 								; bump stack pointer
.a5be	60		rts				rts
.a5bf					Stack_Nip:
.a5bf	bd 00 0c	lda $0c00,x			lda 	stack0,x	 				; copy top to 2nd
.a5c2	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.a5c5	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a5c8	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.a5cb	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a5ce	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.a5d1	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a5d4	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.a5d7	ca		dex				dex 								; drop tos
.a5d8	60		rts				rts
.a5d9					Stack_Over:
.a5d9	bd ff 0b	lda $0bff,x			lda 	stack0-1,x				; copy to next up
.a5dc	9d 01 0c	sta $0c01,x			sta 	stack0+1,x
.a5df	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a5e2	9d 01 0d	sta $0d01,x			sta 	stack1+1,x
.a5e5	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a5e8	9d 01 0e	sta $0e01,x			sta 	stack2+1,x
.a5eb	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a5ee	9d 01 0f	sta $0f01,x			sta 	stack3+1,x
.a5f1	e8		inx				inx 							; bump stack pointer
.a5f2	60		rts				rts
.a5f3					Stack_Swap:
.a5f3	5a		phy				phy
.a5f4	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a5f7	a8		tay				tay
.a5f8	bd ff 0b	lda $0bff,x			lda 	stack0-1,x
.a5fb	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a5fe	98		tya				tya
.a5ff	9d ff 0b	sta $0bff,x			sta 	stack0-1,x
.a602	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a605	a8		tay				tay
.a606	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a609	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a60c	98		tya				tya
.a60d	9d ff 0c	sta $0cff,x			sta 	stack1-1,x
.a610	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a613	a8		tay				tay
.a614	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a617	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a61a	98		tya				tya
.a61b	9d ff 0d	sta $0dff,x			sta 	stack2-1,x
.a61e	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a621	a8		tay				tay
.a622	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a625	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a628	98		tya				tya
.a629	9d ff 0e	sta $0eff,x			sta 	stack3-1,x
.a62c	7a		ply				ply
.a62d	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/unary.asm

.a62e					Unary_Absolute:
.a62e	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a631	30 01		bmi $a634			bmi 	Unary_Negate
.a633	60		rts				rts
.a634					Unary_Negate:
.a634					Unary_Const_Minus:
.a634	38		sec				sec
.a635	a9 00		lda #$00			lda		#0
.a637	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.a63a	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a63d	a9 00		lda #$00			lda		#0
.a63f	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.a642	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a645	a9 00		lda #$00			lda		#0
.a647	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.a64a	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a64d	a9 00		lda #$00			lda		#0
.a64f	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.a652	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a655	60		rts				rts
.a656					Unary_Not:
.a656	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a659	49 ff		eor #$ff			eor 	#$FF
.a65b	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a65e	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a661	49 ff		eor #$ff			eor 	#$FF
.a663	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a666	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a669	49 ff		eor #$ff			eor 	#$FF
.a66b	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a66e	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a671	49 ff		eor #$ff			eor 	#$FF
.a673	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a676	60		rts				rts
.a677					Unary_Increment:
.a677	fe 00 0c	inc $0c00,x			inc 	stack0,x
.a67a	d0 0d		bne $a689			bne 	_UIExit
.a67c	fe 00 0d	inc $0d00,x			inc 	stack1,x
.a67f	d0 08		bne $a689			bne 	_UIExit
.a681	fe 00 0e	inc $0e00,x			inc 	stack2,x
.a684	d0 03		bne $a689			bne 	_UIExit
.a686	fe 00 0f	inc $0f00,x			inc 	stack3,x
.a689					_UIExit:
.a689	60		rts				rts
.a68a					Unary_Decrement:
.a68a	38		sec				sec
.a68b	bd 00 0c	lda $0c00,x			lda 	stack0,x
.a68e	e9 01		sbc #$01			sbc 	#1
.a690	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a693	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a696	e9 00		sbc #$00			sbc 	#0
.a698	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a69b	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a69e	e9 00		sbc #$00			sbc 	#0
.a6a0	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a6a3	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a6a6	e9 00		sbc #$00			sbc 	#0
.a6a8	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a6ab	60		rts				rts
.a6ac					Unary_Shl:
.a6ac	1e 00 0c	asl $0c00,x			asl 	stack0,x
.a6af	3e 00 0d	rol $0d00,x			rol 	stack1,x
.a6b2	3e 00 0e	rol $0e00,x			rol 	stack2,x
.a6b5	3e 00 0f	rol $0f00,x			rol 	stack3,x
.a6b8	60		rts				rts
.a6b9					Unary_Shr:
.a6b9	5e 00 0f	lsr $0f00,x			lsr 	stack3,x
.a6bc	7e 00 0e	ror $0e00,x			ror 	stack2,x
.a6bf	7e 00 0d	ror $0d00,x			ror 	stack1,x
.a6c2	7e 00 0c	ror $0c00,x			ror 	stack0,x
.a6c5	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/memory.asm

.a6c6					Mem_Peek:
.a6c6	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a6c9	85 04		sta $04				sta 	zTemp0
.a6cb	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a6ce	85 05		sta $05				sta 	zTemp0+1
.a6d0	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a6d2	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a6d5	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a6d8	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a6db	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a6de	60		rts				rts
.a6df					Mem_WPeek:
.a6df	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a6e2	85 04		sta $04				sta 	zTemp0
.a6e4	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a6e7	85 05		sta $05				sta 	zTemp0+1
.a6e9	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a6eb	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a6ee	5a		phy				phy 								; read msb
.a6ef	a0 01		ldy #$01			ldy 	#1
.a6f1	b1 04		lda ($04),y			lda 	(zTemp0),y
.a6f3	7a		ply				ply
.a6f4	9d 00 0d	sta $0d00,x			sta 	stack1,x 				; write to stack
.a6f7	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a6fa	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a6fd	60		rts				rts
.a6fe					Mem_DPeek:
.a6fe	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a701	85 04		sta $04				sta 	zTemp0
.a703	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a706	85 05		sta $05				sta 	zTemp0+1
.a708	b2 04		lda ($04)			lda 	(zTemp0)					; read byte
.a70a	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; write to stack
.a70d	5a		phy				phy 								; read msb
.a70e	a0 01		ldy #$01			ldy 	#1
.a710	b1 04		lda ($04),y			lda 	(zTemp0),y
.a712	9d 00 0d	sta $0d00,x			sta 	stack1,x 					; write to stack
.a715	c8		iny				iny
.a716	b1 04		lda ($04),y			lda 	(zTemp0),y
.a718	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a71b	c8		iny				iny
.a71c	b1 04		lda ($04),y			lda 	(zTemp0),y
.a71e	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a721	7a		ply				ply
.a722	60		rts				rts
.a723					Mem_Poke:
.a723	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a726	85 04		sta $04				sta 	zTemp0
.a728	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a72b	85 05		sta $05				sta 	zTemp0+1
.a72d	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.a730	92 04		sta ($04)			sta 	(zTemp0)
.a732	ca		dex				dex
.a733	ca		dex				dex
.a734	60		rts				rts
.a735					Mem_WPoke:
.a735	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a738	85 04		sta $04				sta 	zTemp0
.a73a	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a73d	85 05		sta $05				sta 	zTemp0+1
.a73f	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 				; byte to write
.a742	92 04		sta ($04)			sta 	(zTemp0)
.a744	5a		phy				phy
.a745	a0 01		ldy #$01			ldy 	#1
.a747	bd ff 0e	lda $0eff,x			lda 	stack3-1,x 				; byte to write
.a74a	91 04		sta ($04),y			sta 	(zTemp0),y
.a74c	7a		ply				ply
.a74d	ca		dex				dex
.a74e	ca		dex				dex
.a74f	60		rts				rts
.a750					Mem_DPoke:
.a750	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy address
.a753	85 04		sta $04				sta 	zTemp0
.a755	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a758	85 05		sta $05				sta 	zTemp0+1
.a75a	bd ff 0b	lda $0bff,x			lda 	stack0-1,x 					; byte to write
.a75d	92 04		sta ($04)			sta 	(zTemp0)
.a75f	5a		phy				phy
.a760	a0 01		ldy #$01			ldy 	#1
.a762	bd ff 0c	lda $0cff,x			lda 	stack1-1,x
.a765	91 04		sta ($04),y			sta 	(zTemp0),y
.a767	bd ff 0d	lda $0dff,x			lda 	stack2-1,x
.a76a	c8		iny				iny
.a76b	91 04		sta ($04),y			sta 	(zTemp0),y
.a76d	bd ff 0e	lda $0eff,x			lda 	stack3-1,x
.a770	c8		iny				iny
.a771	91 04		sta ($04),y			sta 	(zTemp0),y
.a773	7a		ply				ply
.a774	ca		dex				dex
.a775	ca		dex				dex
.a776	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/binary.asm

.a777					Stack_Add:
.a777	ca		dex				dex
.a778					Stack_Add_No_Dex:
.a778	18		clc				clc
.a779	bd 00 0c	lda $0c00,x			lda		stack0,x
.a77c	7d 01 0c	adc $0c01,x			adc 	stack0+1,x
.a77f	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a782	bd 00 0d	lda $0d00,x			lda		stack1,x
.a785	7d 01 0d	adc $0d01,x			adc 	stack1+1,x
.a788	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a78b	bd 00 0e	lda $0e00,x			lda		stack2,x
.a78e	7d 01 0e	adc $0e01,x			adc 	stack2+1,x
.a791	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a794	bd 00 0f	lda $0f00,x			lda		stack3,x
.a797	7d 01 0f	adc $0f01,x			adc 	stack3+1,x
.a79a	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a79d	60		rts				rts
.a79e					Stack_Sub:
.a79e	ca		dex				dex
.a79f	38		sec				sec
.a7a0	bd 00 0c	lda $0c00,x			lda		stack0,x
.a7a3	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.a7a6	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a7a9	bd 00 0d	lda $0d00,x			lda		stack1,x
.a7ac	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.a7af	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a7b2	bd 00 0e	lda $0e00,x			lda		stack2,x
.a7b5	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.a7b8	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a7bb	bd 00 0f	lda $0f00,x			lda		stack3,x
.a7be	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.a7c1	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a7c4	60		rts				rts
.a7c5					Stack_And:
.a7c5	ca		dex				dex
.a7c6	bd 00 0c	lda $0c00,x			lda		stack0,x
.a7c9	3d 01 0c	and $0c01,x			and		stack0+1,x
.a7cc	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a7cf	bd 00 0d	lda $0d00,x			lda		stack1,x
.a7d2	3d 01 0d	and $0d01,x			and 	stack1+1,x
.a7d5	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a7d8	bd 00 0e	lda $0e00,x			lda		stack2,x
.a7db	3d 01 0e	and $0e01,x			and 	stack2+1,x
.a7de	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a7e1	bd 00 0f	lda $0f00,x			lda		stack3,x
.a7e4	3d 01 0f	and $0f01,x			and 	stack3+1,x
.a7e7	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a7ea	60		rts				rts
.a7eb					Stack_Xor:
.a7eb	ca		dex				dex
.a7ec	bd 00 0c	lda $0c00,x			lda		stack0,x
.a7ef	5d 01 0c	eor $0c01,x			eor		stack0+1,x
.a7f2	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a7f5	bd 00 0d	lda $0d00,x			lda		stack1,x
.a7f8	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.a7fb	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a7fe	bd 00 0e	lda $0e00,x			lda		stack2,x
.a801	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.a804	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a807	bd 00 0f	lda $0f00,x			lda		stack3,x
.a80a	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.a80d	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a810	60		rts				rts
.a811					Stack_Or:
.a811	ca		dex				dex
.a812	bd 00 0c	lda $0c00,x			lda		stack0,x
.a815	1d 01 0c	ora $0c01,x			ora		stack0+1,x
.a818	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a81b	bd 00 0d	lda $0d00,x			lda		stack1,x
.a81e	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.a821	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a824	bd 00 0e	lda $0e00,x			lda		stack2,x
.a827	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.a82a	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a82d	bd 00 0f	lda $0f00,x			lda		stack3,x
.a830	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.a833	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a836	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/multiply.asm

.a837					MulInteger32:
.a837	ca		dex				dex
.a838	bd 00 0c	lda $0c00,x			lda 	stack0,x					; copy +0 to workspace
.a83b	85 0a		sta $0a				sta 	zLTemp1
.a83d	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a840	85 0b		sta $0b				sta 	zLTemp1+1
.a842	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a845	85 0c		sta $0c				sta 	zLTemp1+2
.a847	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a84a	85 0d		sta $0d				sta 	zLTemp1+3
.a84c	9e 00 0c	stz $0c00,x			stz 	stack0,x 					; zero +0, where the result goes.
.a84f	9e 00 0d	stz $0d00,x			stz 	stack1,x
.a852	9e 00 0e	stz $0e00,x			stz 	stack2,x
.a855	9e 00 0f	stz $0f00,x			stz 	stack3,x
.a858					_BFMMultiply:
.a858	a5 0a		lda $0a				lda 	zLTemp1 					; get LSBit of 8-11
.a85a	29 01		and #$01			and 	#1
.a85c	f0 03		beq $a861			beq 	_BFMNoAdd
.a85e	20 78 a7	jsr $a778			jsr 	Stack_Add_No_Dex 			; co-opt this code
.a861					_BFMNoAdd:
.a861	1e 01 0c	asl $0c01,x			asl 	stack0+1,x 					; shift +4 left
.a864	3e 01 0d	rol $0d01,x			rol 	stack1+1,x
.a867	3e 01 0e	rol $0e01,x			rol 	stack2+1,x
.a86a	3e 01 0f	rol $0f01,x			rol 	stack3+1,x
.a86d	46 0d		lsr $0d				lsr 	zLTemp1+3 					; shift +8 right
.a86f	66 0c		ror $0c				ror 	zLTemp1+2
.a871	66 0b		ror $0b				ror 	zLTemp1+1
.a873	66 0a		ror $0a				ror 	zLTemp1
.a875	a5 0a		lda $0a				lda 	zLTemp1 					; continue if +8 is nonzero
.a877	05 0b		ora $0b				ora 	zLTemp1+1
.a879	05 0c		ora $0c				ora 	zLTemp1+2
.a87b	05 0d		ora $0d				ora 	zLTemp1+3
.a87d	d0 d9		bne $a858			bne 	_BFMMultiply
.a87f	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/divide.asm

.a880					DivInteger32:
.a880	ca		dex				dex
.a881	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; check for division by zero.
.a884	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.a887	1d 01 0e	ora $0e01,x			ora 	stack2+1,x
.a88a	1d 01 0f	ora $0f01,x			ora 	stack3+1,x
.a88d	d0 14		bne $a8a3			bne 	_BFDOkay
.a88f	20 84 a4	jsr $a484			jsr 	ErrorHandler
>a892	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",0
>a89a	20 42 59 20 5a 45 52 4f 00
.a8a3					_BFDOkay:
.a8a3	64 0a		stz $0a				stz 	zLTemp1 					; Q/Dividend/Left in +0
.a8a5	64 0b		stz $0b				stz 	zLTemp1+1 					; M/Divisor/Right in +4
.a8a7	64 0c		stz $0c				stz 	zLTemp1+2
.a8a9	64 0d		stz $0d				stz 	zLTemp1+3
.a8ab	9c 23 0a	stz $0a23			stz 	SignCount 					; Count of signs.
.a8ae	20 09 a9	jsr $a909			jsr 	CheckIntegerNegate 			; negate (and bump sign count)
.a8b1	e8		inx				inx
.a8b2	20 09 a9	jsr $a909			jsr 	CheckIntegerNegate
.a8b5	ca		dex				dex
.a8b6	5a		phy				phy 								; Y is the counter
.a8b7	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.a8b9					_BFDLoop:
.a8b9	1e 00 0c	asl $0c00,x			asl 	stack0,x 					; shift AQ left.
.a8bc	3e 00 0d	rol $0d00,x			rol 	stack1,x
.a8bf	3e 00 0e	rol $0e00,x			rol 	stack2,x
.a8c2	3e 00 0f	rol $0f00,x			rol 	stack3,x
.a8c5	26 0a		rol $0a				rol 	zLTemp1
.a8c7	26 0b		rol $0b				rol 	zLTemp1+1
.a8c9	26 0c		rol $0c				rol 	zLTemp1+2
.a8cb	26 0d		rol $0d				rol 	zLTemp1+3
.a8cd	38		sec				sec
.a8ce	a5 0a		lda $0a				lda 	zLTemp1+0 					; Calculate A-M on stack.
.a8d0	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.a8d3	48		pha				pha
.a8d4	a5 0b		lda $0b				lda 	zLTemp1+1
.a8d6	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.a8d9	48		pha				pha
.a8da	a5 0c		lda $0c				lda 	zLTemp1+2
.a8dc	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.a8df	48		pha				pha
.a8e0	a5 0d		lda $0d				lda 	zLTemp1+3
.a8e2	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.a8e5	90 15		bcc $a8fc			bcc 	_BFDNoAdd
.a8e7	85 0d		sta $0d				sta 	zLTemp1+3 					; update A
.a8e9	68		pla				pla
.a8ea	85 0c		sta $0c				sta 	zLTemp1+2
.a8ec	68		pla				pla
.a8ed	85 0b		sta $0b				sta 	zLTemp1+1
.a8ef	68		pla				pla
.a8f0	85 0a		sta $0a				sta 	zLTemp1+0
.a8f2	bd 00 0c	lda $0c00,x			lda 	stack0,x 			; set Q bit 1.
.a8f5	09 01		ora #$01			ora 	#1
.a8f7	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a8fa	80 03		bra $a8ff			bra 	_BFDNext
.a8fc					_BFDNoAdd:
.a8fc	68		pla				pla 								; Throw away the intermediate calculations
.a8fd	68		pla				pla
.a8fe	68		pla				pla
.a8ff					_BFDNext:
.a8ff	88		dey				dey
.a900	d0 b7		bne $a8b9			bne 	_BFDLoop
.a902	7a		ply				ply 								; restore Y
.a903	4e 23 0a	lsr $0a23			lsr 	SignCount 					; if sign count odd,
.a906	b0 07		bcs $a90f			bcs		IntegerNegateAlways 		; negate the result
.a908	60		rts				rts
.a909					CheckIntegerNegate:
.a909	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; is it -ve = MSB set ?
.a90c	30 01		bmi $a90f			bmi 	IntegerNegateAlways 		; if so negate it
.a90e	60		rts				rts
.a90f					IntegerNegateAlways:
.a90f	ee 23 0a	inc $0a23			inc 	SignCount 					; bump the count of signs
.a912	4c 34 a6	jmp $a634			jmp 	Unary_Negate
.a915					ModInteger32:
.a915	20 80 a8	jsr $a880			jsr 	DivInteger32
.a918	a5 0a		lda $0a				lda 	zLTemp1
.a91a	9d 00 0c	sta $0c00,x			sta 	stack0,x
.a91d	a5 0b		lda $0b				lda 	zLTemp1+1
.a91f	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a922	a5 0c		lda $0c				lda 	zLTemp1+2
.a924	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a927	a5 0d		lda $0d				lda 	zLTemp1+3
.a929	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a92c	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: functions/compare.asm

.a92d					Comp_Equal:
.a92d	38		sec				sec
.a92e	80 01		bra $a931			bra 	Comp_CheckEqual
.a930					Comp_NotEqual:
.a930	18		clc				clc
.a931					Comp_CheckEqual:
.a931	08		php				php
.a932	ca		dex				dex
.a933	bd 00 0c	lda $0c00,x			lda		stack0,x
.a936	5d 01 0c	eor $0c01,x			eor 	stack0+1,x
.a939	d0 16		bne $a951			bne 	_CCENonZero
.a93b	bd 00 0d	lda $0d00,x			lda		stack1,x
.a93e	5d 01 0d	eor $0d01,x			eor 	stack1+1,x
.a941	d0 0e		bne $a951			bne 	_CCENonZero
.a943	bd 00 0e	lda $0e00,x			lda		stack2,x
.a946	5d 01 0e	eor $0e01,x			eor 	stack2+1,x
.a949	d0 06		bne $a951			bne 	_CCENonZero
.a94b	bd 00 0f	lda $0f00,x			lda		stack3,x
.a94e	5d 01 0f	eor $0f01,x			eor 	stack3+1,x
.a951					_CCENonZero:
.a951	f0 02		beq $a955			beq 	_CCENotSet
.a953	a9 ff		lda #$ff			lda 	#$FF 						; $FF if not-equal
.a955					_CCENotSet:
.a955					CompCheckFlip:
.a955	28		plp				plp 								; if carry set, we want $FF if equal
.a956	90 02		bcc $a95a			bcc 	CompReturn
.a958	49 ff		eor #$ff			eor 	#$FF
.a95a					CompReturn:
.a95a	9d 00 0c	sta $0c00,x			sta 	stack0,x 					; save result on stack.
.a95d	9d 00 0d	sta $0d00,x			sta 	stack1,x
.a960	9d 00 0e	sta $0e00,x			sta 	stack2,x
.a963	9d 00 0f	sta $0f00,x			sta 	stack3,x
.a966	60		rts				rts
.a967					Comp_Less:
.a967	18		clc				clc
.a968	80 01		bra $a96b			bra 	Comp_LessCont
.a96a					Comp_GreaterEqual:
.a96a	38		sec				sec
.a96b					Comp_LessCont:
.a96b	08		php				php
.a96c	ca		dex				dex
.a96d	38		sec				sec
.a96e	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; do a subtraction w/o storing the result
.a971	fd 01 0c	sbc $0c01,x			sbc 	stack0+1,x
.a974	bd 00 0d	lda $0d00,x			lda 	stack1,x
.a977	fd 01 0d	sbc $0d01,x			sbc 	stack1+1,x
.a97a	bd 00 0e	lda $0e00,x			lda 	stack2,x
.a97d	fd 01 0e	sbc $0e01,x			sbc 	stack2+1,x
.a980	bd 00 0f	lda $0f00,x			lda 	stack3,x
.a983	fd 01 0f	sbc $0f01,x			sbc 	stack3+1,x
.a986	50 02		bvc $a98a			bvc 	_CLNoFlip 					; unsigned -> signed
.a988	49 80		eor #$80			eor 	#$80
.a98a					_CLNoFlip:
.a98a	29 80		and #$80			and 	#$80 						; 0 if >= here, so flip if CS.
.a98c	f0 c7		beq $a955			beq 	CompCheckFlip
.a98e	a9 ff		lda #$ff			lda 	#$FF 						; -1 if < here, so flip if CS.
.a990	80 c3		bra $a955			bra 	CompCheckFlip
.a992					Comp_LessEqual:
.a992	38		sec				sec
.a993	80 01		bra $a996			bra 	Comp_LessEqualCont
.a995					Comp_Greater:
.a995	18		clc				clc
.a996					Comp_LessEqualCont:
.a996	08		php				php
.a997	ca		dex				dex
.a998	38		sec				sec
.a999	bd 01 0c	lda $0c01,x			lda 	stack0+1,x 					; do a subtraction w/o storing the result, backwards
.a99c	fd 00 0c	sbc $0c00,x			sbc 	stack0,x
.a99f	bd 01 0d	lda $0d01,x			lda 	stack1+1,x
.a9a2	fd 00 0d	sbc $0d00,x			sbc 	stack1,x
.a9a5	bd 01 0e	lda $0e01,x			lda 	stack2+1,x
.a9a8	fd 00 0e	sbc $0e00,x			sbc 	stack2,x
.a9ab	bd 01 0f	lda $0f01,x			lda 	stack3+1,x
.a9ae	fd 00 0f	sbc $0f00,x			sbc 	stack3,x
.a9b1	50 02		bvc $a9b5			bvc 	_CLENoFlip 					; unsigned -> signed
.a9b3	49 80		eor #$80			eor 	#$80
.a9b5					_CLENoFlip:
.a9b5	29 80		and #$80			and 	#$80 						; 0 if > here, so flip if CS
.a9b7	f0 9c		beq $a955			beq 	CompCheckFlip
.a9b9	a9 ff		lda #$ff			lda 	#$FF 						; -1 if >= here, so flip if CS
.a9bb	80 98		bra $a955			bra 	CompCheckFlip

;******  Return to file: main.asm


;******  Processing file: miscellany/system.asm

.a9bd					System_RUN:
.a9bd	20 7e a3	jsr $a37e			jsr		ResetForRun 				; clear vars, stacks etc.
.a9c0	20 73 a3	jsr $a373			jsr 	ResetCodePointer 			; point to first thing to do.
.a9c3	4c ef a1	jmp $a1ef			jmp 	Execute						; and run
.a9c6					System_END:
>a9c6	ff						.byte 	$FF
.a9c7	4c c8 a4	jmp $a4c8			jmp 	WarmStart
.a9ca					System_STOP:
.a9ca	4c ff ff	jmp $ffff			jmp 	$FFFF
.a9cd	20 84 a4	jsr $a484			jsr 	ErrorHandler
>a9d0	53 54 4f 50 00					.text 	"STOP",0
.a9d5					System_Assert:
.a9d5	ca		dex				dex
.a9d6	bd 01 0c	lda $0c01,x			lda 	stack0+1,x
.a9d9	1d 01 0d	ora $0d01,x			ora 	stack1+1,x
.a9dc	1d 02 0d	ora $0d02,x			ora 	stack1+2,x
.a9df	1d 03 0d	ora $0d03,x			ora 	stack1+3,x
.a9e2	d0 0a		bne $a9ee			bne 	_SAOkay
.a9e4	20 84 a4	jsr $a484			jsr 	ErrorHandler
>a9e7	41 53 53 45 52 54 00				.text 	"ASSERT",0
.a9ee	60		rts		_SAOkay:rts
.a9ef					System_New:
.a9ef	9c 00 11	stz $1100			stz 	ProgramStart 				; zero the first offset, erases.
.a9f2	20 7e a3	jsr $a37e			jsr		ResetForRun 				; clear vars, stacks etc.
.a9f5	60		rts				rts
.a9f6					System_Old:
.a9f6	20 73 a3	jsr $a373			jsr 	ResetCodePointer 			; start of first line.
.a9f9					_SOFindZero:
.a9f9	b1 00		lda ($00),y			lda 	(codePtr),y 				; look for trailing $00
.a9fb	f0 15		beq $aa12			beq 	_SOFoundEnd
.a9fd	c8		iny				iny
.a9fe	d0 f9		bne $a9f9			bne 	_SOFindZero
.aa00	20 84 a4	jsr $a484			jsr 	ErrorHandler
>aa03	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER",0
>aa0b	45 43 4f 56 45 52 00
.aa12					_SOFoundEnd:
.aa12	c8		iny				iny 								; update the offset
.aa13	8c 00 11	sty $1100			sty 	ProgramStart
.aa16	20 7e a3	jsr $a37e			jsr 	ResetForRun 				; redo all stacks etc.
.aa19	60		rts				rts
.aa1a					System_Sys:
.aa1a	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; copy and drop call address
.aa1d	85 04		sta $04				sta 	zTemp0
.aa1f	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aa22	85 05		sta $05				sta 	zTemp0+1
.aa24	ca		dex				dex
.aa25	da		phx				phx
.aa26	5a		phy				phy
.aa27	ad 00 10	lda $1000			lda 	AZVariables+('A'-'A')*4		; load AXY
.aa2a	ae 5c 10	ldx $105c			ldx 	AZVariables+('X'-'A')*4
.aa2d	ac 60 10	ldy $1060			ldy 	AZVariables+('Y'-'A')*4
.aa30	20 3f aa	jsr $aa3f			jsr 	_SSCall 					; effectively jsr (zTemp)
.aa33	8d 00 10	sta $1000			sta 	AZVariables+('A'-'A')*4 	; store AXY
.aa36	8e 5c 10	stx $105c			stx 	AZVariables+('X'-'A')*4
.aa39	8c 60 10	sty $1060			sty 	AZVariables+('Y'-'A')*4
.aa3c	7a		ply				ply
.aa3d	fa		plx				plx
.aa3e	60		rts				rts
.aa3f	6c 04 00	jmp ($0004)	_SSCall:jmp 	(zTemp0)

;******  Return to file: main.asm


;******  Processing file: miscellany/variables.asm

.aa42					Identifier:
.aa42	88		dey				dey 								; wind back to identifier start
.aa43	20 99 a2	jsr $a299			jsr 	IdentifierSearch 			; try to find it.
.aa46	90 2d		bcc $aa75			bcc 	_IDUnknown 					; not known, give up.
.aa48	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.aa4a	d0 3d		bne $aa89			bne 	IDTypeError
.aa4c	c8		iny		_IDSkip:iny
.aa4d	b1 00		lda ($00),y			lda 	(codePtr),y
.aa4f	c9 c0		cmp #$c0			cmp 	#$C0
.aa51	b0 f9		bcs $aa4c			bcs 	_IDSkip
.aa53	20 0b a4	jsr $a40b			jsr 	IndexCheck 					; check index/subscript
.aa56	5a		phy				phy
.aa57	e8		inx				inx 								; make space on stack
.aa58	a0 00		ldy #$00			ldy 	#0 							; copy it back
.aa5a	b1 0e		lda ($0e),y			lda 	(idDataAddr),y
.aa5c	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aa5f	c8		iny				iny
.aa60	b1 0e		lda ($0e),y			lda 	(idDataAddr),y
.aa62	9d 00 0d	sta $0d00,x			sta 	stack1,x
.aa65	c8		iny				iny
.aa66	b1 0e		lda ($0e),y			lda 	(idDataAddr),y
.aa68	9d 00 0e	sta $0e00,x			sta 	stack2,x
.aa6b	c8		iny				iny
.aa6c	b1 0e		lda ($0e),y			lda 	(idDataAddr),y
.aa6e	9d 00 0f	sta $0f00,x			sta 	stack3,x
.aa71	7a		ply				ply
.aa72	4c ef a1	jmp $a1ef			jmp 	Execute
.aa75					_IDUnknown:
.aa75	20 84 a4	jsr $a484			jsr 	ErrorHandler
>aa78	55 4e 4b 4e 4f 57 4e 20				.text 	"UNKNOWN VARIABLE",0
>aa80	56 41 52 49 41 42 4c 45 00
.aa89					IDTypeError:
.aa89	20 84 a4	jsr $a484			jsr 	ErrorHandler
>aa8c	4d 49 53 53 49 4e 47 20				.text 	"MISSING VARIABLE",0
>aa94	56 41 52 49 41 42 4c 45 00
.aa9d					WriteVariable:
.aa9d	b1 00		lda ($00),y			lda 	(codePtr),y 				; check variable
.aa9f	c9 c0		cmp #$c0			cmp 	#$C0
.aaa1	90 e6		bcc $aa89			bcc 	IDTypeError
.aaa3	20 99 a2	jsr $a299			jsr 	IdentifierSearch 			; does it exist
.aaa6	90 06		bcc $aaae			bcc 	_WVNoIdentifier
.aaa8	c9 56		cmp #$56			cmp 	#IDT_VARIABLE 				; must be a variable
.aaaa	f0 12		beq $aabe			beq 	_WVWriteTOS 				; if so write TOS to it.
.aaac	80 db		bra $aa89			bra 	IDTypeError 				; not, then can't do anything.
.aaae					_WVNoIdentifier:
.aaae	5a		phy				phy 								; get current line number
.aaaf	a0 01		ldy #$01			ldy 	#1
.aab1	b1 00		lda ($00),y			lda 	(codePtr),y
.aab3	c8		iny				iny
.aab4	11 00		ora ($00),y			ora 	(codePtr),y
.aab6	7a		ply				ply
.aab7	f0 2d		beq $aae6			beq 	_WVCantCreate 				; if zero (command line) no new vars
.aab9	a9 56		lda #$56			lda 	#IDT_VARIABLE 				; create identifier
.aabb	20 00 a3	jsr $a300			jsr 	IdentifierCreate 			; try to find it
.aabe					_WVWriteTOS:
.aabe	88		dey				dey 								; skip over identifier.
.aabf					_WVSkipIdentifier:
.aabf	c8		iny				iny
.aac0	b1 00		lda ($00),y			lda 	(codePtr),y
.aac2	c9 c0		cmp #$c0			cmp 	#$C0
.aac4	b0 f9		bcs $aabf			bcs 	_WVSkipIdentifier
.aac6	20 0b a4	jsr $a40b			jsr 	IndexCheck 					; check index/subscript
.aac9	5a		phy				phy									; copy TOS in
.aaca	a0 00		ldy #$00			ldy 	#0
.aacc	bd 00 0c	lda $0c00,x			lda 	stack0,x
.aacf	91 0e		sta ($0e),y			sta 	(idDataAddr),y
.aad1	c8		iny				iny
.aad2	bd 00 0d	lda $0d00,x			lda 	stack1,x
.aad5	91 0e		sta ($0e),y			sta 	(idDataAddr),y
.aad7	c8		iny				iny
.aad8	bd 00 0e	lda $0e00,x			lda 	stack2,x
.aadb	91 0e		sta ($0e),y			sta 	(idDataAddr),y
.aadd	c8		iny				iny
.aade	bd 00 0f	lda $0f00,x			lda 	stack3,x
.aae1	91 0e		sta ($0e),y			sta 	(idDataAddr),y
.aae3	7a		ply				ply
.aae4	ca		dex				dex 								; drop
.aae5	60		rts				rts									; go back and execute again.
.aae6					_WVCantCreate:
.aae6	20 84 a4	jsr $a484			jsr 	ErrorHandler
>aae9	43 41 4e 4e 4f 54 20 43				.text 	"CANNOT CREATE VARIABLE",0
>aaf1	52 45 41 54 45 20 56 41 52 49 41 42 4c 45 00

;******  Return to file: main.asm


;******  Processing file: miscellany/inttostr.asm


;******  Return to file: main.asm


;******  Processing file: miscellany/intfromstr.asm


;******  Return to file: main.asm


;******  Processing file: structures/fornext.asm

.ab00					Command_For:
.ab00	20 c8 ab	jsr $abc8			jsr 	StructPushCurrent 			; push current on the stack.
.ab03	bd 00 0c	lda $0c00,x			lda 	stack0,x 					; check zero
.ab06	1d 00 0d	ora $0d00,x			ora 	stack1,x
.ab09	1d 00 0e	ora $0e00,x			ora 	stack2,x
.ab0c	1d 00 0f	ora $0f00,x			ora 	stack3,x
.ab0f	f0 34		beq $ab45			beq 	_CFZero
.ab11	bd 00 0f	lda $0f00,x			lda 	stack3,x 					; push 1's complement of index on
.ab14	49 ff		eor #$ff			eor 	#$FF 						; structure stack.
.ab16	c6 02		dec $02				dec 	StructSP
.ab18	92 02		sta ($02)			sta 	(StructSP)
.ab1a	bd 00 0e	lda $0e00,x			lda 	stack2,x
.ab1d	49 ff		eor #$ff			eor 	#$FF
.ab1f	c6 02		dec $02				dec 	StructSP
.ab21	92 02		sta ($02)			sta 	(StructSP)
.ab23	bd 00 0d	lda $0d00,x			lda 	stack1,x
.ab26	49 ff		eor #$ff			eor 	#$FF
.ab28	c6 02		dec $02				dec 	StructSP
.ab2a	92 02		sta ($02)			sta 	(StructSP)
.ab2c	bd 00 0c	lda $0c00,x			lda 	stack0,x
.ab2f	49 ff		eor #$ff			eor 	#$FF
.ab31	c6 02		dec $02				dec 	StructSP
.ab33	92 02		sta ($02)			sta 	(StructSP)
.ab35	ca		dex				dex 								; pop stack value
.ab36	a9 46		lda #$46			lda 	#STM_FOR 					; push FOR marker
.ab38	c6 02		dec $02				dec 	StructSP
.ab3a	92 02		sta ($02)			sta 	(StructSP)
.ab3c	a5 02		lda $02				lda 	StructSP 					; copy current so it can access it.
.ab3e	85 10		sta $10				sta 	ForAddr
.ab40	a5 03		lda $03				lda 	StructSP+1
.ab42	85 11		sta $11				sta 	ForAddr+1
.ab44	60		rts				rts
.ab45					_CFZero:
.ab45	20 84 a4	jsr $a484			jsr 	ErrorHandler
>ab48	46 4f 52 20 43 4f 55 4e				.text 	"FOR COUNT ZERO",0
>ab50	54 20 5a 45 52 4f 00
.ab57					Command_Next:
.ab57	b2 02		lda ($02)			lda 	(StructSP)					; check it's FOR.
.ab59	c9 46		cmp #$46			cmp 	#STM_FOR
.ab5b	d0 30		bne $ab8d			bne 	_CNNoFor
.ab5d	5a		phy				phy
.ab5e	a0 00		ldy #$00			ldy 	#0
.ab60					_CNIncrement:
.ab60	c8		iny				iny
.ab61	b1 02		lda ($02),y			lda 	(StructSP),y 				; increment the index
.ab63	1a		inc a				inc 	a
.ab64	91 02		sta ($02),y			sta 	(StructSP),y
.ab66	f0 f8		beq $ab60			beq		_CNIncrement 				; carry out.
.ab68	a0 01		ldy #$01			ldy 	#1 							; now and all the counts together
.ab6a	b1 02		lda ($02),y			lda 	(StructSP),y 				; on the last time round they
.ab6c	c8		iny				iny 								; will all be $FF
.ab6d	31 02		and ($02),y			and 	(StructSP),y
.ab6f	c8		iny				iny
.ab70	31 02		and ($02),y			and 	(StructSP),y
.ab72	c8		iny				iny
.ab73	31 02		and ($02),y			and 	(StructSP),y
.ab75	7a		ply				ply 								; restore Y
.ab76	1a		inc a				inc 	a 							; so this will be zero last time round
.ab77	d0 06		bne $ab7f			bne 	_CNLoop 					; loop back if non-zero
.ab79	a9 09		lda #$09			lda 	#9 							; pop 9 elements off structure stack.
.ab7b	20 c2 ab	jsr $abc2			jsr 	StructPopCount
.ab7e	60		rts				rts
.ab7f					_CNLoop:
.ab7f	a5 02		lda $02				lda 	StructSP 					; copy current so it can access it.
.ab81	85 10		sta $10				sta 	ForAddr
.ab83	a5 03		lda $03				lda 	StructSP+1
.ab85	85 11		sta $11				sta 	ForAddr+1
.ab87	a0 05		ldy #$05			ldy 	#5 							; restore the position
.ab89	20 e0 ab	jsr $abe0			jsr 	StructPopCurrent
.ab8c	60		rts				rts
.ab8d					_CNNoFor:
.ab8d	20 84 a4	jsr $a484			jsr 	ErrorHandler
>ab90	4d 49 53 53 49 4e 47 20				.text 	"MISSING FOR",0
>ab98	46 4f 52 00
.ab9c					Command_Index:
.ab9c	5a		phy				phy
.ab9d	a0 01		ldy #$01			ldy 	#1 							; get the stack position of
.ab9f	e8		inx				inx
.aba0	38		sec				sec
.aba1	a9 fe		lda #$fe			lda 	#$FE
.aba3	f1 10		sbc ($10),y			sbc 	(ForAddr),y
.aba5	9d 00 0c	sta $0c00,x			sta 	stack0,x
.aba8	c8		iny				iny
.aba9	a9 ff		lda #$ff			lda 	#$FF
.abab	f1 10		sbc ($10),y			sbc 	(ForAddr),y
.abad	9d 00 0d	sta $0d00,x			sta 	stack1,x
.abb0	c8		iny				iny
.abb1	a9 ff		lda #$ff			lda 	#$FF
.abb3	f1 10		sbc ($10),y			sbc 	(ForAddr),y
.abb5	9d 00 0e	sta $0e00,x			sta 	stack2,x
.abb8	c8		iny				iny
.abb9	a9 ff		lda #$ff			lda 	#$FF
.abbb	f1 10		sbc ($10),y			sbc 	(ForAddr),y
.abbd	9d 00 0f	sta $0f00,x			sta 	stack3,x
.abc0	7a		ply				ply
.abc1	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: structures/structures.asm

.abc2					StructPopCount:
.abc2	18		clc				clc
.abc3	65 02		adc $02				adc 	StructSP
.abc5	85 02		sta $02				sta 	StructSP
.abc7	60		rts				rts
.abc8					StructPushCurrent:
.abc8	a9 00		lda #$00			lda 	#0							; push bank
.abca	c6 02		dec $02				dec 	StructSP
.abcc	92 02		sta ($02)			sta 	(StructSP)
.abce	98		tya				tya									; y Offset
.abcf	c6 02		dec $02				dec 	StructSP
.abd1	92 02		sta ($02)			sta 	(StructSP)
.abd3	a5 01		lda $01				lda 	codePtr+1 					; codeptr high
.abd5	c6 02		dec $02				dec 	StructSP
.abd7	92 02		sta ($02)			sta 	(StructSP)
.abd9	a5 00		lda $00				lda 	codePtr 					; codeptr low
.abdb	c6 02		dec $02				dec 	StructSP
.abdd	92 02		sta ($02)			sta 	(StructSP)
.abdf	60		rts				rts
.abe0					StructPopCurrent:
.abe0	b1 02		lda ($02),y			lda 	(StructSP),y 				; codeptr low
.abe2	85 00		sta $00				sta 	codePtr
.abe4	c8		iny				iny
.abe5	b1 02		lda ($02),y			lda 	(StructSP),y 				; codeptr high
.abe7	85 01		sta $01				sta 	codePtr+1
.abe9	c8		iny				iny
.abea	b1 02		lda ($02),y			lda 	(StructSP),y				; y offset
.abec	a8		tay				tay
.abed	60		rts				rts

;******  Return to file: main.asm


;******  Processing file: generated/testcode.inc

>1100	07 e8 03 aa 10 47 00 05			.byte $07,$e8,$03,$aa,$10,$47,$00,$05,$e9,$03,$3f,$00
>1108	e9 03 3f 00

;******  Return to file: main.asm

>110c	00						.byte 	0

;******  End of listing
