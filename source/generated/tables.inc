; *** Generated by tables.py ***

KeywordText:
	.byte $01,$20                          ; $10  
	.byte $01,$21                          ; $11 !
	.byte $01,$26                          ; $12 &
	.byte $01,$2a                          ; $13 *
	.byte $01,$2b                          ; $14 +
	.byte $02,$2b,$2b                      ; $15 ++
	.byte $01,$2d                          ; $16 -
	.byte $02,$2d,$2d                      ; $17 --
	.byte $01,$2f                          ; $18 /
	.byte $01,$3b                          ; $19 ;
	.byte $01,$3c                          ; $1a <
	.byte $02,$3c,$3c                      ; $1b <<
	.byte $02,$3c,$3d                      ; $1c <=
	.byte $02,$3c,$3e                      ; $1d <>
	.byte $01,$3d                          ; $1e =
	.byte $01,$3e                          ; $1f >
	.byte $02,$3e,$3d                      ; $20 >=
	.byte $02,$3e,$3e                      ; $21 >>
	.byte $01,$00                          ; $22 @
	.byte $03,$01,$02,$13                  ; $23 ABS
	.byte $05,$01,$0c,$0c,$0f,$03          ; $24 ALLOC
	.byte $03,$01,$0e,$04                  ; $25 AND
	.byte $02,$03,$21                      ; $26 C!
	.byte $02,$03,$00                      ; $27 C@
	.byte $03,$04,$05,$06                  ; $28 DEF
	.byte $04,$04,$12,$0f,$10              ; $29 DROP
	.byte $03,$04,$15,$10                  ; $2a DUP
	.byte $04,$05,$0c,$13,$05              ; $2b ELSE
	.byte $05,$05,$0d,$10,$14,$19          ; $2c EMPTY
	.byte $03,$05,$0e,$04                  ; $2d END
	.byte $05,$05,$0e,$04,$09,$06          ; $2e ENDIF
	.byte $03,$06,$0f,$12                  ; $2f FOR
	.byte $02,$09,$06                      ; $30 IF
	.byte $05,$09,$0e,$04,$05,$18          ; $31 INDEX
	.byte $04,$0c,$09,$13,$14              ; $32 LIST
	.byte $03,$0d,$0f,$04                  ; $33 MOD
	.byte $06,$0e,$05,$07,$01,$14,$05      ; $34 NEGATE
	.byte $03,$0e,$05,$17                  ; $35 NEW
	.byte $04,$0e,$05,$18,$14              ; $36 NEXT
	.byte $03,$0e,$09,$10                  ; $37 NIP
	.byte $03,$0e,$0f,$14                  ; $38 NOT
	.byte $03,$0f,$0c,$04                  ; $39 OLD
	.byte $02,$0f,$12                      ; $3a OR
	.byte $04,$0f,$16,$05,$12              ; $3b OVER
	.byte $06,$12,$05,$10,$05,$01,$14      ; $3c REPEAT
	.byte $03,$12,$15,$0e                  ; $3d RUN
	.byte $04,$13,$14,$0f,$10              ; $3e STOP
	.byte $04,$13,$17,$01,$10              ; $3f SWAP
	.byte $03,$13,$19,$13                  ; $40 SYS
	.byte $05,$15,$0e,$14,$09,$0c          ; $41 UNTIL
	.byte $02,$17,$21                      ; $42 W!
	.byte $02,$17,$00                      ; $43 W@
	.byte $03,$18,$0f,$12                  ; $44 XOR
	.byte $02,$1b,$1d                      ; $45 []
	.byte $01,$1e                          ; $46 ^
	.byte $01,$2d                          ; $47 {-}
	.byte $00

KeywordVectorTable:
	.word SyntaxError                      ; $10  
	.word Mem_DPoke                        ; $11 !
	.word SyntaxError                      ; $12 &
	.word MulInteger32                     ; $13 *
	.word Stack_Add                        ; $14 +
	.word Unary_Increment                  ; $15 ++
	.word Stack_Sub                        ; $16 -
	.word Unary_Decrement                  ; $17 --
	.word DivInteger32                     ; $18 /
	.word SyntaxError                      ; $19 ;
	.word Comp_Less                        ; $1a <
	.word Unary_Shl                        ; $1b <<
	.word Comp_LessEqual                   ; $1c <=
	.word Comp_NotEqual                    ; $1d <>
	.word Comp_Equal                       ; $1e =
	.word Comp_Greater                     ; $1f >
	.word Comp_GreaterEqual                ; $20 >=
	.word Unary_Shr                        ; $21 >>
	.word Mem_DPeek                        ; $22 @
	.word Unary_Absolute                   ; $23 ABS
	.word SyntaxError                      ; $24 ALLOC
	.word Stack_And                        ; $25 AND
	.word Mem_Poke                         ; $26 C!
	.word Mem_Peek                         ; $27 C@
	.word SyntaxError                      ; $28 DEF
	.word Stack_Drop                       ; $29 DROP
	.word Stack_Dup                        ; $2a DUP
	.word SyntaxError                      ; $2b ELSE
	.word Stack_Empty                      ; $2c EMPTY
	.word System_END                       ; $2d END
	.word SyntaxError                      ; $2e ENDIF
	.word Command_For                      ; $2f FOR
	.word SyntaxError                      ; $30 IF
	.word Command_Index                    ; $31 INDEX
	.word SyntaxError                      ; $32 LIST
	.word ModInteger32                     ; $33 MOD
	.word Unary_Negate                     ; $34 NEGATE
	.word System_New                       ; $35 NEW
	.word Command_Next                     ; $36 NEXT
	.word Stack_Nip                        ; $37 NIP
	.word Unary_Not                        ; $38 NOT
	.word System_Old                       ; $39 OLD
	.word Stack_Or                         ; $3a OR
	.word Stack_Over                       ; $3b OVER
	.word SyntaxError                      ; $3c REPEAT
	.word System_RUN                       ; $3d RUN
	.word System_STOP                      ; $3e STOP
	.word Stack_Swap                       ; $3f SWAP
	.word System_Sys                       ; $40 SYS
	.word SyntaxError                      ; $41 UNTIL
	.word Mem_WPoke                        ; $42 W!
	.word Mem_WPeek                        ; $43 W@
	.word Stack_Xor                        ; $44 XOR
	.word SyntaxError                      ; $45 []
	.word WriteVariable                    ; $46 ^
	.word Unary_Const_Minus                ; $47 {-}

KWD_SPACE = $10                  ; $10  
KWD_PLING = $11                  ; $11 !
KWD_AMPERSAND = $12              ; $12 &
KWD_ASTERISK = $13               ; $13 *
KWD_PLUS = $14                   ; $14 +
KWD_PLUSPLUS = $15               ; $15 ++
KWD_MINUS = $16                  ; $16 -
KWD_MINUSMINUS = $17             ; $17 --
KWD_SLASH = $18                  ; $18 /
KWD_SEMICOLON = $19              ; $19 ;
KWD_LESS = $1a                   ; $1a <
KWD_LESSLESS = $1b               ; $1b <<
KWD_LESSEQUAL = $1c              ; $1c <=
KWD_LESSGREATER = $1d            ; $1d <>
KWD_EQUAL = $1e                  ; $1e =
KWD_GREATER = $1f                ; $1f >
KWD_GREATEREQUAL = $20           ; $20 >=
KWD_GREATERGREATER = $21         ; $21 >>
KWD_AT = $22                     ; $22 @
KWD_ABS = $23                    ; $23 ABS
KWD_ALLOC = $24                  ; $24 ALLOC
KWD_AND = $25                    ; $25 AND
KWD_CPLING = $26                 ; $26 C!
KWD_CAT = $27                    ; $27 C@
KWD_DEF = $28                    ; $28 DEF
KWD_DROP = $29                   ; $29 DROP
KWD_DUP = $2a                    ; $2a DUP
KWD_ELSE = $2b                   ; $2b ELSE
KWD_EMPTY = $2c                  ; $2c EMPTY
KWD_END = $2d                    ; $2d END
KWD_ENDIF = $2e                  ; $2e ENDIF
KWD_FOR = $2f                    ; $2f FOR
KWD_IF = $30                     ; $30 IF
KWD_INDEX = $31                  ; $31 INDEX
KWD_LIST = $32                   ; $32 LIST
KWD_MOD = $33                    ; $33 MOD
KWD_NEGATE = $34                 ; $34 NEGATE
KWD_NEW = $35                    ; $35 NEW
KWD_NEXT = $36                   ; $36 NEXT
KWD_NIP = $37                    ; $37 NIP
KWD_NOT = $38                    ; $38 NOT
KWD_OLD = $39                    ; $39 OLD
KWD_OR = $3a                     ; $3a OR
KWD_OVER = $3b                   ; $3b OVER
KWD_REPEAT = $3c                 ; $3c REPEAT
KWD_RUN = $3d                    ; $3d RUN
KWD_STOP = $3e                   ; $3e STOP
KWD_SWAP = $3f                   ; $3f SWAP
KWD_SYS = $40                    ; $40 SYS
KWD_UNTIL = $41                  ; $41 UNTIL
KWD_WPLING = $42                 ; $42 W!
KWD_WAT = $43                    ; $43 W@
KWD_XOR = $44                    ; $44 XOR
KWD_LSQPARENRSQPAREN = $45       ; $45 []
KWD_HAT = $46                    ; $46 ^
KWD_CONSTANT_MINUS = $47         ; $47 {-}
