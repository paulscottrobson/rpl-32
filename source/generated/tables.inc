; *** Generated by tables.py ***

KeywordText:
	.byte $01,$21                          ; $10 !
	.byte $01,$2a                          ; $11 *
	.byte $01,$2b                          ; $12 +
	.byte $02,$2b,$2b                      ; $13 ++
	.byte $01,$2d                          ; $14 -
	.byte $02,$2d,$2d                      ; $15 --
	.byte $01,$2e                          ; $16 .
	.byte $01,$2f                          ; $17 /
	.byte $01,$3b                          ; $18 ;
	.byte $01,$3c                          ; $19 <
	.byte $02,$3c,$3c                      ; $1a <<
	.byte $02,$3c,$3d                      ; $1b <=
	.byte $02,$3c,$3e                      ; $1c <>
	.byte $01,$3d                          ; $1d =
	.byte $01,$3e                          ; $1e >
	.byte $02,$3e,$3d                      ; $1f >=
	.byte $02,$3e,$3e                      ; $20 >>
	.byte $01,$40                          ; $21 @
	.byte $03,$41,$42,$53                  ; $22 ABS
	.byte $05,$41,$4c,$4c,$4f,$43          ; $23 ALLOC
	.byte $03,$41,$4e,$44                  ; $24 AND
	.byte $06,$41,$53,$53,$45,$52,$54      ; $25 ASSERT
	.byte $02,$43,$21                      ; $26 C!
	.byte $02,$43,$40                      ; $27 C@
	.byte $03,$43,$4c,$52                  ; $28 CLR
	.byte $03,$44,$45,$46                  ; $29 DEF
	.byte $04,$44,$52,$4f,$50              ; $2a DROP
	.byte $03,$44,$55,$50                  ; $2b DUP
	.byte $04,$45,$4c,$53,$45              ; $2c ELSE
	.byte $03,$45,$4e,$44                  ; $2d END
	.byte $05,$45,$4e,$44,$49,$46          ; $2e ENDIF
	.byte $03,$46,$4f,$52                  ; $2f FOR
	.byte $02,$49,$46                      ; $30 IF
	.byte $05,$49,$4e,$44,$45,$58          ; $31 INDEX
	.byte $04,$4c,$49,$53,$54              ; $32 LIST
	.byte $03,$4d,$4f,$44                  ; $33 MOD
	.byte $06,$4e,$45,$47,$41,$54,$45      ; $34 NEGATE
	.byte $03,$4e,$45,$57                  ; $35 NEW
	.byte $04,$4e,$45,$58,$54              ; $36 NEXT
	.byte $03,$4e,$49,$50                  ; $37 NIP
	.byte $03,$4e,$4f,$54                  ; $38 NOT
	.byte $03,$4f,$4c,$44                  ; $39 OLD
	.byte $02,$4f,$52                      ; $3a OR
	.byte $04,$4f,$56,$45,$52              ; $3b OVER
	.byte $06,$52,$45,$50,$45,$41,$54      ; $3c REPEAT
	.byte $03,$52,$55,$4e                  ; $3d RUN
	.byte $03,$53,$48,$4c                  ; $3e SHL
	.byte $03,$53,$48,$52                  ; $3f SHR
	.byte $04,$53,$54,$4f,$50              ; $40 STOP
	.byte $04,$53,$57,$41,$50              ; $41 SWAP
	.byte $03,$53,$59,$53                  ; $42 SYS
	.byte $05,$55,$4e,$54,$49,$4c          ; $43 UNTIL
	.byte $02,$57,$21                      ; $44 W!
	.byte $02,$57,$40                      ; $45 W@
	.byte $03,$58,$4f,$52                  ; $46 XOR
	.byte $01,$5b                          ; $47 [
	.byte $01,$5d                          ; $48 ]
	.byte $01,$5e                          ; $49 ^
	.byte $01,$2b                          ; $4a {+}
	.byte $01,$2d                          ; $4b {-}
	.byte $00

KeywordVectorTable:
	.word Mem_DPoke                        ; $10 !
	.word MulInteger32                     ; $11 *
	.word Stack_Add                        ; $12 +
	.word Unary_Increment                  ; $13 ++
	.word Stack_Sub                        ; $14 -
	.word Unary_Decrement                  ; $15 --
	.word System_ShowStack                 ; $16 .
	.word DivInteger32                     ; $17 /
	.word SyntaxError                      ; $18 ;
	.word Comp_Less                        ; $19 <
	.word Unary_Shl                        ; $1a <<
	.word Comp_LessEqual                   ; $1b <=
	.word Comp_NotEqual                    ; $1c <>
	.word Comp_Equal                       ; $1d =
	.word Comp_Greater                     ; $1e >
	.word Comp_GreaterEqual                ; $1f >=
	.word Unary_Shr                        ; $20 >>
	.word Mem_DPeek                        ; $21 @
	.word Unary_Absolute                   ; $22 ABS
	.word SyntaxError                      ; $23 ALLOC
	.word Stack_And                        ; $24 AND
	.word System_Assert                    ; $25 ASSERT
	.word Mem_Poke                         ; $26 C!
	.word Mem_Peek                         ; $27 C@
	.word Stack_Empty                      ; $28 CLR
	.word SyntaxError                      ; $29 DEF
	.word Stack_Drop                       ; $2a DROP
	.word Stack_Dup                        ; $2b DUP
	.word SyntaxError                      ; $2c ELSE
	.word System_END                       ; $2d END
	.word SyntaxError                      ; $2e ENDIF
	.word Command_For                      ; $2f FOR
	.word SyntaxError                      ; $30 IF
	.word Command_Index                    ; $31 INDEX
	.word Cmd_List                         ; $32 LIST
	.word ModInteger32                     ; $33 MOD
	.word Unary_Negate                     ; $34 NEGATE
	.word System_New                       ; $35 NEW
	.word Command_Next                     ; $36 NEXT
	.word Stack_Nip                        ; $37 NIP
	.word Unary_Not                        ; $38 NOT
	.word System_Old                       ; $39 OLD
	.word Stack_Or                         ; $3a OR
	.word Stack_Over                       ; $3b OVER
	.word Command_Repeat                   ; $3c REPEAT
	.word System_RUN                       ; $3d RUN
	.word Stack_Shl                        ; $3e SHL
	.word Stack_Shr                        ; $3f SHR
	.word System_STOP                      ; $40 STOP
	.word Stack_Swap                       ; $41 SWAP
	.word System_Sys                       ; $42 SYS
	.word Command_Until                    ; $43 UNTIL
	.word Mem_WPoke                        ; $44 W!
	.word Mem_WPeek                        ; $45 W@
	.word Stack_Xor                        ; $46 XOR
	.word SyntaxError                      ; $47 [
	.word SyntaxError                      ; $48 ]
	.word WriteVariable                    ; $49 ^
	.word SyntaxError                      ; $4a {+}
	.word SyntaxError                      ; $4b {-}

KWD_PLING = $10                  ; $10 !
KWD_ASTERISK = $11               ; $11 *
KWD_PLUS = $12                   ; $12 +
KWD_PLUSPLUS = $13               ; $13 ++
KWD_MINUS = $14                  ; $14 -
KWD_MINUSMINUS = $15             ; $15 --
KWD_DOT = $16                    ; $16 .
KWD_SLASH = $17                  ; $17 /
KWD_SEMICOLON = $18              ; $18 ;
KWD_LESS = $19                   ; $19 <
KWD_LESSLESS = $1a               ; $1a <<
KWD_LESSEQUAL = $1b              ; $1b <=
KWD_LESSGREATER = $1c            ; $1c <>
KWD_EQUAL = $1d                  ; $1d =
KWD_GREATER = $1e                ; $1e >
KWD_GREATEREQUAL = $1f           ; $1f >=
KWD_GREATERGREATER = $20         ; $20 >>
KWD_AT = $21                     ; $21 @
KWD_ABS = $22                    ; $22 ABS
KWD_ALLOC = $23                  ; $23 ALLOC
KWD_AND = $24                    ; $24 AND
KWD_ASSERT = $25                 ; $25 ASSERT
KWD_CPLING = $26                 ; $26 C!
KWD_CAT = $27                    ; $27 C@
KWD_CLR = $28                    ; $28 CLR
KWD_DEF = $29                    ; $29 DEF
KWD_DROP = $2a                   ; $2a DROP
KWD_DUP = $2b                    ; $2b DUP
KWD_ELSE = $2c                   ; $2c ELSE
KWD_END = $2d                    ; $2d END
KWD_ENDIF = $2e                  ; $2e ENDIF
KWD_FOR = $2f                    ; $2f FOR
KWD_IF = $30                     ; $30 IF
KWD_INDEX = $31                  ; $31 INDEX
KWD_LIST = $32                   ; $32 LIST
KWD_MOD = $33                    ; $33 MOD
KWD_NEGATE = $34                 ; $34 NEGATE
KWD_NEW = $35                    ; $35 NEW
KWD_NEXT = $36                   ; $36 NEXT
KWD_NIP = $37                    ; $37 NIP
KWD_NOT = $38                    ; $38 NOT
KWD_OLD = $39                    ; $39 OLD
KWD_OR = $3a                     ; $3a OR
KWD_OVER = $3b                   ; $3b OVER
KWD_REPEAT = $3c                 ; $3c REPEAT
KWD_RUN = $3d                    ; $3d RUN
KWD_SHL = $3e                    ; $3e SHL
KWD_SHR = $3f                    ; $3f SHR
KWD_STOP = $40                   ; $40 STOP
KWD_SWAP = $41                   ; $41 SWAP
KWD_SYS = $42                    ; $42 SYS
KWD_UNTIL = $43                  ; $43 UNTIL
KWD_WPLING = $44                 ; $44 W!
KWD_WAT = $45                    ; $45 W@
KWD_XOR = $46                    ; $46 XOR
KWD_LSQPAREN = $47               ; $47 [
KWD_RSQPAREN = $48               ; $48 ]
KWD_HAT = $49                    ; $49 ^
KWD_CONSTANT_PLUS = $4a          ; $4a {+}
KWD_CONSTANT_MINUS = $4b         ; $4b {-}
