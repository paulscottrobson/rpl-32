; *** Generated by tables.py ***

KeywordText:
	.byte $01,$20                          ; $10  
	.byte $01,$21                          ; $11 !
	.byte $01,$26                          ; $12 &
	.byte $01,$2a                          ; $13 *
	.byte $01,$2b                          ; $14 +
	.byte $02,$2b,$2b                      ; $15 ++
	.byte $01,$2d                          ; $16 -
	.byte $02,$2d,$2d                      ; $17 --
	.byte $01,$2f                          ; $18 /
	.byte $01,$3b                          ; $19 ;
	.byte $01,$3c                          ; $1a <
	.byte $02,$3c,$3c                      ; $1b <<
	.byte $02,$3c,$3d                      ; $1c <=
	.byte $02,$3c,$3e                      ; $1d <>
	.byte $01,$3d                          ; $1e =
	.byte $01,$3e                          ; $1f >
	.byte $02,$3e,$3d                      ; $20 >=
	.byte $02,$3e,$3e                      ; $21 >>
	.byte $01,$00                          ; $22 @
	.byte $03,$01,$02,$13                  ; $23 ABS
	.byte $05,$01,$0c,$0c,$0f,$03          ; $24 ALLOC
	.byte $03,$01,$0e,$04                  ; $25 AND
	.byte $06,$01,$13,$13,$05,$12,$14      ; $26 ASSERT
	.byte $02,$03,$21                      ; $27 C!
	.byte $02,$03,$00                      ; $28 C@
	.byte $03,$04,$05,$06                  ; $29 DEF
	.byte $04,$04,$12,$0f,$10              ; $2a DROP
	.byte $03,$04,$15,$10                  ; $2b DUP
	.byte $04,$05,$0c,$13,$05              ; $2c ELSE
	.byte $05,$05,$0d,$10,$14,$19          ; $2d EMPTY
	.byte $03,$05,$0e,$04                  ; $2e END
	.byte $05,$05,$0e,$04,$09,$06          ; $2f ENDIF
	.byte $03,$06,$0f,$12                  ; $30 FOR
	.byte $02,$09,$06                      ; $31 IF
	.byte $05,$09,$0e,$04,$05,$18          ; $32 INDEX
	.byte $04,$0c,$09,$13,$14              ; $33 LIST
	.byte $03,$0d,$0f,$04                  ; $34 MOD
	.byte $06,$0e,$05,$07,$01,$14,$05      ; $35 NEGATE
	.byte $03,$0e,$05,$17                  ; $36 NEW
	.byte $04,$0e,$05,$18,$14              ; $37 NEXT
	.byte $03,$0e,$09,$10                  ; $38 NIP
	.byte $03,$0e,$0f,$14                  ; $39 NOT
	.byte $03,$0f,$0c,$04                  ; $3a OLD
	.byte $02,$0f,$12                      ; $3b OR
	.byte $04,$0f,$16,$05,$12              ; $3c OVER
	.byte $06,$12,$05,$10,$05,$01,$14      ; $3d REPEAT
	.byte $03,$12,$15,$0e                  ; $3e RUN
	.byte $04,$13,$14,$0f,$10              ; $3f STOP
	.byte $04,$13,$17,$01,$10              ; $40 SWAP
	.byte $03,$13,$19,$13                  ; $41 SYS
	.byte $05,$15,$0e,$14,$09,$0c          ; $42 UNTIL
	.byte $02,$17,$21                      ; $43 W!
	.byte $02,$17,$00                      ; $44 W@
	.byte $03,$18,$0f,$12                  ; $45 XOR
	.byte $02,$1b,$1d                      ; $46 []
	.byte $01,$1e                          ; $47 ^
	.byte $01,$2d                          ; $48 {-}
	.byte $00

KeywordVectorTable:
	.word SyntaxError                      ; $10  
	.word Mem_DPoke                        ; $11 !
	.word SyntaxError                      ; $12 &
	.word MulInteger32                     ; $13 *
	.word Stack_Add                        ; $14 +
	.word Unary_Increment                  ; $15 ++
	.word Stack_Sub                        ; $16 -
	.word Unary_Decrement                  ; $17 --
	.word DivInteger32                     ; $18 /
	.word SyntaxError                      ; $19 ;
	.word Comp_Less                        ; $1a <
	.word Unary_Shl                        ; $1b <<
	.word Comp_LessEqual                   ; $1c <=
	.word Comp_NotEqual                    ; $1d <>
	.word Comp_Equal                       ; $1e =
	.word Comp_Greater                     ; $1f >
	.word Comp_GreaterEqual                ; $20 >=
	.word Unary_Shr                        ; $21 >>
	.word Mem_DPeek                        ; $22 @
	.word Unary_Absolute                   ; $23 ABS
	.word SyntaxError                      ; $24 ALLOC
	.word Stack_And                        ; $25 AND
	.word System_Assert                    ; $26 ASSERT
	.word Mem_Poke                         ; $27 C!
	.word Mem_Peek                         ; $28 C@
	.word SyntaxError                      ; $29 DEF
	.word Stack_Drop                       ; $2a DROP
	.word Stack_Dup                        ; $2b DUP
	.word SyntaxError                      ; $2c ELSE
	.word Stack_Empty                      ; $2d EMPTY
	.word System_END                       ; $2e END
	.word SyntaxError                      ; $2f ENDIF
	.word Command_For                      ; $30 FOR
	.word SyntaxError                      ; $31 IF
	.word Command_Index                    ; $32 INDEX
	.word SyntaxError                      ; $33 LIST
	.word ModInteger32                     ; $34 MOD
	.word Unary_Negate                     ; $35 NEGATE
	.word System_New                       ; $36 NEW
	.word Command_Next                     ; $37 NEXT
	.word Stack_Nip                        ; $38 NIP
	.word Unary_Not                        ; $39 NOT
	.word System_Old                       ; $3a OLD
	.word Stack_Or                         ; $3b OR
	.word Stack_Over                       ; $3c OVER
	.word SyntaxError                      ; $3d REPEAT
	.word System_RUN                       ; $3e RUN
	.word System_STOP                      ; $3f STOP
	.word Stack_Swap                       ; $40 SWAP
	.word System_Sys                       ; $41 SYS
	.word SyntaxError                      ; $42 UNTIL
	.word Mem_WPoke                        ; $43 W!
	.word Mem_WPeek                        ; $44 W@
	.word Stack_Xor                        ; $45 XOR
	.word SyntaxError                      ; $46 []
	.word WriteVariable                    ; $47 ^
	.word Unary_Const_Minus                ; $48 {-}

KWD_SPACE = $10                  ; $10  
KWD_PLING = $11                  ; $11 !
KWD_AMPERSAND = $12              ; $12 &
KWD_ASTERISK = $13               ; $13 *
KWD_PLUS = $14                   ; $14 +
KWD_PLUSPLUS = $15               ; $15 ++
KWD_MINUS = $16                  ; $16 -
KWD_MINUSMINUS = $17             ; $17 --
KWD_SLASH = $18                  ; $18 /
KWD_SEMICOLON = $19              ; $19 ;
KWD_LESS = $1a                   ; $1a <
KWD_LESSLESS = $1b               ; $1b <<
KWD_LESSEQUAL = $1c              ; $1c <=
KWD_LESSGREATER = $1d            ; $1d <>
KWD_EQUAL = $1e                  ; $1e =
KWD_GREATER = $1f                ; $1f >
KWD_GREATEREQUAL = $20           ; $20 >=
KWD_GREATERGREATER = $21         ; $21 >>
KWD_AT = $22                     ; $22 @
KWD_ABS = $23                    ; $23 ABS
KWD_ALLOC = $24                  ; $24 ALLOC
KWD_AND = $25                    ; $25 AND
KWD_ASSERT = $26                 ; $26 ASSERT
KWD_CPLING = $27                 ; $27 C!
KWD_CAT = $28                    ; $28 C@
KWD_DEF = $29                    ; $29 DEF
KWD_DROP = $2a                   ; $2a DROP
KWD_DUP = $2b                    ; $2b DUP
KWD_ELSE = $2c                   ; $2c ELSE
KWD_EMPTY = $2d                  ; $2d EMPTY
KWD_END = $2e                    ; $2e END
KWD_ENDIF = $2f                  ; $2f ENDIF
KWD_FOR = $30                    ; $30 FOR
KWD_IF = $31                     ; $31 IF
KWD_INDEX = $32                  ; $32 INDEX
KWD_LIST = $33                   ; $33 LIST
KWD_MOD = $34                    ; $34 MOD
KWD_NEGATE = $35                 ; $35 NEGATE
KWD_NEW = $36                    ; $36 NEW
KWD_NEXT = $37                   ; $37 NEXT
KWD_NIP = $38                    ; $38 NIP
KWD_NOT = $39                    ; $39 NOT
KWD_OLD = $3a                    ; $3a OLD
KWD_OR = $3b                     ; $3b OR
KWD_OVER = $3c                   ; $3c OVER
KWD_REPEAT = $3d                 ; $3d REPEAT
KWD_RUN = $3e                    ; $3e RUN
KWD_STOP = $3f                   ; $3f STOP
KWD_SWAP = $40                   ; $40 SWAP
KWD_SYS = $41                    ; $41 SYS
KWD_UNTIL = $42                  ; $42 UNTIL
KWD_WPLING = $43                 ; $43 W!
KWD_WAT = $44                    ; $44 W@
KWD_XOR = $45                    ; $45 XOR
KWD_LSQPARENRSQPAREN = $46       ; $46 []
KWD_HAT = $47                    ; $47 ^
KWD_CONSTANT_MINUS = $48         ; $48 {-}
