; *** Generated by tables.py ***

KeywordText:
	.byte $01,$21                          ; $10 !
	.byte $01,$26                          ; $11 &
	.byte $01,$2a                          ; $12 *
	.byte $01,$2b                          ; $13 +
	.byte $02,$2b,$2b                      ; $14 ++
	.byte $01,$2d                          ; $15 -
	.byte $02,$2d,$2d                      ; $16 --
	.byte $01,$2e                          ; $17 .
	.byte $01,$2f                          ; $18 /
	.byte $01,$3b                          ; $19 ;
	.byte $01,$3c                          ; $1a <
	.byte $02,$3c,$3c                      ; $1b <<
	.byte $02,$3c,$3d                      ; $1c <=
	.byte $02,$3c,$3e                      ; $1d <>
	.byte $01,$3d                          ; $1e =
	.byte $01,$3e                          ; $1f >
	.byte $02,$3e,$3d                      ; $20 >=
	.byte $02,$3e,$3e                      ; $21 >>
	.byte $01,$40                          ; $22 @
	.byte $03,$41,$42,$53                  ; $23 ABS
	.byte $05,$41,$4c,$4c,$4f,$43          ; $24 ALLOC
	.byte $03,$41,$4e,$44                  ; $25 AND
	.byte $06,$41,$53,$53,$45,$52,$54      ; $26 ASSERT
	.byte $02,$43,$21                      ; $27 C!
	.byte $02,$43,$40                      ; $28 C@
	.byte $03,$43,$4c,$52                  ; $29 CLR
	.byte $03,$44,$45,$46                  ; $2a DEF
	.byte $04,$44,$52,$4f,$50              ; $2b DROP
	.byte $03,$44,$55,$50                  ; $2c DUP
	.byte $04,$45,$4c,$53,$45              ; $2d ELSE
	.byte $03,$45,$4e,$44                  ; $2e END
	.byte $05,$45,$4e,$44,$49,$46          ; $2f ENDIF
	.byte $03,$46,$4f,$52                  ; $30 FOR
	.byte $02,$49,$46                      ; $31 IF
	.byte $05,$49,$4e,$44,$45,$58          ; $32 INDEX
	.byte $04,$4c,$49,$53,$54              ; $33 LIST
	.byte $03,$4d,$4f,$44                  ; $34 MOD
	.byte $06,$4e,$45,$47,$41,$54,$45      ; $35 NEGATE
	.byte $03,$4e,$45,$57                  ; $36 NEW
	.byte $04,$4e,$45,$58,$54              ; $37 NEXT
	.byte $03,$4e,$49,$50                  ; $38 NIP
	.byte $03,$4e,$4f,$54                  ; $39 NOT
	.byte $03,$4f,$4c,$44                  ; $3a OLD
	.byte $02,$4f,$52                      ; $3b OR
	.byte $04,$4f,$56,$45,$52              ; $3c OVER
	.byte $06,$52,$45,$50,$45,$41,$54      ; $3d REPEAT
	.byte $03,$52,$55,$4e                  ; $3e RUN
	.byte $03,$53,$48,$4c                  ; $3f SHL
	.byte $03,$53,$48,$52                  ; $40 SHR
	.byte $04,$53,$54,$4f,$50              ; $41 STOP
	.byte $04,$53,$57,$41,$50              ; $42 SWAP
	.byte $03,$53,$59,$53                  ; $43 SYS
	.byte $05,$55,$4e,$54,$49,$4c          ; $44 UNTIL
	.byte $02,$57,$21                      ; $45 W!
	.byte $02,$57,$40                      ; $46 W@
	.byte $03,$58,$4f,$52                  ; $47 XOR
	.byte $02,$5b,$5d                      ; $48 []
	.byte $01,$5e                          ; $49 ^
	.byte $01,$2b                          ; $4a {+}
	.byte $01,$2d                          ; $4b {-}
	.byte $00

KeywordVectorTable:
	.word Mem_DPoke                        ; $10 !
	.word SyntaxError                      ; $11 &
	.word MulInteger32                     ; $12 *
	.word Stack_Add                        ; $13 +
	.word Unary_Increment                  ; $14 ++
	.word Stack_Sub                        ; $15 -
	.word Unary_Decrement                  ; $16 --
	.word System_ShowStack                 ; $17 .
	.word DivInteger32                     ; $18 /
	.word SyntaxError                      ; $19 ;
	.word Comp_Less                        ; $1a <
	.word Unary_Shl                        ; $1b <<
	.word Comp_LessEqual                   ; $1c <=
	.word Comp_NotEqual                    ; $1d <>
	.word Comp_Equal                       ; $1e =
	.word Comp_Greater                     ; $1f >
	.word Comp_GreaterEqual                ; $20 >=
	.word Unary_Shr                        ; $21 >>
	.word Mem_DPeek                        ; $22 @
	.word Unary_Absolute                   ; $23 ABS
	.word SyntaxError                      ; $24 ALLOC
	.word Stack_And                        ; $25 AND
	.word System_Assert                    ; $26 ASSERT
	.word Mem_Poke                         ; $27 C!
	.word Mem_Peek                         ; $28 C@
	.word Stack_Empty                      ; $29 CLR
	.word SyntaxError                      ; $2a DEF
	.word Stack_Drop                       ; $2b DROP
	.word Stack_Dup                        ; $2c DUP
	.word SyntaxError                      ; $2d ELSE
	.word System_END                       ; $2e END
	.word SyntaxError                      ; $2f ENDIF
	.word Command_For                      ; $30 FOR
	.word SyntaxError                      ; $31 IF
	.word Command_Index                    ; $32 INDEX
	.word Cmd_List                         ; $33 LIST
	.word ModInteger32                     ; $34 MOD
	.word Unary_Negate                     ; $35 NEGATE
	.word System_New                       ; $36 NEW
	.word Command_Next                     ; $37 NEXT
	.word Stack_Nip                        ; $38 NIP
	.word Unary_Not                        ; $39 NOT
	.word System_Old                       ; $3a OLD
	.word Stack_Or                         ; $3b OR
	.word Stack_Over                       ; $3c OVER
	.word Command_Repeat                   ; $3d REPEAT
	.word System_RUN                       ; $3e RUN
	.word Stack_Shl                        ; $3f SHL
	.word Stack_Shr                        ; $40 SHR
	.word System_STOP                      ; $41 STOP
	.word Stack_Swap                       ; $42 SWAP
	.word System_Sys                       ; $43 SYS
	.word Command_Until                    ; $44 UNTIL
	.word Mem_WPoke                        ; $45 W!
	.word Mem_WPeek                        ; $46 W@
	.word Stack_Xor                        ; $47 XOR
	.word SyntaxError                      ; $48 []
	.word WriteVariable                    ; $49 ^
	.word SyntaxError                      ; $4a {+}
	.word SyntaxError                      ; $4b {-}

KWD_PLING = $10                  ; $10 !
KWD_AMPERSAND = $11              ; $11 &
KWD_ASTERISK = $12               ; $12 *
KWD_PLUS = $13                   ; $13 +
KWD_PLUSPLUS = $14               ; $14 ++
KWD_MINUS = $15                  ; $15 -
KWD_MINUSMINUS = $16             ; $16 --
KWD_DOT = $17                    ; $17 .
KWD_SLASH = $18                  ; $18 /
KWD_SEMICOLON = $19              ; $19 ;
KWD_LESS = $1a                   ; $1a <
KWD_LESSLESS = $1b               ; $1b <<
KWD_LESSEQUAL = $1c              ; $1c <=
KWD_LESSGREATER = $1d            ; $1d <>
KWD_EQUAL = $1e                  ; $1e =
KWD_GREATER = $1f                ; $1f >
KWD_GREATEREQUAL = $20           ; $20 >=
KWD_GREATERGREATER = $21         ; $21 >>
KWD_AT = $22                     ; $22 @
KWD_ABS = $23                    ; $23 ABS
KWD_ALLOC = $24                  ; $24 ALLOC
KWD_AND = $25                    ; $25 AND
KWD_ASSERT = $26                 ; $26 ASSERT
KWD_CPLING = $27                 ; $27 C!
KWD_CAT = $28                    ; $28 C@
KWD_CLR = $29                    ; $29 CLR
KWD_DEF = $2a                    ; $2a DEF
KWD_DROP = $2b                   ; $2b DROP
KWD_DUP = $2c                    ; $2c DUP
KWD_ELSE = $2d                   ; $2d ELSE
KWD_END = $2e                    ; $2e END
KWD_ENDIF = $2f                  ; $2f ENDIF
KWD_FOR = $30                    ; $30 FOR
KWD_IF = $31                     ; $31 IF
KWD_INDEX = $32                  ; $32 INDEX
KWD_LIST = $33                   ; $33 LIST
KWD_MOD = $34                    ; $34 MOD
KWD_NEGATE = $35                 ; $35 NEGATE
KWD_NEW = $36                    ; $36 NEW
KWD_NEXT = $37                   ; $37 NEXT
KWD_NIP = $38                    ; $38 NIP
KWD_NOT = $39                    ; $39 NOT
KWD_OLD = $3a                    ; $3a OLD
KWD_OR = $3b                     ; $3b OR
KWD_OVER = $3c                   ; $3c OVER
KWD_REPEAT = $3d                 ; $3d REPEAT
KWD_RUN = $3e                    ; $3e RUN
KWD_SHL = $3f                    ; $3f SHL
KWD_SHR = $40                    ; $40 SHR
KWD_STOP = $41                   ; $41 STOP
KWD_SWAP = $42                   ; $42 SWAP
KWD_SYS = $43                    ; $43 SYS
KWD_UNTIL = $44                  ; $44 UNTIL
KWD_WPLING = $45                 ; $45 W!
KWD_WAT = $46                    ; $46 W@
KWD_XOR = $47                    ; $47 XOR
KWD_LSQPARENRSQPAREN = $48       ; $48 []
KWD_HAT = $49                    ; $49 ^
KWD_CONSTANT_PLUS = $4a          ; $4a {+}
KWD_CONSTANT_MINUS = $4b         ; $4b {-}
