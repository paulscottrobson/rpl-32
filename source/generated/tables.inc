; *** Generated by tables.py ***

KeywordText:
	.byte $01,$21                          ; $10 !
	.byte $01,$2a                          ; $11 *
	.byte $01,$2b                          ; $12 +
	.byte $02,$2b,$2b                      ; $13 ++
	.byte $01,$2d                          ; $14 -
	.byte $02,$2d,$2d                      ; $15 --
	.byte $01,$2e                          ; $16 .
	.byte $01,$2f                          ; $17 /
	.byte $01,$3b                          ; $18 ;
	.byte $01,$3c                          ; $19 <
	.byte $02,$3c,$3c                      ; $1a <<
	.byte $02,$3c,$3d                      ; $1b <=
	.byte $02,$3c,$3e                      ; $1c <>
	.byte $01,$3d                          ; $1d =
	.byte $01,$3e                          ; $1e >
	.byte $02,$3e,$3d                      ; $1f >=
	.byte $02,$3e,$3e                      ; $20 >>
	.byte $01,$40                          ; $21 @
	.byte $03,$41,$42,$53                  ; $22 ABS
	.byte $05,$41,$4c,$4c,$4f,$43          ; $23 ALLOC
	.byte $03,$41,$4e,$44                  ; $24 AND
	.byte $06,$41,$53,$53,$45,$52,$54      ; $25 ASSERT
	.byte $02,$43,$21                      ; $26 C!
	.byte $02,$43,$40                      ; $27 C@
	.byte $03,$43,$4c,$52                  ; $28 CLR
	.byte $03,$44,$45,$46                  ; $29 DEF
	.byte $04,$44,$52,$4f,$50              ; $2a DROP
	.byte $03,$44,$55,$50                  ; $2b DUP
	.byte $04,$45,$4c,$53,$45              ; $2c ELSE
	.byte $03,$45,$4e,$44                  ; $2d END
	.byte $05,$45,$4e,$44,$49,$46          ; $2e ENDIF
	.byte $03,$46,$4f,$52                  ; $2f FOR
	.byte $02,$49,$46                      ; $30 IF
	.byte $05,$49,$4e,$44,$45,$58          ; $31 INDEX
	.byte $04,$4c,$49,$53,$54              ; $32 LIST
	.byte $04,$4c,$4f,$41,$44              ; $33 LOAD
	.byte $03,$4d,$4f,$44                  ; $34 MOD
	.byte $06,$4e,$45,$47,$41,$54,$45      ; $35 NEGATE
	.byte $03,$4e,$45,$57                  ; $36 NEW
	.byte $04,$4e,$45,$58,$54              ; $37 NEXT
	.byte $03,$4e,$49,$50                  ; $38 NIP
	.byte $03,$4e,$4f,$54                  ; $39 NOT
	.byte $03,$4f,$4c,$44                  ; $3a OLD
	.byte $02,$4f,$52                      ; $3b OR
	.byte $04,$4f,$56,$45,$52              ; $3c OVER
	.byte $08,$52,$45,$4e,$55,$4d,$42,$45,$52 ; $3d RENUMBER
	.byte $06,$52,$45,$50,$45,$41,$54      ; $3e REPEAT
	.byte $06,$52,$45,$54,$55,$52,$4e      ; $3f RETURN
	.byte $03,$52,$55,$4e                  ; $40 RUN
	.byte $04,$53,$41,$56,$45              ; $41 SAVE
	.byte $03,$53,$48,$4c                  ; $42 SHL
	.byte $03,$53,$48,$52                  ; $43 SHR
	.byte $04,$53,$54,$4f,$50              ; $44 STOP
	.byte $04,$53,$57,$41,$50              ; $45 SWAP
	.byte $03,$53,$59,$53                  ; $46 SYS
	.byte $05,$55,$4e,$54,$49,$4c          ; $47 UNTIL
	.byte $02,$57,$21                      ; $48 W!
	.byte $02,$57,$40                      ; $49 W@
	.byte $03,$58,$4f,$52                  ; $4a XOR
	.byte $01,$5b                          ; $4b [
	.byte $01,$5d                          ; $4c ]
	.byte $01,$5e                          ; $4d ^
	.byte $01,$2b                          ; $4e {+}
	.byte $01,$2d                          ; $4f {-}
	.byte $00

KeywordVectorTable:
	.word Mem_DPoke                        ; $10 !
	.word MulInteger32                     ; $11 *
	.word Stack_Add                        ; $12 +
	.word Unary_Increment                  ; $13 ++
	.word Stack_Sub                        ; $14 -
	.word Unary_Decrement                  ; $15 --
	.word System_ShowStack                 ; $16 .
	.word DivInteger32                     ; $17 /
	.word ProcReturn                       ; $18 ;
	.word Comp_Less                        ; $19 <
	.word Unary_Shl                        ; $1a <<
	.word Comp_LessEqual                   ; $1b <=
	.word Comp_NotEqual                    ; $1c <>
	.word Comp_Equal                       ; $1d =
	.word Comp_Greater                     ; $1e >
	.word Comp_GreaterEqual                ; $1f >=
	.word Unary_Shr                        ; $20 >>
	.word Mem_DPeek                        ; $21 @
	.word Unary_Absolute                   ; $22 ABS
	.word SyntaxError                      ; $23 ALLOC
	.word Stack_And                        ; $24 AND
	.word System_Assert                    ; $25 ASSERT
	.word Mem_Poke                         ; $26 C!
	.word Mem_Peek                         ; $27 C@
	.word Stack_Empty                      ; $28 CLR
	.word SyntaxError                      ; $29 DEF
	.word Stack_Drop                       ; $2a DROP
	.word Stack_Dup                        ; $2b DUP
	.word SyntaxError                      ; $2c ELSE
	.word System_END                       ; $2d END
	.word SyntaxError                      ; $2e ENDIF
	.word Command_For                      ; $2f FOR
	.word SyntaxError                      ; $30 IF
	.word Command_Index                    ; $31 INDEX
	.word Cmd_List                         ; $32 LIST
	.word System_Load                      ; $33 LOAD
	.word ModInteger32                     ; $34 MOD
	.word Unary_Negate                     ; $35 NEGATE
	.word System_New                       ; $36 NEW
	.word Command_Next                     ; $37 NEXT
	.word Stack_Nip                        ; $38 NIP
	.word Unary_Not                        ; $39 NOT
	.word System_Old                       ; $3a OLD
	.word Stack_Or                         ; $3b OR
	.word Stack_Over                       ; $3c OVER
	.word SyntaxError                      ; $3d RENUMBER
	.word Command_Repeat                   ; $3e REPEAT
	.word ProcReturn2                      ; $3f RETURN
	.word System_RUN                       ; $40 RUN
	.word System_Save                      ; $41 SAVE
	.word Stack_Shl                        ; $42 SHL
	.word Stack_Shr                        ; $43 SHR
	.word System_STOP                      ; $44 STOP
	.word Stack_Swap                       ; $45 SWAP
	.word System_Sys                       ; $46 SYS
	.word Command_Until                    ; $47 UNTIL
	.word Mem_WPoke                        ; $48 W!
	.word Mem_WPeek                        ; $49 W@
	.word Stack_Xor                        ; $4a XOR
	.word SyntaxError                      ; $4b [
	.word SyntaxError                      ; $4c ]
	.word WriteVariable                    ; $4d ^
	.word SyntaxError                      ; $4e {+}
	.word SyntaxError                      ; $4f {-}

KWD_PLING = $10                  ; $10 !
KWD_ASTERISK = $11               ; $11 *
KWD_PLUS = $12                   ; $12 +
KWD_PLUSPLUS = $13               ; $13 ++
KWD_MINUS = $14                  ; $14 -
KWD_MINUSMINUS = $15             ; $15 --
KWD_DOT = $16                    ; $16 .
KWD_SLASH = $17                  ; $17 /
KWD_SEMICOLON = $18              ; $18 ;
KWD_LESS = $19                   ; $19 <
KWD_LESSLESS = $1a               ; $1a <<
KWD_LESSEQUAL = $1b              ; $1b <=
KWD_LESSGREATER = $1c            ; $1c <>
KWD_EQUAL = $1d                  ; $1d =
KWD_GREATER = $1e                ; $1e >
KWD_GREATEREQUAL = $1f           ; $1f >=
KWD_GREATERGREATER = $20         ; $20 >>
KWD_AT = $21                     ; $21 @
KWD_ABS = $22                    ; $22 ABS
KWD_ALLOC = $23                  ; $23 ALLOC
KWD_AND = $24                    ; $24 AND
KWD_ASSERT = $25                 ; $25 ASSERT
KWD_CPLING = $26                 ; $26 C!
KWD_CAT = $27                    ; $27 C@
KWD_CLR = $28                    ; $28 CLR
KWD_DEF = $29                    ; $29 DEF
KWD_DROP = $2a                   ; $2a DROP
KWD_DUP = $2b                    ; $2b DUP
KWD_ELSE = $2c                   ; $2c ELSE
KWD_END = $2d                    ; $2d END
KWD_ENDIF = $2e                  ; $2e ENDIF
KWD_FOR = $2f                    ; $2f FOR
KWD_IF = $30                     ; $30 IF
KWD_INDEX = $31                  ; $31 INDEX
KWD_LIST = $32                   ; $32 LIST
KWD_LOAD = $33                   ; $33 LOAD
KWD_MOD = $34                    ; $34 MOD
KWD_NEGATE = $35                 ; $35 NEGATE
KWD_NEW = $36                    ; $36 NEW
KWD_NEXT = $37                   ; $37 NEXT
KWD_NIP = $38                    ; $38 NIP
KWD_NOT = $39                    ; $39 NOT
KWD_OLD = $3a                    ; $3a OLD
KWD_OR = $3b                     ; $3b OR
KWD_OVER = $3c                   ; $3c OVER
KWD_RENUMBER = $3d               ; $3d RENUMBER
KWD_REPEAT = $3e                 ; $3e REPEAT
KWD_RETURN = $3f                 ; $3f RETURN
KWD_RUN = $40                    ; $40 RUN
KWD_SAVE = $41                   ; $41 SAVE
KWD_SHL = $42                    ; $42 SHL
KWD_SHR = $43                    ; $43 SHR
KWD_STOP = $44                   ; $44 STOP
KWD_SWAP = $45                   ; $45 SWAP
KWD_SYS = $46                    ; $46 SYS
KWD_UNTIL = $47                  ; $47 UNTIL
KWD_WPLING = $48                 ; $48 W!
KWD_WAT = $49                    ; $49 W@
KWD_XOR = $4a                    ; $4a XOR
KWD_LSQPAREN = $4b               ; $4b [
KWD_RSQPAREN = $4c               ; $4c ]
KWD_HAT = $4d                    ; $4d ^
KWD_CONSTANT_PLUS = $4e          ; $4e {+}
KWD_CONSTANT_MINUS = $4f         ; $4f {-}
